{"file_contents":{"replit.md":{"content":"# Our Legacy - Replit Agent Guide\n\n## Overview\n\nOur Legacy is a text-based CLI fantasy RPG game built primarily in Python. Players create characters from 8 classes (Warrior, Mage, Rogue, Hunter, Bard, Paladin, Druid, Priest), explore areas, fight enemies and bosses, complete missions, craft items, manage companions, farm crops, build housing, and run dungeons. The game is entirely data-driven through JSON files, with a robust mod system that lets users extend or override any game data. It also includes a launcher, a global chat system, a mod downloader (Storyland), a mod uploader (Storywrite), and a GUI wrapper (Py2GUI). A set of serverless API endpoints (Vercel) handle mod uploads, global chat, and a market API.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Core Game Engine (`main.py`)\n- **Single-file Python application** containing the full RPG game loop: character creation, exploration, combat, inventory, quests, crafting, companions, dungeons, farming, housing, cutscenes, and save/load.\n- **Data-driven design**: All game content (classes, items, enemies, bosses, areas, missions, spells, effects, crafting recipes, dungeons, companions, dialogues, cutscenes, housing, farming, weather, weekly challenges, shops) is defined in JSON files under `data/`.\n- **ModManager class** loads mods from `mods/` directory. Each mod has a `mod.json` metadata file and can include any data JSON file. Mod data is merged with base data at load time, allowing additions and overrides.\n- **Localization**: Multi-language support via `data/languages/` with a config file and translation JSON files (English included, with slots for 10 languages).\n- **Save system**: JSON-based saves stored in `data/saves/` with naming pattern `{name}_{uuid}_save_{timestamp}_{class}_{level}.json`.\n\n### Launcher (`launcher.py`)\n- Simple CLI menu that launches the main game, Storyland (mod downloader), Storywrite (mod uploader), or chat via subprocess calls.\n\n### GUI Wrapper (`gui_all.py` + `py2gui.py`)\n- `py2gui.py` is a custom tkinter-based terminal emulator GUI library that replaces `print()` and `input()` with GUI equivalents.\n- `gui_all.py` wraps the launcher and all modules into a single GUI experience by monkey-patching builtins.\n\n### Chat System (`chat.py`)\n- CLI chat client that connects to the global chat API. Uses ANSI colors, threading for real-time updates, and readline for input.\n\n### Mod Ecosystem\n- **Storyland** (`storyland.py`): Downloads mods from GitHub repo `andy64lol/Our_Legacy_Mods` via GitHub API.\n- **Storywrite** (`storywrite.py`): Uploads mods to the repository via a Vercel API endpoint.\n\n### Serverless API (`api/` directory)\n- **Deployed on Vercel** as serverless functions (JavaScript ES modules).\n- `api/ping.js` - Health check endpoint.\n- `api/send_message.js` - Global chat: reads/writes messages to `andy64lol/globalchat` GitHub repo. Includes profanity filtering and message archival (max 100 messages).\n- `api/create_user.js` - User management: creates/reads users stored in the same GitHub repo.\n- `api/upload_test.js` - Mod upload: pushes mod files to GitHub repo with profanity checking.\n- `api/market.js` - Item market API: reads from `api/data/items.json` and filters by type/rarity/class/level.\n- All API functions use **GitHub REST API** with a `GITHUB_REST_API` environment variable for authentication.\n\n### Data File Architecture\nAll game content lives in `data/` as flat JSON files:\n| File | Purpose |\n|------|---------|\n| `classes.json` | Character class definitions with stats and progression |\n| `items.json` | All equipment, consumables, materials |\n| `enemies.json` | Regular enemy definitions |\n| `bosses.json` | Boss encounters with phases and special abilities |\n| `areas.json` | World map locations and connections |\n| `shops.json` | Shop inventories per location |\n| `missions.json` | Quest definitions with prerequisites |\n| `spells.json` | Magic spells with weapon restrictions |\n| `effects.json` | Status effects (poison, stun, buffs) |\n| `companions.json` | Hireable companion NPCs |\n| `crafting.json` | Alchemy recipes |\n| `dialogues.json` | NPC/boss dialogue strings |\n| `dungeons.json` | Procedural dungeon definitions |\n| `cutscenes.json` | Interactive story sequences |\n| `housing.json` | Housing/decoration items |\n| `farming.json` | Crop definitions |\n| `weather.json` | Weather types and bonuses |\n| `weekly_challenges.json` | Recurring challenge definitions |\n\n### Key Design Decisions\n- **No database**: Everything is file-based JSON. Saves, game data, and even the chat/user systems use GitHub repos as storage via API.\n- **Mod merging over replacement**: Mods merge their JSON data with base data rather than replacing it, so multiple mods can coexist.\n- **Subprocess isolation**: The launcher runs each module (game, chat, storyland, storywrite) as a separate subprocess to avoid state conflicts.\n- **Weather/Time system**: Partially implemented (TODO.md tracks progress). Weather data exists in `data/weather.json` but full integration is in progress.\n\n## External Dependencies\n\n### Python Dependencies\n- **Standard library only** for the core game: `json`, `os`, `random`, `sys`, `time`, `uuid`, `datetime`, `difflib`, `signal`, `traceback`, `io`\n- `requests` - Used by storyland.py, storywrite.py, and chat.py for HTTP calls\n- `tkinter` - Used by py2gui.py for the GUI wrapper\n- `readline` - Used by chat.py for input handling\n\n### Node.js / JavaScript Dependencies\n- `@supabase/supabase-js` (^2.95.3) - Listed in package.json but not visibly used in current API code\n- `octokit` (^3.2.2) - Listed in package.json but API files use raw fetch with GitHub REST API instead\n\n### External Services\n- **GitHub REST API**: Core backend storage for chat messages, user data, and mod uploads. Requires `GITHUB_REST_API` environment variable (personal access token).\n  - Repo `andy64lol/globalchat` - Stores chat messages (`global_chat.json`) and users (`users.json`)\n  - Repo `andy64lol/Our_Legacy_Mods` - Stores community mods\n- **Vercel**: Hosts the serverless API functions in the `api/` directory\n- **Profanity filter**: Fetches word list from `github.com/zautumnz/profane-words` at runtime for chat and mod upload filtering\n\n### Running the Project\n- **Main game**: `python3 main.py`\n- **Launcher**: `python3 launcher.py`\n- **GUI version**: `python3 gui_all.py`\n- **Chat**: `python3 chat.py`\n- **Mod downloader**: `python3 storyland.py`\n- **Mod uploader**: `python3 storywrite.py`\n- **npm start**: Runs `python3 main.py`","path":null,"size_bytes":6553,"size_tokens":null},"DOCS_INDEX.md":{"content":"# Our Legacy - Documentation Index\n\nWelcome to Our Legacy! This is your complete guide to understanding, playing, and modding the game.\n\n---\n\n## ðŸ“š Documentation Files\n\n### 1. **README.md** - Start Here!\n**Quick Overview of the Game**\n- Game features and character classes\n- Installation and quick start\n- File structure overview\n- Mod system introduction\n\nðŸ‘‰ **For**: Players new to the game, people curious about what Our Legacy is\n\n---\n\n### 2. **documentation.md** - Complete Reference (937 lines)\n**Comprehensive Guide to All Game Systems**\n- All 11 data files explained with full parameter lists\n- Complete examples for each file type\n- Mod system documentation\n- How mods are loaded and merged\n- Best practices for development\n\n**Sections**:\n- âœ… Classes.json - Character definitions\n- âœ… Items.json - Equipment and consumables\n- âœ… Enemies.json - Regular encounters\n- âœ… Bosses.json - Boss encounters with phases\n- âœ… Areas.json - World locations\n- âœ… Missions.json - Quest system\n- âœ… Dialogues.json - Text content\n- âœ… Dungeons.json - Procedural dungeons\n- âœ… Crafting.json - Alchemy recipes\n- âœ… Spells.json - Magic system\n- âœ… Companions.json - Party members\n- âœ… Mod system explanation with examples\n\nðŸ‘‰ **For**: Modders, developers, anyone who wants to understand the complete system\n\n---\n\n### 3. **MOD_CREATION_GUIDE.md** - Quick Start (400+ lines)\n**Fast Reference for Creating Mods**\n- Step-by-step mod creation\n- Copy-paste ready templates for:\n  - New bosses\n  - New dungeons\n  - New items\n  - New areas\n  - New enemies\n  - New classes\n  - New recipes\n- Parameter quick reference\n- Common issues and fixes\n\nðŸ‘‰ **For**: Modders who want to create content quickly\n\n---\n\n## ðŸŽ® Getting Started\n\n### Players\n1. Read [README.md](README.md) for game overview\n2. Run `python3 main.py`\n3. Create character and explore!\n\n### Modders - Quick Start\n1. Read [MOD_CREATION_GUIDE.md](MOD_CREATION_GUIDE.md) - 5 minute overview\n2. Follow \"Quick Start: Create Your First Mod\"\n3. Copy a template for your content type\n4. Test and iterate!\n\n### Modders - Deep Dive\n1. Read [MOD_CREATION_GUIDE.md](MOD_CREATION_GUIDE.md) for basics\n2. Study [documentation.md](documentation.md) for complete reference\n3. Review examples in each section\n4. Check `mods/The Ether/` for complete mod example\n\n### Developers\n1. Review [documentation.md](documentation.md) for complete data structure\n2. Check [README.md](README.md) file structure section\n3. Study mod loading code in `main.py` (lines 1195-1257)\n4. Review existing mods for patterns\n\n---\n\n## ðŸ“‹ Data Files Reference\n\n| File | Purpose | Documented In | Best For |\n|------|---------|---------------|---------| \n| **classes.json** | Character classes | documentation.md | Understanding character progression |\n| **items.json** | Equipment & consumables | documentation.md | Creating new gear |\n| **enemies.json** | Regular encounters | documentation.md | Creating new enemies |\n| **bosses.json** | Boss battles | documentation.md | Creating challenging encounters |\n| **areas.json** | World locations | documentation.md | Adding new locations |\n| **missions.json** | Quests | documentation.md | Creating quest content |\n| **dialogues.json** | Text dialogue | documentation.md | Adding story text |\n| **dungeons.json** | Procedural dungeons | documentation.md | Creating complex dungeons |\n| **crafting.json** | Alchemy system | documentation.md | Adding recipes |\n| **spells.json** | Magic abilities | documentation.md | Creating spells |\n| **companions.json** | Party members | documentation.md | Adding companions |\n| **housing.json** | Home building items | documentation.md | Creating housing items |\n| **effects.json** | Status effects | documentation.md | Creating buffs/debuffs |\n| **farming.json** | Crop definitions | documentation.md | Adding farm crops |\n| **weekly_challenges.json** | Recurring challenges | documentation.md | Creating challenges |\n\n---\n\n## ðŸŽ¯ Common Tasks\n\n### I want to...\n\n**Understand how the game works**\nâ†’ Read [README.md](README.md)\n\n**Create my first mod**\nâ†’ Follow [MOD_CREATION_GUIDE.md](MOD_CREATION_GUIDE.md) Quick Start\n\n**Add a new boss**\nâ†’ See boss template in [MOD_CREATION_GUIDE.md](MOD_CREATION_GUIDE.md)\n\n**Add a new dungeon with challenges**\nâ†’ See dungeon template in [MOD_CREATION_GUIDE.md](MOD_CREATION_GUIDE.md)\n\n**Understand all available parameters**\nâ†’ Read [documentation.md](documentation.md) parameter sections\n\n**See a complete example**\nâ†’ Check `mods/The Ether/` for Ethereal Spire dungeon example\n\n**Learn about the mod system**\nâ†’ See \"Mod System\" section in [documentation.md](documentation.md)\n\n**Understand how mods are loaded**\nâ†’ See \"How Mods Load\" in [README.md](README.md) or [documentation.md](documentation.md)\n\n**Troubleshoot my mod**\nâ†’ Check \"Testing Your Mod\" and \"Common Issues\" in [MOD_CREATION_GUIDE.md](MOD_CREATION_GUIDE.md)\n\n---\n\n## ðŸ”— Quick Links\n\n### Documentation\n- ðŸ“– [Complete Reference](documentation.md) - 937 lines of detailed info\n- âš¡ [Quick Guide](MOD_CREATION_GUIDE.md) - Fast templates and reference\n- ðŸ“± [Game Overview](README.md) - Features and structure\n\n### Main Game\n- ðŸŽ® [Main Game](main.py) - Core game engine\n- ðŸ“Š [Base Data](data/) - All game data files\n- ðŸŽ¯ [Example Content](mods/The%20Ether/) - Study this mod!\n\n---\n\n## ðŸ“Š Documentation Statistics\n\n| Aspect | Coverage |\n|--------|----------|\n| Data Files | 15/15 files documented âœ… |\n| Parameters | All parameters listed âœ… |\n| Examples | Examples for each file type âœ… |\n| Templates | 9 complete templates âœ… |\n| Mod System | Fully explained âœ… |\n| Best Practices | Complete guide âœ… |\n| Troubleshooting | Common issues covered âœ… |\n\n---\n\n## ðŸš€ Next Steps\n\n1. **Start with your interest level**:\n   - Curious? â†’ [README.md](README.md)\n   - Want to create? â†’ [MOD_CREATION_GUIDE.md](MOD_CREATION_GUIDE.md)\n   - Need complete info? â†’ [documentation.md](documentation.md)\n\n2. **Choose your action**:\n   - Play the game\n   - Create a mod\n   - Study the system\n   - Contribute to community\n\n3. **Get help**:\n   - Check the relevant doc section\n   - Review example mods\n   - Test in-game\n   - Iterate and improve\n\n---\n\n## ðŸ“ File Manifest\n\n```\nOur_Legacy/\nâ”œâ”€â”€ README.md                      â† Game overview, start here!\nâ”œâ”€â”€ documentation.md               â† Complete reference (937 lines)\nâ”œâ”€â”€ MOD_CREATION_GUIDE.md          â† Quick start templates\nâ”œâ”€â”€ DOCUMENTATION_UPDATES.md       â† What was updated\nâ”œâ”€â”€ main.py                        â† Game engine\nâ”œâ”€â”€ data/                          â† Base game content\nâ”œâ”€â”€ mods/                          â† Player mods\nâ”‚   â””â”€â”€ The Ether/                â† Example mod\nâ””â”€â”€ ...\n```\n\n---\n\n## ðŸ’¡ Pro Tips\n\n1. **Read in order**: README â†’ MOD_CREATION_GUIDE â†’ documentation.md\n2. **Use templates**: Copy-paste from MOD_CREATION_GUIDE.md for quick start\n3. **Study examples**: Check \"The Ether\" mod in mods/ folder\n4. **Validate JSON**: Always check syntax before testing\n5. **Test locally**: Create character to see your mod content\n6. **Iterate**: Update and improve based on gameplay\n\n---\n\n## ðŸŽ“ Learning Path\n\n**Beginner**: README.md â†’ MOD_CREATION_GUIDE.md â†’ Create first mod\n**Intermediate**: MOD_CREATION_GUIDE.md â†’ documentation.md â†’ Create complex mod\n**Advanced**: documentation.md â†’ Study existing mods â†’ Contribute to community\n\n---\n\n## ðŸ“ž Support\n\n- **Questions about gameplay?** â†’ See README.md\n- **Need mod creation help?** â†’ Check MOD_CREATION_GUIDE.md\n- **Need parameter details?** â†’ Search documentation.md\n- **Can't find something?** â†’ Check DOCUMENTATION_UPDATES.md\n\n---\n\n**Ready to dive in? Start with [README.md](README.md)!**\n\n**Want to create? Go to [MOD_CREATION_GUIDE.md](MOD_CREATION_GUIDE.md)!**\n\n**Need complete details? Read [documentation.md](documentation.md)!**\n","path":null,"size_bytes":7890,"size_tokens":null},"main.py":{"content":"\"\"\"\nOur Legacy - Text-Based CLI Fantasy RPG Game\nA comprehensive exploration and grinding-driven RPG experience\n\"\"\"\n\nimport json\nimport os\nimport random\nimport sys\nimport time\nimport uuid\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any, Optional\nimport difflib\nimport signal\nimport traceback\nimport io\n\n# Default settings\nDEFAULT_SETTINGS = {\n    \"mods_enabled\": True,\n    \"disabled_mods\": [],\n    \"overwrite_save_by_uuid\": False\n}\n\n\nclass ModManager:\n    \"\"\"Manages mod loading and data merging\"\"\"\n\n    def __init__(self):\n        self.mods_dir = \"mods\"\n        self.mods: Dict[str, Dict[str, Any]] = {}\n        self.enabled_mods: List[str] = []\n        self.settings_file = \"data/mod_settings.json\"\n        self.settings = DEFAULT_SETTINGS.copy()\n        self.load_settings()\n\n    def load_settings(self):\n        \"\"\"Load mod settings from file\"\"\"\n        try:\n            if os.path.exists(self.settings_file):\n                with open(self.settings_file, 'r') as f:\n                    loaded_settings = json.load(f)\n                    # Merge with defaults\n                    self.settings.update(loaded_settings)\n        except (json.JSONDecodeError, IOError):\n            self.settings = DEFAULT_SETTINGS.copy()\n\n    def save_settings(self):\n        \"\"\"Save mod settings to file\"\"\"\n        try:\n            os.makedirs(os.path.dirname(self.settings_file), exist_ok=True)\n            with open(self.settings_file, 'w') as f:\n                json.dump(self.settings, f, indent=2)\n        except IOError as e:\n            print(f\"Error saving mod settings: {e}\")\n\n    def discover_mods(self):\n        \"\"\"Discover all mods in the mods directory\"\"\"\n        self.mods = {}\n        self.enabled_mods = []\n\n        if not os.path.exists(self.mods_dir):\n            return\n\n        for entry in os.listdir(self.mods_dir):\n            mod_path = os.path.join(self.mods_dir, entry)\n            if os.path.isdir(mod_path):\n                mod_json_path = os.path.join(mod_path, \"mod.json\")\n                if os.path.exists(mod_json_path):\n                    try:\n                        with open(mod_json_path, 'r') as f:\n                            mod_data = json.load(f)\n                            mod_data['mod_path'] = mod_path\n                            mod_data['folder_name'] = entry\n                            self.mods[entry] = mod_data\n                    except (json.JSONDecodeError, IOError):\n                        print(f\"Warning: Failed to load mod.json for {entry}\")\n\n    def get_enabled_mods(self) -> List[str]:\n        \"\"\"Get list of enabled mod folder names\"\"\"\n        if not self.settings.get(\"mods_enabled\", True):\n            return []\n\n        disabled = set(self.settings.get(\"disabled_mods\", []))\n        return [name for name in self.mods.keys() if name not in disabled]\n\n    def load_mod_data(self, data_type: str) -> Dict[str, Any]:\n        \"\"\"Load and merge data from all enabled mods for a specific data type\"\"\"\n        merged_data = {}\n\n        for mod_name in self.get_enabled_mods():\n            mod = self.mods.get(mod_name)\n            if not mod:\n                continue\n\n            mod_path = mod.get('mod_path', '')\n            file_path = os.path.join(mod_path, data_type)\n\n            if os.path.exists(file_path):\n                try:\n                    with open(file_path, 'r') as f:\n                        mod_data = json.load(f)\n\n                        # Add mod prefix to prevent conflicts\n                        for key, value in mod_data.items():\n                            # Check if key already exists in base data (for validation only)\n                            # We still add it to allow mod-to-mod interaction\n                            new_key = f\"{mod_name}_{key}\" if key in merged_data else key\n                            merged_data[new_key] = value\n\n                except (json.JSONDecodeError, IOError) as e:\n                    print(\n                        f\"Warning: Failed to load {data_type} from mod {mod_name}: {e}\"\n                    )\n\n        return merged_data\n\n    def get_mod_list(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of all mods with their metadata and status\"\"\"\n        mods_list = []\n        enabled = self.get_enabled_mods()\n        disabled = set(self.settings.get(\"disabled_mods\", []))\n\n        for name, mod in self.mods.items():\n            mods_list.append({\n                'folder_name':\n                name,\n                'name':\n                mod.get('name', name),\n                'description':\n                mod.get('description', ''),\n                'author':\n                mod.get('author', 'Unknown'),\n                'version':\n                mod.get('version', '1.0'),\n                'enabled':\n                name in enabled and self.settings.get(\"mods_enabled\", True),\n                'mod_path':\n                mod.get('mod_path', '')\n            })\n\n        return mods_list\n\n    def toggle_mod(self, folder_name: str):\n        \"\"\"Toggle a mod's enabled state\"\"\"\n        disabled = set(self.settings.get(\"disabled_mods\", []))\n\n        if folder_name in disabled:\n            disabled.remove(folder_name)\n            print(f\"Mod enabled: {folder_name}\")\n        else:\n            disabled.add(folder_name)\n            print(f\"Mod disabled: {folder_name}\")\n\n        self.settings[\"disabled_mods\"] = list(disabled)\n        self.save_settings()\n\n    def toggle_mods_system(self):\n        \"\"\"Toggle the entire mods system on/off\"\"\"\n        self.settings[\"mods_enabled\"] = not self.settings.get(\n            \"mods_enabled\", True)\n        status = \"enabled\" if self.settings[\"mods_enabled\"] else \"disabled\"\n        print(f\"Mod system {status}!\")\n        self.save_settings()\n        return self.settings[\"mods_enabled\"]\n\n\n# Optional HTTP library for market API\ntry:\n    import requests\n    REQUESTS_AVAILABLE = True\nexcept ImportError:\n    requests = None\n    REQUESTS_AVAILABLE = False\n    try:\n        import urllib.request\n        import urllib.parse\n    except ImportError:\n        pass\n\n# Optional readline for tab-completion (best-effort)\ntry:\n    import readline\nexcept Exception:\n    readline = None\n\n# Global color toggle\nCOLORS_ENABLED = True\n\n\nclass Colors:\n    \"\"\"ANSI color codes for terminal output\"\"\"\n    RED = '\\033[91m'\n    GREEN = '\\033[92m'\n    YELLOW = '\\033[93m'\n    BLUE = '\\033[94m'\n    MAGENTA = '\\033[95m'\n    CYAN = '\\033[96m'\n    WHITE = '\\033[97m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n    END = '\\033[0m'\n    GOLD = '\\033[93m'\n    ORANGE = '\\033[38;5;208m'\n    PURPLE = '\\033[95m'\n    DARK_GRAY = '\\033[90m'\n    LIGHT_GRAY = '\\033[37m'\n    GRAY = '\\033[90m'  # Alias for DARK_GRAY\n\n    # Rarity colors for items\n    COMMON = '\\033[37m'  # White\n    UNCOMMON = '\\033[92m'  # Green\n    RARE = '\\033[94m'  # Blue\n    EPIC = '\\033[95m'  # Magenta\n    LEGENDARY = '\\033[93m'  # Gold\n\n    @staticmethod\n    def _color(code: str) -> str:\n        \"\"\"Return color code if colors are enabled, otherwise empty string\"\"\"\n        global COLORS_ENABLED\n        return code if COLORS_ENABLED else \"\"\n\n\ndef clear_screen():\n    \"\"\"Clear the terminal screen in a cross-platform way.\"\"\"\n    time.sleep(1)\n    command = 'cls' if os.name == 'nt' else 'clear'\n    os.system(command)\n\n\ndef create_progress_bar(current: int,\n                        maximum: int,\n                        width: int = 20,\n                        color: str = Colors.GREEN) -> str:\n    \"\"\"Create a visual progress bar.\"\"\"\n    if maximum <= 0:\n        return \"[\" + \" \" * width + \"]\"\n\n    filled_width = int((current / maximum) * width)\n    filled = \"â–ˆ\" * filled_width\n    empty = \"â–‘\" * (width - filled_width)\n    percentage = (current / maximum) * 100\n\n    return f\"[{color}{filled}{Colors.END}{empty}] {percentage:.1f}%\"\n\n\ndef create_boss_hp_bar(current: int,\n                       maximum: int,\n                       width: int = 40,\n                       color: str = Colors.RED) -> str:\n    \"\"\"Create a wide, epic visual HP bar for bosses.\"\"\"\n    if maximum <= 0:\n        return \"[\" + \" \" * width + \"]\"\n\n    filled_width = int((current / maximum) * width)\n    filled = \"â–ˆ\" * filled_width\n    empty = \"â–‘\" * (width - filled_width)\n    percentage = (current / maximum) * 100\n\n    return f\"{Colors.BOLD}{Colors.RED}BOSS HP{Colors.END} [{color}{filled}{Colors.END}{empty}] {Colors.BOLD}{percentage:.1f}%{Colors.END} ({current}/{maximum})\"\n\n\ndef create_hp_mp_bar(current: int,\n                     maximum: int,\n                     width: int = 15,\n                     color: str = Colors.RED) -> str:\n    \"\"\"Create a visual HP/MP bar.\"\"\"\n    if maximum <= 0:\n        return \"[\" + \" \" * width + \"]\"\n\n    filled_width = int((current / maximum) * width)\n    filled = \"â–ˆ\" * filled_width\n    empty = \"â–‘\" * (width - filled_width)\n\n    return f\"[{color}{filled}{Colors.END}{empty}] {current}/{maximum}\"\n\n\ndef create_separator(char: str = \"=\", length: int = 60) -> str:\n    \"\"\"Create a visual separator line.\"\"\"\n    return char * length\n\n\ndef create_section_header(title: str, char: str = \"=\", width: int = 60) -> str:\n    \"\"\"Create a decorative section header.\"\"\"\n    padding = (width - len(title) - 2) // 2\n    return f\"{Colors.CYAN}{Colors.BOLD}{char * padding} {title} {char * padding}{Colors.END}\"\n\n\ndef loading_indicator(message: str = \"Loading\"):\n    \"\"\"Display a loading indicator.\"\"\"\n    print(f\"\\n{Colors.YELLOW}{message}{Colors.END}\", end=\"\", flush=True)\n    for i in range(3):\n        time.sleep(0.5)\n        print(\".\", end=\"\", flush=True)\n    print()\n\n\ndef get_rarity_color(rarity: str) -> str:\n    \"\"\"Get the color for an item rarity.\"\"\"\n    rarity_colors = {\n        \"common\": Colors.COMMON,\n        \"uncommon\": Colors.UNCOMMON,\n        \"rare\": Colors.RARE,\n        \"epic\": Colors.EPIC,\n        \"legendary\": Colors.LEGENDARY\n    }\n    return rarity_colors.get(rarity.lower(), Colors.WHITE)\n\n\ndef format_item_name(item_name: str, rarity: str = \"common\") -> str:\n    \"\"\"Format item name with rarity color.\"\"\"\n    color = get_rarity_color(rarity)\n    return f\"{color}{item_name}{Colors.END}\"\n\n\n    def ask(self, prompt: str,\n            valid_choices: Optional[List[str]] = None,\n            allow_empty: bool = True,\n            case_sensitive: bool = False,\n            suggest: bool = True) -> str:\n        \"\"\"Prompt the user for input with optional validation and suggestions.\"\"\"\n        # Advance time by 1 hour for each action if player exists\n        if hasattr(self, 'player') and self.player:\n            self.player.advance_time(1)\n\n        while True:\n            try:\n                # Translate prompt if it's a key\n                translated_prompt = self.lang.get(prompt, prompt) if hasattr(self, 'lang') else prompt\n                response = input(translated_prompt)\n            except EOFError:\n                response = ''\n\n            resp = response.strip()\n\n            # Normalize for comparison if case-insensitive\n            cmp_resp = resp if case_sensitive else resp.lower()\n            # Ensure cmp_choices is always a list[str] for safe membership checks\n            cmp_choices: List[str] = []\n            if valid_choices:\n                cmp_choices = [\n                    c if case_sensitive else c.lower() for c in valid_choices\n                ]\n\n            # Empty handling\n            if not resp and allow_empty:\n                clear_screen()\n                return resp\n            if not resp and not allow_empty:\n                print(\"Input cannot be empty. Please try again.\")\n                continue\n\n            # If no validation requested, accept\n            if not valid_choices:\n                clear_screen()\n                return resp\n\n            # Exact match\n            if cmp_choices and cmp_resp in cmp_choices:\n                clear_screen()\n                return resp\n\n            # If suggestions enabled, show closest matches\n            if suggest and cmp_choices:\n                close = difflib.get_close_matches(cmp_resp,\n                                                  cmp_choices,\n                                                  n=3,\n                                                  cutoff=0.4)\n                if close:\n                    print(f\"Invalid input. Did you mean: {', '.join(close)} ?\")\n                else:\n                    print(\n                        f\"Invalid input. Allowed choices: {', '.join(cmp_choices)}\"\n                    )\n            else:\n                # Fallback to showing valid choices if available\n                print(\n                    f\"Invalid input. Allowed choices: {', '.join(cmp_choices or [])}\"\n                )\n\n        # Retry loop\n\n\ndef _make_completer(options: List[str]):\n    \"\"\"Return a simple readline completer for the provided options.\"\"\"\n    if not readline:\n        return None\n\n    opts = sorted(options)\n\n    def completer(text, state):\n        matches = [o for o in opts if o.startswith(text)]\n        try:\n            return matches[state]\n        except IndexError:\n            return None\n\n    return completer\n\n\ndef enable_tab_completion(options: List[str]):\n    \"\"\"Enable tab-completion for a short period (best-effort).\"\"\"\n    if not readline:\n        return None\n    completer = _make_completer(options)\n    if completer:\n        readline.set_completer(completer)\n        readline.parse_and_bind('tab: complete')\n        return completer\n    return None\n\n\ndef disable_tab_completion(prev_completer):\n    \"\"\"Restore previous completer (if any).\"\"\"\n    if not readline:\n        return\n    readline.set_completer(prev_completer)\n\n\n# Market API URL and cooldown (set by Game class when game starts)\ngame_api = None\n\n# Market API URL and cooldown\nMARKET_API_URL = \"https://our-legacy.vercel.app/api/market\"\nMARKET_COOLDOWN_MINUTES = 10\n\n\nclass MarketAPI:\n    \"\"\"API for accessing the Elite Market with 10-minute cooldown\"\"\"\n\n    def __init__(self):\n        self.cache = None\n        self.last_fetch = None\n        self.cooldown_minutes = MARKET_COOLDOWN_MINUTES\n\n    def _is_cache_valid(self) -> bool:\n        \"\"\"Check if cache is still valid (within cooldown period)\"\"\"\n        if not self.last_fetch or not self.cache:\n            return False\n        elapsed = datetime.now() - self.last_fetch\n        return elapsed < timedelta(minutes=self.cooldown_minutes)\n\n    def fetch_market_data(self,\n                          force_refresh: bool = False\n                          ) -> Optional[Dict[str, Any]]:\n        \"\"\"Fetch market data from the API with caching and cooldown\"\"\"\n        # Check cache validity\n        if not force_refresh and self._is_cache_valid():\n            print(f\"{Colors.CYAN}Visiting the market...{Colors.END}\")\n            return self.cache\n\n        # Check cooldown\n        if self.last_fetch and not self._is_cache_valid():\n            remaining = timedelta(minutes=self.cooldown_minutes) - (\n                datetime.now() - self.last_fetch)\n            mins = int(remaining.total_seconds() // 60)\n            secs = int(remaining.total_seconds() % 60)\n            print(\n                f\"{Colors.YELLOW}Merchants have left and the market is closed! Please come back in {mins}m {secs}s{Colors.END}\"\n            )\n            return None\n\n        print(\n            f\"{Colors.CYAN}Checking if merchants are in the market...{Colors.END}\"\n        )\n\n        # Try to fetch from API using requests\n        if REQUESTS_AVAILABLE and requests is not None:\n            try:\n                response = requests.get(MARKET_API_URL, timeout=10)\n                if response.status_code == 200:\n                    data = response.json()\n                    self.cache = data\n                    self.last_fetch = datetime.now()\n                    print(f\"{Colors.GREEN}Market is open!{Colors.END}\")\n                    return data\n                else:\n                    print(\n                        f\"{Colors.RED}Failed to reach to the market: HTTP {response.status_code}{Colors.END}\"\n                    )\n            except requests.exceptions.RequestException as e:\n                print(f\"{Colors.RED}Network error: {e}{Colors.END}\")\n        else:\n            # Fallback using urllib\n            try:\n                import urllib.request\n                req = urllib.request.Request(MARKET_API_URL)\n                with urllib.request.urlopen(req, timeout=10) as response:\n                    data = json.loads(response.read().decode())\n                    self.cache = data\n                    self.last_fetch = datetime.now()\n                    print(f\"{Colors.GREEN}Market is open! {Colors.END}\")\n                    return data\n            except Exception as e:\n                print(f\"{Colors.RED}Network error: {e}{Colors.END}\")\n\n        return None\n\n    def get_cooldown_remaining(self) -> Optional[timedelta]:\n        \"\"\"Get remaining cooldown time\"\"\"\n        if not self.last_fetch:\n            return None\n        elapsed = datetime.now() - self.last_fetch\n        remaining = timedelta(minutes=self.cooldown_minutes) - elapsed\n        if remaining.total_seconds() > 0:\n            return remaining\n        return None\n\n    def get_all_items(self) -> List[Dict[str, Any]]:\n        \"\"\"Get all market items\"\"\"\n        data = self.fetch_market_data()\n        if data and data.get('ok'):\n            return data.get('items', [])\n        return []\n\n    def filter_items(self,\n                     item_type: Optional[str] = None,\n                     rarity: Optional[str] = None,\n                     class_req: Optional[str] = None,\n                     max_price: Optional[int] = None) -> List[Dict[str, Any]]:\n        \"\"\"Get filtered market items\"\"\"\n        data = self.fetch_market_data()\n        if not data or not data.get('ok'):\n            return []\n\n        items = data.get('items', [])\n\n        filtered = []\n        for item in items:\n            if item_type and item.get('type', '').lower() != item_type.lower():\n                continue\n            if rarity and item.get('rarity', '').lower() != rarity.lower():\n                continue\n            if class_req:\n                req = item.get('requirements') or {}\n                if req.get('class', '').lower() != class_req.lower():\n                    continue\n            if max_price and item.get('marketPrice', 0) > max_price:\n                continue\n            filtered.append(item)\n\n        return filtered\n\n    def get_items_by_type(self) -> Dict[str, List[Dict[str, Any]]]:\n        \"\"\"Get items grouped by type\"\"\"\n        data = self.fetch_market_data()\n        if data and data.get('ok'):\n            return data.get('itemsByType', {})\n        return {}\n\n\nclass Character:\n    \"\"\"Player character class\"\"\"\n\n    def __init__(self,\n                 name: str,\n                 character_class: str,\n                 classes_data: Optional[Dict] = None,\n                 player_uuid: Optional[str] = None):\n        self.name = name\n        self.character_class = character_class\n        self.uuid = player_uuid or str(uuid.uuid4())\n        # Rank system based on level\n        self.rank = \"F tier adventurer\"\n        self.level = 1\n        self.experience = 0\n        self.experience_to_next = 100\n        self.class_data = {}\n        self.level_up_bonuses = {}\n\n        # Load class data if provided\n        if classes_data and character_class in classes_data:\n            self.class_data = classes_data[character_class]\n            stats = self.class_data.get(\"base_stats\", {})\n            self.level_up_bonuses = self.class_data.get(\"level_up_bonuses\", {})\n        else:\n            # Fallback defaults\n            default_stats = {\n                \"hp\": 100,\n                \"mp\": 50,\n                \"attack\": 10,\n                \"defense\": 8,\n                \"speed\": 10\n            }\n            stats = default_stats\n\n        self.max_hp = stats.get(\"hp\", 100)\n        self.hp = self.max_hp\n        self.max_mp = stats.get(\"mp\", 50)\n        self.mp = self.max_mp\n        self.attack = stats.get(\"attack\", 10)\n        self.defense = stats.get(\"defense\", 8)\n        self.speed = stats.get(\"speed\", 10)\n\n        # Equipment slots (legacy compatibility)\n        self.weapon = None\n        self.armor = None\n        self.offhand = None\n        # Legacy single accessory points to accessory_1 for compatibility\n        self.accessory = None\n\n        # Inventory and gold\n        self.inventory = []\n        self.gold = 100  # Starting gold\n        # Save base stats so equipment bonuses can be recalculated\n        self.base_max_hp = self.max_hp\n        self.base_max_mp = self.max_mp\n        self.base_attack = self.attack\n        self.base_defense = self.defense\n        self.base_speed = self.speed\n\n        # Equipped items are stored by slot name\n        # Support 1 weapon, 1 armor, 1 offhand, 3 accessories, and companions\n        self.equipment: Dict[str, Optional[str]] = {\n            \"weapon\": None,\n            \"armor\": None,\n            \"offhand\": None,\n            \"accessory_1\": None,\n            \"accessory_2\": None,\n            \"accessory_3\": None\n        }\n\n        # Companions (4 max) - now storing full companion data\n        # Each companion is {id, name, equipment: {weapon, armor, accessory}, level}\n        self.companions: List[Dict[str, Any]] = []\n\n        # Battle state\n        self.defending = False\n\n        # Active temporary buffs/debuffs: list of {name, duration, modifiers}\n        # modifiers is a dict like {\"attack_bonus\": 5, \"defense_bonus\": 2}\n        self.active_buffs: List[Dict[str, Any]] = []\n\n        # Track killed bosses for cooldown: {boss_name: timestamp_str}\n        self.bosses_killed: Dict[str, str] = {}\n\n        # Housing system: track owned housing items and comfort points\n        self.housing_owned: List[str] = []  # List of housing item IDs owned\n        self.comfort_points: int = 0  # Total comfort points from housing\n\n        # Building slots: what's placed in each slot (None if empty)\n        # Key format: \"house_1\", \"house_2\", \"house_3\", etc.\n        self.building_slots: Dict[str, Optional[str]] = {\n            \"house_1\": None,\n            \"house_2\": None,\n            \"house_3\": None,\n            \"decoration_1\": None,\n            \"decoration_2\": None,\n            \"decoration_3\": None,\n            \"decoration_4\": None,\n            \"decoration_5\": None,\n            \"decoration_6\": None,\n            \"decoration_7\": None,\n            \"decoration_8\": None,\n            \"decoration_9\": None,\n            \"decoration_10\": None,\n            \"fencing_1\": None,\n            \"garden_1\": None,\n            \"garden_2\": None,\n            \"garden_3\": None,\n            \"farm_1\": None,\n            \"farm_2\": None,\n            \"training_place_1\": None,\n            \"training_place_2\": None,\n            \"training_place_3\": None,\n        }\n\n        # Farming system: track planted crops and their growth time\n        # Format: {farm_slot_id: [{\"crop\": \"wheat\", \"days_left\": 3}, ...]}\n        self.farm_plots: Dict[str, List[Dict[str, Any]]] = {\n            \"farm_1\": [],\n            \"farm_2\": [],\n        }\n\n        # Sync legacy equipment slots with new system for compatibility\n        self._sync_equipment_slots()\n\n    def _sync_equipment_slots(self):\n        \"\"\"Sync legacy equipment slots with new equipment dictionary for compatibility\"\"\"\n        # This ensures backward compatibility with any code that might use the old slots\n        self.weapon = self.equipment.get(\"weapon\")\n        self.armor = self.equipment.get(\"armor\")\n        # Map legacy single accessory to accessory_1\n        self.accessory = self.equipment.get(\"accessory_1\")\n        self.offhand = self.equipment.get(\"offhand\")\n\n    def _update_equipment_slots(self):\n        \"\"\"Update legacy equipment slots when equipment dictionary changes\"\"\"\n        self.weapon = self.equipment.get(\"weapon\")\n        self.armor = self.equipment.get(\"armor\")\n        self.accessory = self.equipment.get(\"accessory_1\")\n        self.offhand = self.equipment.get(\"offhand\")\n\n    def is_alive(self) -> bool:\n        \"\"\"Check if character is alive\"\"\"\n        return self.hp > 0\n\n    def take_damage(self, damage: int) -> int:\n        \"\"\"Apply damage to character, return actual damage taken\"\"\"\n        # Use effective defense (includes buffs)\n        base_damage = max(1, damage - self.get_effective_defense())\n\n        remaining = base_damage\n\n        # Consume any absorb shields from active buffs first\n        for b in list(self.active_buffs):\n            mods = b.get('modifiers', {})\n            if remaining <= 0:\n                break\n            if 'absorb_amount' in mods and mods.get('absorb_amount', 0) > 0:\n                avail = mods.get('absorb_amount', 0)\n                use = min(avail, remaining)\n                remaining -= use\n                mods['absorb_amount'] = avail - use\n                # remove buff if its modifiers are depleted\n                if all((not isinstance(v, (int, float)) or v == 0)\n                       for v in mods.values()):\n                    try:\n                        self.active_buffs.remove(b)\n                    except ValueError:\n                        pass\n\n        # Any remaining damage applies to HP\n        damage_taken = max(0, remaining)\n        self.hp = max(0, self.hp - damage_taken)\n        return damage_taken\n\n    def heal(self, amount: int):\n        \"\"\"Heal character\"\"\"\n        self.hp = min(self.max_hp, self.hp + amount)\n\n    def gain_experience(self, exp: int):\n        \"\"\"Gain experience and level up if needed\"\"\"\n        self.experience += exp\n        while self.experience >= self.experience_to_next:\n            self.level_up()\n\n    def level_up(self):\n        \"\"\"Level up the character\"\"\"\n        self.level += 1\n        self.experience -= self.experience_to_next\n        self.experience_to_next = int(self.experience_to_next * 1.5)\n\n        # Apply stat increases from class data\n        if self.level_up_bonuses:\n            self.max_hp += self.level_up_bonuses.get(\"hp\", 0)\n            self.max_mp += self.level_up_bonuses.get(\"mp\", 0)\n            self.attack += self.level_up_bonuses.get(\"attack\", 0)\n            self.defense += self.level_up_bonuses.get(\"defense\", 0)\n            self.speed += self.level_up_bonuses.get(\"speed\", 0)\n            self.hp = self.max_hp\n            self.mp = self.max_mp\n\n        print(\n            f\"{Colors.GREEN}{Colors.BOLD}Level Up!{Colors.END} You are now level {self.level}!\"\n        )\n        # Update rank when leveling\n        self._update_rank()\n\n    def _update_rank(self):\n        \"\"\"Simple rank tiers based on level\"\"\"\n        if self.level >= 100:\n            self.rank = \"SSR tier adventurer\"\n        elif self.level >= 90:\n            self.rank = \"SR tier adventurer\"\n        elif self.level >= 80:\n            self.rank = \"SSS tier adventurer\"\n        elif self.level >= 70:\n            self.rank = \"SS tier adventurer\"\n        elif self.level >= 50:\n            self.rank = \"S tier adventurer\"\n        elif self.level >= 30:\n            self.rank = \"A tier adventurer\"\n        elif self.level >= 20:\n            self.rank = \"B tier adventurer\"\n        elif self.level >= 15:\n            self.rank = \"C tier adventurer\"\n        elif self.level >= 10:\n            self.rank = \"D tier adventurer\"\n        elif self.level >= 5:\n            self.rank = \"E tier adventurer\"\n        else:\n            self.rank = \"F tier adventurer\"\n\n    def get_time_period(self) -> str:\n        \"\"\"Get the current time period name based on the hour.\"\"\"\n        if not hasattr(self, 'times_data') or not self.times_data:\n            return \"unknown\"\n        for period, data in self.times_data.items():\n            if data['start_hour'] <= self.hour <= data['end_hour']:\n                return period\n        return \"unknown\"\n\n    def get_time_description(self, language_data: Dict) -> str:\n        \"\"\"Get the translated description of the current time.\"\"\"\n        period = self.get_time_period()\n        if period == \"unknown\":\n            return \"The passage of time is strange here...\"\n        \n        period_data = self.times_data.get(period, {})\n        desc_key = period_data.get(\"description\", \"\")\n        return language_data.get(desc_key, desc_key)\n\n    def get_weather_description(self, language_data: Dict) -> str:\n        \"\"\"Get the translated description of the current weather.\"\"\"\n        if not hasattr(self, 'current_weather') or not self.current_weather:\n            self.current_weather = \"sunny\"  # Default\n        \n        weather_info = self.weather_data.get(self.current_weather, {})\n        desc_key = weather_info.get(\"description\", \"\")\n        return language_data.get(desc_key, desc_key)\n\n    def advance_time(self, hours: int = 1):\n        \"\"\"Advance the game time by a number of hours.\"\"\"\n        self.hour += hours\n        while self.hour >= self.max_hours:\n            self.hour -= self.max_hours\n            self.day += 1\n            # Randomly change weather each day\n            if hasattr(self, 'weather_data') and self.weather_data:\n                self.current_weather = random.choice(list(self.weather_data.keys()))\n            print(f\"\\n{Colors.YELLOW}A new day begins! Day {self.day}{Colors.END}\")\n\n    def display_stats(self):\n        \"\"\"Display character statistics\"\"\"\n        print(\n            f\"\\n{Colors.CYAN}{Colors.BOLD}=== {self.name} - Level {self.level} {self.character_class} ({self.rank}) ==={Colors.END}\"\n        )\n        # HP and MP with visual bars\n        hp_bar = create_hp_mp_bar(self.hp,\n                                  self.max_hp,\n                                  width=20,\n                                  color=Colors.RED)\n        mp_bar = create_hp_mp_bar(self.mp,\n                                  self.max_mp,\n                                  width=20,\n                                  color=Colors.BLUE)\n        exp_bar = create_progress_bar(self.experience,\n                                      self.experience_to_next,\n                                      width=20,\n                                      color=Colors.MAGENTA)\n\n        print(f\"HP:  {hp_bar}\")\n        print(f\"MP:  {mp_bar}\")\n        print(f\"Exp: {exp_bar}\")\n\n        # Stats with visual indicators\n        print(f\"\\n{create_separator('-', 50)}\")\n        print(\n            f\"Attack:  {Colors.YELLOW}{Colors.BOLD}{self.attack}{Colors.END}\")\n        print(\n            f\"Defense: {Colors.YELLOW}{Colors.BOLD}{self.defense}{Colors.END}\")\n        print(f\"Speed:   {Colors.YELLOW}{Colors.BOLD}{self.speed}{Colors.END}\")\n        print(f\"Gold:    {Colors.GOLD}{Colors.BOLD}{self.gold}{Colors.END}\")\n\n        # Equipped items with better formatting\n        print(f\"\\n{create_separator('-', 50)}\")\n        print(f\"{Colors.CYAN}{Colors.BOLD}EQUIPPED ITEMS:{Colors.END}\")\n        for slot in ['weapon', 'armor', 'accessory']:\n            item_name = self.equipment.get(slot, 'None')\n            if item_name != 'None':\n                print(f\"  {slot.title():<10}: {item_name}\")\n            else:\n                print(\n                    f\"  {slot.title():<10}: {Colors.DARK_GRAY}None{Colors.END}\"\n                )\n\n        # Display companions if any\n        if self.companions:\n            print(f\"\\n{create_separator('-', 50)}\")\n            print(\n                f\"{Colors.CYAN}{Colors.BOLD}COMPANIONS ({len(self.companions)}/4):{Colors.END}\"\n            )\n            for i, companion in enumerate(self.companions, 1):\n                if isinstance(companion, dict):\n                    comp_name = companion.get('name')\n                    comp_level = companion.get('level', 1)\n                    print(\n                        f\"  {i}. {Colors.CYAN}{comp_name}{Colors.END} (Level {comp_level})\"\n                    )\n                else:\n                    print(f\"  {i}. {Colors.CYAN}{companion}{Colors.END}\")\n\n        # Active buffs\n        if self.active_buffs:\n            print(f\"\\n{create_separator('-', 50)}\")\n            print(f\"{Colors.CYAN}{Colors.BOLD}ACTIVE BUFFS:{Colors.END}\")\n            for b in self.active_buffs:\n                mods = ', '.join(f\"{k}:{v}\"\n                                 for k, v in b.get('modifiers', {}).items())\n                print(\n                    f\"  - {b.get('name')} ({b.get('duration')} turns): {mods}\")\n\n        print(f\"{create_separator('=', 50)}\")\n\n    def update_stats_from_equipment(\n            self,\n            items_data: Dict[str, Any],\n            companions_data: Optional[Dict[str, Any]] = None):\n        \"\"\"Recalculate stats from base stats plus any equipped item and companion bonuses.\"\"\"\n        # Start from base\n        self.max_hp = self.base_max_hp\n        self.max_mp = self.base_max_mp\n        self.attack = self.base_attack\n        self.defense = self.base_defense\n        self.speed = self.base_speed\n\n        # Apply bonuses from each equipped item\n        for slot in (\"weapon\", \"armor\", \"accessory\"):\n            item_name = self.equipment.get(slot)\n            if not item_name:\n                continue\n            item = items_data.get(item_name, {})\n            # Common bonus keys\n            if item.get(\"attack_bonus\"):\n                self.attack += item.get(\"attack_bonus\", 0)\n            if item.get(\"defense_bonus\"):\n                self.defense += item.get(\"defense_bonus\", 0)\n            if item.get(\"speed_bonus\"):\n                self.speed += item.get(\"speed_bonus\", 0)\n            if item.get(\"mp_bonus\"):\n                self.max_mp += item.get(\"mp_bonus\", 0)\n            if item.get(\"defense_penalty\"):\n                self.defense -= item.get(\"defense_penalty\", 0)\n            if item.get(\"speed_penalty\"):\n                self.speed -= item.get(\"speed_penalty\", 0)\n            if item.get(\"attack_penalty\"):\n                self.attack -= item.get(\"attack_penalty\", 0)\n            if item.get(\"hp_bonus\"):\n                self.max_hp += item.get(\"hp_bonus\", 0)\n\n        # Apply companion bonuses if companions_data is provided\n        if companions_data:\n            bonuses = self.calculate_companion_bonuses(companions_data)\n            self.attack += bonuses[\"attack\"]\n            self.defense += bonuses[\"defense\"]\n            self.speed += bonuses[\"speed\"]\n            self.max_hp += bonuses[\"max_hp\"]\n            self.max_mp += bonuses[\"max_mp\"]\n\n        # Clamp current HP/MP to new maxima\n        self.hp = min(self.hp, self.max_hp)\n        self.mp = min(self.mp, self.max_mp)\n\n    # --- Buff helpers ---\n    def get_total_buff_modifiers(self) -> Dict[str, int]:\n        \"\"\"Aggregate modifiers from active buffs\"\"\"\n        totals = {}\n        for b in self.active_buffs:\n            for k, v in b.get('modifiers', {}).items():\n                totals[k] = totals.get(k, 0) + v\n        return totals\n\n    def get_effective_attack(self) -> int:\n        mods = self.get_total_buff_modifiers()\n        return max(0, self.attack + mods.get('attack_bonus', 0))\n\n    def get_effective_defense(self) -> int:\n        mods = self.get_total_buff_modifiers()\n        return max(0, self.defense + mods.get('defense_bonus', 0))\n\n    def get_effective_speed(self) -> int:\n        mods = self.get_total_buff_modifiers()\n        return max(0, self.speed + mods.get('speed_bonus', 0))\n\n    def get_effective_max_hp(self) -> int:\n        mods = self.get_total_buff_modifiers()\n        return max(1, self.max_hp + mods.get('hp_bonus', 0))\n\n    def get_effective_max_mp(self) -> int:\n        mods = self.get_total_buff_modifiers()\n        return max(0, self.max_mp + mods.get('mp_bonus', 0))\n\n    def apply_buff(self, name: str, duration: int, modifiers: Dict[str, int]):\n        \"\"\"Add a temporary buff/debuff\"\"\"\n        self.active_buffs.append({\n            \"name\": name,\n            \"duration\": duration,\n            \"modifiers\": modifiers\n        })\n\n    def tick_buffs(self):\n        \"\"\"Reduce buff durations by 1 and expire any that reach 0.\"\"\"\n        changed = False\n\n        # First, apply per-turn modifiers (healing, mp regen, etc.)\n        for b in list(self.active_buffs):\n            mods = b.get('modifiers', {})\n            # MP per turn\n            if mods.get('mp_per_turn'):\n                try:\n                    self.mp = min(self.get_effective_max_mp(),\n                                  self.mp + int(mods.get('mp_per_turn', 0)))\n                except Exception:\n                    pass\n            # Heal per turn\n            if mods.get('heal_per_turn'):\n                try:\n                    self.heal(int(mods.get('heal_per_turn', 0)))\n                except Exception:\n                    pass\n\n        # Then reduce duration and remove expired buffs\n        for b in list(self.active_buffs):\n            b['duration'] -= 1\n            if b['duration'] <= 0:\n                try:\n                    self.active_buffs.remove(b)\n                except ValueError:\n                    pass\n                changed = True\n\n        return changed\n\n    def equip(self, item_name: str, items_data: Dict[str, Any]) -> bool:\n        \"\"\"Attempt to equip `item_name`. Returns True if equipped.\"\"\"\n        item = items_data.get(item_name)\n        if not item:\n            return False\n        item_type = item.get(\"type\")\n        if item_type not in (\"weapon\", \"armor\", \"accessory\", \"offhand\"):\n            return False\n\n        # Check requirements (simple level/class checks)\n        reqs = item.get(\"requirements\", {})\n        if reqs.get(\"level\") and self.level < reqs.get(\"level\", 0):\n            return False\n        if reqs.get(\"class\") and reqs.get(\"class\") != self.character_class:\n            return False\n\n        # Determine which slot to use\n        if item_type == \"accessory\":\n            # Find first available accessory slot\n            for i in range(1, 4):\n                slot = f\"accessory_{i}\"\n                if self.equipment[slot] is None:\n                    self.equipment[slot] = item_name\n                    self._update_equipment_slots()\n                    self.update_stats_from_equipment(items_data)\n                    return True\n            # If all slots full, ask which one to replace\n            print(\"All accessory slots are full. Replace one?\")\n            for i in range(1, 4):\n                slot = f\"accessory_{i}\"\n                equipped = self.equipment[slot]\n                print(f\"{i}. Slot {i}: {equipped}\")\n            choice = input(\n                \"Enter slot (1-3) or press Enter to cancel: \").strip()\n            if choice in ('1', '2', '3'):\n                slot = f\"accessory_{choice}\"\n                self.equipment[slot] = item_name\n                self._update_equipment_slots()\n                self.update_stats_from_equipment(items_data)\n                return True\n            return False\n        else:\n            # For weapon, armor, and offhand - single slot each\n            self.equipment[item_type] = item_name\n            self._update_equipment_slots()\n            self.update_stats_from_equipment(items_data)\n            return True\n\n    def unequip(self, slot: str, items_data: Dict[str, Any]) -> Optional[str]:\n        \"\"\"Unequip an item from `slot`. Returns the item name if removed.\"\"\"\n        valid_slots = (\"weapon\", \"armor\", \"offhand\", \"accessory_1\",\n                       \"accessory_2\", \"accessory_3\")\n        if slot not in valid_slots:\n            return None\n        prev = self.equipment.get(slot)\n        self.equipment[slot] = None\n        self._update_equipment_slots()\n        self.update_stats_from_equipment(items_data)\n        return prev\n\n    def calculate_companion_bonuses(\n            self, companions_data: Dict[str, Any]) -> Dict[str, int]:\n        \"\"\"Calculate stat bonuses from all active companions.\"\"\"\n        bonuses = {\n            \"attack\": 0,\n            \"defense\": 0,\n            \"speed\": 0,\n            \"max_hp\": 0,\n            \"max_mp\": 0,\n            \"healing\": 0,\n            \"spell_power\": 0\n        }\n\n        for companion in self.companions:\n            # Companion can be just name (old format) or dict with equipment\n            if isinstance(companion, str):\n                # Legacy format: just the name\n                comp_id = None\n                comp_name = companion\n            else:\n                # New format: dict with id, name, equipment, level\n                comp_id = companion.get('id')\n                comp_name = companion.get('name')\n\n            # Find companion data by name or id\n            comp_data = None\n            for cid, cdata in companions_data.items():\n                if cdata.get('name') == comp_name or cid == comp_id:\n                    comp_data = cdata\n                    break\n\n            if not comp_data:\n                continue\n\n            # Apply direct stat bonuses\n            bonuses[\"attack\"] += comp_data.get(\"attack_bonus\", 0)\n            bonuses[\"defense\"] += comp_data.get(\"defense_bonus\", 0)\n            bonuses[\"speed\"] += comp_data.get(\"speed_bonus\", 0)\n            bonuses[\"max_hp\"] += comp_data.get(\"hp_bonus\", 0)\n            bonuses[\"max_mp\"] += comp_data.get(\"mp_bonus\", 0)\n            bonuses[\"healing\"] += comp_data.get(\"healing_bonus\", 0)\n            bonuses[\"spell_power\"] += comp_data.get(\"spell_power_bonus\", 0)\n\n            # TODO: Apply equipment bonuses from companion's equipment dict\n            if isinstance(companion, dict) and \"equipment\" in companion:\n                # In future, equip items on companions and add their bonuses\n                pass\n\n        return bonuses\n\n    def apply_companion_bonuses(self, companions_data: Dict[str, Any]):\n        \"\"\"Apply companion bonuses to character stats after recalculating from equipment.\"\"\"\n        bonuses = self.calculate_companion_bonuses(companions_data)\n\n        self.attack += bonuses[\"attack\"]\n        self.defense += bonuses[\"defense\"]\n        self.speed += bonuses[\"speed\"]\n        self.max_hp += bonuses[\"max_hp\"]\n        self.max_mp += bonuses[\"max_mp\"]\n\n        # Cap current HP/MP to new max\n        self.hp = min(self.hp, self.max_hp)\n        self.mp = min(self.mp, self.max_mp)\n\n\nclass Enemy:\n    \"\"\"Enemy class\"\"\"\n\n    def __init__(self, enemy_data: Dict):\n        self.name = enemy_data[\"name\"]\n        self.max_hp = enemy_data[\"hp\"]\n        self.hp = enemy_data[\"hp\"]\n        self.attack = enemy_data[\"attack\"]\n        self.defense = enemy_data[\"defense\"]\n        self.speed = enemy_data[\"speed\"]\n        self.experience_reward = enemy_data[\"experience_reward\"]\n        self.gold_reward = enemy_data[\"gold_reward\"]\n        self.loot_table = enemy_data.get(\"loot_table\", [])\n\n    def is_alive(self) -> bool:\n        \"\"\"Check if enemy is alive\"\"\"\n        return self.hp > 0\n\n    def take_damage(self, damage: int) -> int:\n        \"\"\"Apply damage to enemy, return actual damage taken\"\"\"\n        actual_damage = max(1, damage - self.defense)\n        self.hp = max(0, self.hp - actual_damage)\n        return actual_damage\n\n\nclass Boss(Enemy):\n    \"\"\"Boss enemy class with phases and special abilities\"\"\"\n\n    def __init__(self,\n                 boss_data: Dict,\n                 dialogues_data: Optional[Dict[str, Any]] = None):\n        super().__init__(boss_data)\n        self.description = boss_data.get(\"description\", \"A powerful foe.\")\n        self.special_abilities = boss_data.get(\"special_abilities\", [])\n        self.phases = boss_data.get(\"phases\", [])\n        self.current_phase_index = -1\n        self.mp = 100\n        self.max_mp = 100\n        self.cooldowns = {}\n        self.dialogues_data = dialogues_data or {}\n        self.boss_dialogues = boss_data.get(\"dialogues\", {})\n\n    def get_dialogue(self, dialogue_key: str) -> Optional[str]:\n        \"\"\"Get a dialogue string by key, looking up the reference in dialogues_data\"\"\"\n        # Get the dialogue reference key from boss data\n        dialogue_ref = self.boss_dialogues.get(dialogue_key)\n        if not dialogue_ref:\n            return None\n\n        # Look up the actual dialogue text from dialogues_data\n        return self.dialogues_data.get(dialogue_ref)\n\n    def take_damage(self, damage: int) -> int:\n        actual_damage = super().take_damage(damage)\n        self.check_phase_transition()\n        return actual_damage\n\n    def check_phase_transition(self):\n        hp_percent = self.hp / self.max_hp if self.max_hp > 0 else 0\n        for i, phase in enumerate(self.phases):\n            if hp_percent <= phase.get(\"hp_threshold\",\n                                       0) and i > self.current_phase_index:\n                self.current_phase_index = i\n                print(\n                    f\"\\n{Colors.MAGENTA}{Colors.BOLD}PHASE TRANSITION: {phase.get('description')}{Colors.END}\"\n                )\n                self.attack = int(self.attack *\n                                  phase.get(\"attack_multiplier\", 1.0))\n                self.defense = int(self.defense *\n                                   phase.get(\"defense_multiplier\", 1.0))\n                break\n\n\nclass LanguageManager:\n    \"\"\"Manages language loading and translation\"\"\"\n\n    def __init__(self):\n        self.config: Dict[str, Any] = {}\n        self.translations: Dict[str, str] = {}\n        self.current_language = \"en\"\n        self.load_config()\n        self.load_translations()\n\n    def load_config(self):\n        \"\"\"Load language configuration\"\"\"\n        try:\n            with open('data/languages/config.json', 'r') as f:\n                self.config = json.load(f)\n                self.current_language = self.config.get(\n                    'default_language', 'en')\n        except (FileNotFoundError, json.JSONDecodeError):\n            # Fallback defaults\n            self.config = {\n                \"default_language\": \"en\",\n                \"available_languages\": {\n                    \"en\": \"English\"\n                },\n                \"fallback_language\": \"en\",\n                \"overwrite_save_files\": True\n            }\n\n    def load_translations(self):\n        \"\"\"Load translation strings for current language\"\"\"\n        try:\n            lang_file = f'data/languages/{self.current_language}.json'\n            with open(lang_file, 'r') as f:\n                self.translations = json.load(f)\n        except (FileNotFoundError, json.JSONDecodeError):\n            # Fallback to English if current language fails\n            if self.current_language != 'en':\n                try:\n                    with open('data/languages/en.json', 'r') as f:\n                        self.translations = json.load(f)\n                except (FileNotFoundError, json.JSONDecodeError):\n                    self.translations = {}\n\n    def get(self, key: str, **kwargs) -> str:\n        \"\"\"Get translated string, with optional formatting\"\"\"\n        text = self.translations.get(key, key)\n        if kwargs:\n            try:\n                text = text.format(**kwargs)\n            except (KeyError, ValueError):\n                pass  # Return text as-is if formatting fails\n        return text\n\n    def should_overwrite_saves(self) -> bool:\n        \"\"\"Check if save files should be overwritten\"\"\"\n        return self.config.get('overwrite_save_files', True)\n\n\nclass Game:\n    \"\"\"Main game class\"\"\"\n\n    def __init__(self):\n        self.player: Optional[Character] = None\n        self.current_area = \"starting_village\"\n        self.visited_areas: set = set()  # Track visited areas for cutscenes\n        self.enemies_data: Dict[str, Any] = {}\n        self.areas_data: Dict[str, Any] = {}\n        self.items_data: Dict[str, Any] = {}\n        self.missions_data: Dict[str, Any] = {}\n        self.bosses_data: Dict[str, Any] = {}\n        self.classes_data: Dict[str, Any] = {}\n        self.spells_data: Dict[str, Any] = {}\n        self.effects_data: Dict[str, Any] = {}\n        self.companions_data: Dict[str, Any] = {}\n        self.dialogues_data: Dict[str, Any] = {}\n        self.dungeons_data: Dict[str, Any] = {}\n        self.cutscenes_data: Dict[str, Any] = {}\n        self.mission_progress: Dict[str, Any] = {\n        }  # mission_id -> {current_count, target_count, completed, type}\n        self.completed_missions: List[str] = []\n        self.market_api: Optional[MarketAPI] = None\n        self.crafting_data: Dict[str, Any] = {}\n        self.weekly_challenges_data: Dict[str, Any] = {}\n        self.housing_data: Dict[str, Any] = {}  # Housing items data\n        self.shops_data: Dict[str, Any] = {}  # Shop data\n        self.farming_data: Dict[str, Any] = {}  # Farming crops and foods data\n\n        # Challenge tracking\n        self.challenge_progress: Dict[str, int] = {\n        }  # challenge_id -> progress count\n        self.completed_challenges: List[str] = []\n\n        # Dungeon state tracking\n        self.current_dungeon: Optional[Dict[str, Any]] = None\n        self.dungeon_progress: int = 0\n        self.dungeon_rooms: List[Dict[str, Any]] = []\n        self.dungeon_state: Dict[str, Any] = {}\n\n        # Initialize ModManager\n        self.mod_manager = ModManager()\n\n        # Initialize Language Manager\n        self.lang = LanguageManager()\n\n        # Load game data\n        self.load_game_data()\n        self.load_config()\n\n    def load_game_data(self):\n        \"\"\"Load all game data from JSON files and mods\"\"\"\n        try:\n            with open('data/enemies.json', 'r') as f:\n                self.enemies_data = json.load(f)\n            with open('data/areas.json', 'r') as f:\n                self.areas_data = json.load(f)\n            with open('data/items.json', 'r') as f:\n                self.items_data = json.load(f)\n            with open('data/missions.json', 'r') as f:\n                self.missions_data = json.load(f)\n            with open('data/bosses.json', 'r') as f:\n                self.bosses_data = json.load(f)\n            with open('data/classes.json', 'r') as f:\n                self.classes_data = json.load(f)\n            with open('data/spells.json', 'r') as f:\n                self.spells_data = json.load(f)\n            with open('data/effects.json', 'r') as f:\n                self.effects_data = json.load(f)\n            # Optional companions data\n            try:\n                with open('data/companions.json', 'r') as f:\n                    self.companions_data = json.load(f)\n            except FileNotFoundError:\n                self.companions_data = {}\n\n            # Optional crafting data\n            try:\n                with open('data/crafting.json', 'r') as f:\n                    self.crafting_data = json.load(f)\n            except FileNotFoundError:\n                self.crafting_data = {}\n\n            # Load dialogues data\n            try:\n                with open('data/dialogues.json', 'r') as f:\n                    self.dialogues_data = json.load(f)\n            except FileNotFoundError:\n                self.dialogues_data = {}\n\n            # Load cutscenes data\n            try:\n                with open('data/cutscenes.json', 'r') as f:\n                    self.cutscenes_data = json.load(f)\n            except FileNotFoundError:\n                self.cutscenes_data = {}\n\n            # Load dungeons data\n            try:\n                with open('data/dungeons.json', 'r') as f:\n                    self.dungeons_data = json.load(f)\n            except FileNotFoundError:\n                self.dungeons_data = {}\n\n            # Load weekly challenges data\n            try:\n                with open('data/weekly_challenges.json', 'r') as f:\n                    self.weekly_challenges_data = json.load(f)\n                # Initialize challenge progress\n                for challenge in self.weekly_challenges_data.get(\n                        'challenges', []):\n                    self.challenge_progress[challenge['id']] = 0\n            except FileNotFoundError:\n                self.weekly_challenges_data = {}\n\n            # Load housing data\n            try:\n                with open('data/housing.json', 'r') as f:\n                    self.housing_data = json.load(f)\n            except FileNotFoundError:\n                self.housing_data = {}\n\n            # Load shops data\n            try:\n                with open('data/shops.json', 'r') as f:\n                    self.shops_data = json.load(f)\n            except FileNotFoundError:\n                self.shops_data = {}\n\n            # Load farming data\n            try:\n                with open('data/farming.json', 'r') as f:\n                    self.farming_data = json.load(f)\n            except FileNotFoundError:\n                self.farming_data = {}\n\n            # Load mod data after base game data\n            self._load_mod_data()\n        except FileNotFoundError as e:\n            print(f\"Error loading game data: {e}\")\n            print(\"Please ensure all data files exist in the data/ directory.\")\n            sys.exit(1)\n\n    def _load_mod_data(self):\n        \"\"\"Load and merge mod data into base game data\"\"\"\n        # Discover available mods\n        self.mod_manager.discover_mods()\n\n        # Get enabled mods\n        enabled_mods = self.mod_manager.get_enabled_mods()\n\n        if not enabled_mods:\n            return\n\n        print(f\"\\n{Colors.CYAN}Loading mods...{Colors.END}\")\n\n        # Load mod data for each data type\n        mod_data_types = [('areas.json', 'areas_data'),\n                          ('enemies.json', 'enemies_data'),\n                          ('items.json', 'items_data'),\n                          ('missions.json', 'missions_data'),\n                          ('bosses.json', 'bosses_data'),\n                          ('companions.json', 'companions_data'),\n                          ('classes.json', 'classes_data'),\n                          ('spells.json', 'spells_data'),\n                          ('effects.json', 'effects_data'),\n                          ('crafting.json', 'crafting_data'),\n                          ('dungeons.json', 'dungeons_data'),\n                          ('dialogues.json', 'dialogues_data'),\n                          ('cutscenes.json', 'cutscenes_data'),\n                          ('weekly_challenges.json', 'weekly_challenges_data'),\n                          ('housing.json', 'housing_data'),\n                          ('shops.json', 'shops_data')]\n\n        for file_name, attr_name in mod_data_types:\n            mod_data = self.mod_manager.load_mod_data(file_name)\n            if mod_data:\n                # Merge mod data into base data\n                base_data = getattr(self, attr_name)\n\n                # Special handling for dungeons: merge nested structures\n                if file_name == 'dungeons.json':\n                    if 'dungeons' in mod_data:\n                        if 'dungeons' not in base_data:\n                            base_data['dungeons'] = []\n                        base_data['dungeons'].extend(mod_data['dungeons'])\n                    if 'challenge_templates' in mod_data:\n                        if 'challenge_templates' not in base_data:\n                            base_data['challenge_templates'] = {}\n                        base_data['challenge_templates'].update(\n                            mod_data['challenge_templates'])\n                    if 'chest_templates' in mod_data:\n                        if 'chest_templates' not in base_data:\n                            base_data['chest_templates'] = {}\n                        base_data['chest_templates'].update(\n                            mod_data['chest_templates'])\n                # Special handling for weekly_challenges: merge nested challenge arrays\n                elif file_name == 'weekly_challenges.json':\n                    if 'challenges' in mod_data:\n                        if 'challenges' not in base_data:\n                            base_data['challenges'] = []\n                        base_data['challenges'].extend(mod_data['challenges'])\n                        # Initialize progress tracking for new challenges\n                        for challenge in mod_data['challenges']:\n                            self.challenge_progress[challenge['id']] = 0\n                else:\n                    # Standard merge for other data types\n                    base_data.update(mod_data)\n\n                print(\n                    f\"  Loaded {len(mod_data)} entries from mods for {file_name}\"\n                )\n\n        print(f\"{Colors.GREEN}Mod loading complete!{Colors.END}\")\n\n    def load_config(self):\n        \"\"\"Load configuration - uses hardcoded defaults since config file is removed\"\"\"\n        # Set global color toggle to True by default\n        global COLORS_ENABLED\n        COLORS_ENABLED = True\n\n        # Initialize Market API\n        self.market_api = MarketAPI()\n\n    def play_cutscene(self, cutscene_id: str):\n        \"\"\"Play a cutscene by ID\"\"\"\n        if cutscene_id not in self.cutscenes_data:\n            print(f\"Cutscene {cutscene_id} not found.\")\n            return\n\n        cutscene = self.cutscenes_data[cutscene_id]\n        self._play_cutscene_content(cutscene['content'])\n\n    def _play_cutscene_content(self, content: Dict[str, Any]):\n        \"\"\"Recursively play cutscene content\"\"\"\n        # Display text\n        if 'text' in content:\n            print(f\"\\n{Colors.CYAN}{content['text']}{Colors.END}\")\n\n        # Wait\n        if 'wait' in content:\n            wait_time = content['wait']\n            for i in range(wait_time):\n                print(\".\", end=\"\", flush=True)\n                time.sleep(1)\n            print()\n\n        # Handle choices\n        if 'choice' in content:\n            choices = content['choice']\n            if choices:\n                print(f\"\\n{Colors.YELLOW}Choose your response:{Colors.END}\")\n                choice_keys = list(choices.keys())\n                for i, choice_key in enumerate(choice_keys, 1):\n                    print(f\"{i}. {choice_key}\")\n\n                # Allow skipping with Enter\n                choice = ask(\"Your choice (or press Enter to skip): \").strip()\n                if choice and choice.isdigit():\n                    idx = int(choice) - 1\n                    if 0 <= idx < len(choice_keys):\n                        selected_choice = choice_keys[idx]\n                        next_content = choices[selected_choice]\n                        if isinstance(next_content, dict):\n                            self._play_cutscene_content(next_content)\n                # If no choice or invalid, continue without recursion\n\n    def display_welcome(self) -> str:\n        \"\"\"Display welcome screen\"\"\"\n        while True:\n            clear_screen()\n            print(f\"{Colors.CYAN}{Colors.BOLD}\")\n            print(\"=\" * 60)\n            print(\"             OUR LEGACY\")\n            print(\"       Text-Based CLI Fantasy RPG\")\n            print(\"=\" * 60)\n            print(f\"{Colors.END}\")\n            print(self.lang.get(\"welcome_message\"))\n            print(\n                \"Choose your path wisely, for every decision shapes your destiny.\"\n            )\n            print()\n\n            print(\n                f\"{Colors.BOLD}{Colors.CYAN}=== {self.lang.get('main_menu')} ==={Colors.END}\"\n            )\n            print(f\"{Colors.CYAN}1.{Colors.END} {self.lang.get('new_game')}\")\n            print(f\"{Colors.CYAN}2.{Colors.END} {self.lang.get('load_game')}\")\n            print(f\"{Colors.CYAN}3.{Colors.END} {self.lang.get('settings')}\")\n            print(f\"{Colors.CYAN}4.{Colors.END} {self.lang.get('mods')}\")\n            print(f\"{Colors.CYAN}5.{Colors.END} {self.lang.get('quit')}\")\n            print()\n\n            choice = ask(f\"{Colors.CYAN}Choose an option (1-5): {Colors.END}\")\n            if choice == \"1\":\n                return \"new_game\"\n            elif choice == \"2\":\n                return \"load_game\"\n            elif choice == \"3\":\n                self.settings_welcome()\n            elif choice == \"4\":\n                self.mods_welcome()\n            elif choice == \"5\":\n                print(\"Thank you for playing Our Legacy!\")\n                clear_screen()\n                sys.exit(0)\n            else:\n                print(self.lang.get(\"invalid_choice\"))\n\n    def settings_welcome(self):\n        \"\"\"Settings menu available from welcome screen\"\"\"\n        while True:\n            clear_screen()\n            print(f\"\\n{Colors.BOLD}=== SETTINGS ==={Colors.END}\")\n\n            # Get current settings\n            mods_enabled = self.mod_manager.settings.get(\"mods_enabled\", True)\n\n            print(\n                f\"\\n1. Mod System: {'{Colors.GREEN}Enabled{Colors.END}' if mods_enabled else '{Colors.RED}Disabled{Colors.END}'}\"\n            )\n            print(\"2. Back to Main Menu\")\n\n            choice = ask(\"\\nChoose an option: \").strip()\n\n            if choice == \"1\":\n                # Toggle mods system\n                self.mod_manager.toggle_mods_system()\n                if self.mod_manager.settings.get(\"mods_enabled\", True):\n                    print(f\"{Colors.GREEN}Mod system enabled!{Colors.END}\")\n                else:\n                    print(f\"{Colors.RED}Mod system disabled!{Colors.END}\")\n                print(\n                    f\"{Colors.YELLOW}Note: Changes take effect on game restart.{Colors.END}\"\n                )\n                ask(\"\\nPress Enter to continue...\")\n            elif choice == \"2\" or not choice:\n                break\n            else:\n                print(\"Invalid choice.\")\n\n    def mods_welcome(self):\n        \"\"\"Mods menu available from welcome screen\"\"\"\n        while True:\n            clear_screen()\n            print(f\"\\n{Colors.BOLD}=== MODS ==={Colors.END}\")\n\n            # Refresh mod list\n            self.mod_manager.discover_mods()\n            mods_list = self.mod_manager.get_mod_list()\n\n            if not mods_list:\n                print(\"\\n{Colors.YELLOW}No mods found.{Colors.END}\")\n                print(\"Place mods in the 'mods/' directory to use them.\")\n                ask(\"\\nPress Enter to go back...\")\n                break\n\n            # Mod system status\n            mods_system_enabled = self.mod_manager.settings.get(\n                \"mods_enabled\", True)\n            status_color = Colors.GREEN if mods_system_enabled else Colors.RED\n            status_text = \"Enabled\" if mods_system_enabled else \"Disabled\"\n            print(\n                f\"\\nMod System Status: {status_color}{status_text}{Colors.END}\"\n            )\n\n            print(\n                f\"\\n{Colors.CYAN}Installed Mods ({len(mods_list)}):{Colors.END}\"\n            )\n\n            for i, mod in enumerate(mods_list, 1):\n                name = mod.get('name', mod.get('folder_name', 'Unknown'))\n                description = mod.get('description', '')\n                author = mod.get('author', 'Unknown')\n                version = mod.get('version', '1.0')\n                enabled = mod.get('enabled', False)\n\n                status = f\"{Colors.GREEN}[ENABLED]{Colors.END}\" if enabled else f\"{Colors.RED}[DISABLED]{Colors.END}\"\n                print(f\"\\n{i}. {Colors.BOLD}{name}{Colors.END} {status}\")\n                print(f\"   Version: {version}\")\n                print(f\"   Author: {author}\")\n                if description:\n                    # Truncate long descriptions\n                    desc = description[:100] + \"...\" if len(\n                        description) > 100 else description\n                    print(f\"   {desc}\")\n\n            print(f\"\\n{Colors.YELLOW}Options:{Colors.END}\")\n            print(f\"1-{len(mods_list)}. Toggle Mod\")\n            print(\"R. Refresh Mod List\")\n            print(\"B. Back to Main Menu\")\n\n            choice = ask(\"\\nChoose an option: \").strip().upper()\n\n            if choice == 'B' or not choice:\n                break\n            elif choice == 'R':\n                # Refresh mods\n                self.mod_manager.discover_mods()\n                print(\"Mod list refreshed!\")\n                time.sleep(0.5)\n            elif choice.isdigit():\n                idx = int(choice) - 1\n                if 0 <= idx < len(mods_list):\n                    mod = mods_list[idx]\n                    folder_name = mod.get('folder_name')\n                    if isinstance(folder_name, str):\n                        self.mod_manager.toggle_mod(folder_name)\n                        print(\n                            f\"{Colors.YELLOW}Note: Changes take effect on game restart.{Colors.END}\"\n                        )\n                        ask(\"\\nPress Enter to continue...\")\n                else:\n                    print(\"Invalid mod number.\")\n                    time.sleep(1)\n            else:\n                print(\"Invalid choice.\")\n                time.sleep(1)\n\n    def display_available_classes(self):\n        \"\"\"Display all available character classes from classes.json\"\"\"\n        print(\"\\nChoose your class:\")\n\n        color_map = [\n            Colors.RED, Colors.BLUE, Colors.GREEN, Colors.YELLOW,\n            Colors.MAGENTA, Colors.CYAN, Colors.WHITE, Colors.GOLD\n        ]\n\n        for i, (class_name, class_data) in enumerate(self.classes_data.items(),\n                                                     1):\n            color = color_map[(i - 1) % len(color_map)]\n            description = class_data.get(\"description\",\n                                         \"No description available\")\n            print(f\"{color}{i}. {class_name}{Colors.END} - {description}\")\n\n    def select_class(self) -> str:\n        \"\"\"Allow user to select a class from available options\"\"\"\n        class_names = list(self.classes_data.keys())\n        # Try to enable tab-completion for class names (best-effort)\n        try:\n            enable_tab_completion(class_names)\n        except Exception:\n            pass\n\n        try:\n            while True:\n                prompt = f\"Enter class choice (1-{len(class_names)}) or name: \"\n                choice = ask(prompt, allow_empty=False)\n                if choice.isdigit():\n                    choice_idx = int(choice) - 1\n                    if 0 <= choice_idx < len(class_names):\n                        return class_names[choice_idx]\n                    else:\n                        print(\n                            f\"Invalid choice. Please enter a number between 1 and {len(class_names)}.\"\n                        )\n                        continue\n\n                # Try to match by name (case-insensitive)\n                matches = [\n                    cn for cn in class_names if cn.lower() == choice.lower()\n                ]\n                if matches:\n                    return matches[0]\n\n                # Try close matches\n                close = difflib.get_close_matches(\n                    choice.lower(), [cn.lower() for cn in class_names], n=1)\n                if close:\n                    # return the real-cased version\n                    for cn in class_names:\n                        if cn.lower() == close[0]:\n                            return cn\n                print(\n                    \"Invalid class name. Try again or use the numeric choice.\")\n        finally:\n            # restore completer\n            try:\n                disable_tab_completion(None)\n            except Exception:\n                pass\n\n    def create_character(self):\n        \"\"\"Create a new character\"\"\"\n        print(\n            f\"{Colors.BOLD}{self.lang.get('character_creation')}{Colors.END}\")\n        print(\"-\" * 30)\n\n        name = ask(self.lang.get(\"enter_name\"))\n        if not name:\n            name = \"Hero\"\n\n        # Use dynamic class selection instead of hardcoded options\n        self.display_available_classes()\n\n        character_class = self.select_class()\n\n        self.player = Character(name, character_class, self.classes_data)\n        print(\n            self.lang.get(\"welcome_adventurer\",\n                          name=name,\n                          char_class=character_class))\n\n        # Give starting items based on class data\n        self.give_starting_items(character_class)\n\n        if self.player:\n            self.player.display_stats()\n\n    def give_starting_items(self, character_class: str):\n        \"\"\"Grant starting items based on character class from classes.json\"\"\"\n        if not self.player or character_class not in self.classes_data:\n            return\n\n        class_info = self.classes_data[character_class]\n        items = class_info.get(\"starting_items\", [])\n        starting_gold = class_info.get(\"starting_gold\", 100)\n\n        for item in items:\n            self.player.inventory.append(item)\n\n        self.player.gold = starting_gold\n\n        if items:\n            print(\n                f\"{Colors.YELLOW}You received starting equipment:{Colors.END}\")\n            for item in items:\n                print(f\"  - {item}\")\n\n        # Auto-equip first weapon and armor if available\n        for slot in (\"weapon\", \"armor\"):\n            for item in items:\n                item_type = self.items_data.get(item, {}).get(\"type\")\n                if item_type == slot:\n                    self.player.equip(item, self.items_data)\n                    print(f\"{Colors.GREEN}Equipped: {item}{Colors.END}\")\n                    break\n\n    def main_menu(self):\n        \"\"\"Display main menu\"\"\"\n        # Continuous mission check on every main menu return\n        self.update_mission_progress('check', '')\n\n        # Check level-based challenges\n        if self.player:\n            self.update_challenge_progress('level_reach', self.player.level)\n\n        print(\n            f\"\\n{Colors.BOLD}=== {self.lang.get('main_menu')} ==={Colors.END}\")\n\n        # Show current location\n        area_data = self.areas_data.get(self.current_area, {})\n        print(\n            self.lang.get(\"current_location\",\n                          area=area_data.get('name', self.current_area)))\n\n        # Display time and weather\n        if hasattr(self, 'player') and self.player:\n            time_desc = self.player.get_time_description(self.lang)\n            weather_desc = self.player.get_weather_description(self.lang)\n            print(f\"{Colors.YELLOW}{time_desc}{Colors.END}\")\n            print(f\"{Colors.CYAN}{weather_desc}{Colors.END}\")\n\n        print(f\"{Colors.CYAN}1.{Colors.END} {self.lang.get('explore')}\")\n        print(f\"{Colors.CYAN}2.{Colors.END} {self.lang.get('view_character')}\")\n        print(f\"{Colors.CYAN}3.{Colors.END} {self.lang.get('travel')}\")\n        print(f\"{Colors.CYAN}4.{Colors.END} {self.lang.get('inventory')}\")\n        print(f\"{Colors.CYAN}5.{Colors.END} {self.lang.get('missions')}\")\n        print(f\"{Colors.CYAN}6.{Colors.END} {self.lang.get('fight_boss')}\")\n        print(f\"{Colors.CYAN}7.{Colors.END} {self.lang.get('tavern')}\")\n        print(f\"{Colors.CYAN}8.{Colors.END} {self.lang.get('shop')}\")\n        print(f\"{Colors.CYAN}9.{Colors.END} {self.lang.get('alchemy')}\")\n        print(f\"{Colors.CYAN}10.{Colors.END} {self.lang.get('elite_market')}\")\n        print(f\"{Colors.CYAN}11.{Colors.END} {self.lang.get('rest')}\")\n        print(f\"{Colors.CYAN}12.{Colors.END} {self.lang.get('companions')}\")\n        print(f\"{Colors.CYAN}13.{Colors.END} {self.lang.get('dungeons')}\")\n        print(f\"{Colors.CYAN}14.{Colors.END} {self.lang.get('challenges')}\")\n\n        # Show Build options only in your_land\n        menu_max = \"18\"\n        if self.current_area == \"your_land\":\n            print(f\"{Colors.GOLD}15.{Colors.END} Furnish Home\")\n            print(f\"{Colors.GOLD}16.{Colors.END} Build Structures\")\n            print(f\"{Colors.GOLD}17.{Colors.END} Farm\")\n            print(f\"{Colors.GOLD}18.{Colors.END} Training\")\n            print(f\"{Colors.CYAN}19.{Colors.END} {self.lang.get('save_game')}\")\n            print(f\"{Colors.CYAN}20.{Colors.END} {self.lang.get('load_game')}\")\n            print(\n                f\"{Colors.CYAN}21.{Colors.END} {self.lang.get('claim_rewards')}\"\n            )\n            print(f\"{Colors.CYAN}22.{Colors.END} {self.lang.get('quit')}\")\n            menu_max = \"22\"\n            choice = ask(\n                f\"{Colors.CYAN}Choose an option (1-{menu_max}): {Colors.END}\",\n                allow_empty=False)\n        else:\n            print(f\"{Colors.CYAN}15.{Colors.END} {self.lang.get('save_game')}\")\n            print(f\"{Colors.CYAN}16.{Colors.END} {self.lang.get('load_game')}\")\n            print(\n                f\"{Colors.CYAN}17.{Colors.END} {self.lang.get('claim_rewards')}\"\n            )\n            print(f\"{Colors.CYAN}18.{Colors.END} {self.lang.get('quit')}\")\n            menu_max = \"18\"\n            choice = ask(\n                f\"{Colors.CYAN}Choose an option (1-{menu_max}): {Colors.END}\",\n                allow_empty=False)\n\n        # Normalize textual shortcuts to numbers for backward compatibility\n        shortcut_map = {\n            'explore': '1',\n            'e': '1',\n            'view': '2',\n            'v': '2',\n            'travel': '3',\n            't': '3',\n            'inventory': '4',\n            'i': '4',\n            'missions': '5',\n            'm': '5',\n            'boss': '6',\n            'tavern': '7',\n            'shop': '8',\n            's': '8',\n            'alchemy': '9',\n            'alc': '9',\n            'craft': '9',\n            'crafting': '9',\n            'market': '10',\n            'mkt': '10',\n            'elite': '10',\n            'rest': '11',\n            'r': '11',\n            'companions': '12',\n            'comp': '12',\n            'build_home': '15' if self.current_area == \"your_land\" else None,\n            'furnish_home': '15' if self.current_area == \"your_land\" else None,\n            'build_land': '16' if self.current_area == \"your_land\" else None,\n            'build_structures':\n            '16' if self.current_area == \"your_land\" else None,\n            'land': '16' if self.current_area == \"your_land\" else None,\n            'farm': '17' if self.current_area == \"your_land\" else None,\n            'training': '18' if self.current_area == \"your_land\" else None,\n            'train': '18' if self.current_area == \"your_land\" else None,\n            'save': '19' if self.current_area == \"your_land\" else '15',\n            'load': '20' if self.current_area == \"your_land\" else '16',\n            'l': '20' if self.current_area == \"your_land\" else '16',\n            'claim': '21' if self.current_area == \"your_land\" else '17',\n            'c': '21' if self.current_area == \"your_land\" else '17',\n            'quit': '22' if self.current_area == \"your_land\" else '18',\n            'q': '22' if self.current_area == \"your_land\" else '18'\n        }\n\n        # Remove None values from shortcut map\n        shortcut_map = {k: v for k, v in shortcut_map.items() if v is not None}\n\n        normalized = choice.strip().lower()\n        if normalized in shortcut_map:\n            choice = shortcut_map[normalized]\n\n        if choice == \"1\":\n            self.explore()\n\n        elif choice == \"2\":\n            if self.player:\n                self.player.display_stats()\n            else:\n                print(\"No character created yet.\")\n        elif choice == \"3\":\n            self.travel()\n\n        elif choice == \"4\":\n            self.view_inventory()\n\n        elif choice == \"5\":\n            self.view_missions()\n\n        elif choice == \"6\":\n            self.fight_boss_menu()\n\n        elif choice == \"7\":\n            self.visit_tavern()\n\n        elif choice == \"8\":\n            self.visit_shop()\n\n        elif choice == \"9\":\n            self.visit_alchemy()\n\n        elif choice == \"10\":\n            self.visit_market()\n\n        elif choice == \"11\":\n            self.rest()\n\n        elif choice == \"12\":\n            self.manage_companions()\n\n        elif choice == \"13\":\n            self.visit_dungeons()\n\n        elif choice == \"14\":\n            self.view_challenges()\n\n        elif choice == \"15\" and self.current_area == \"your_land\":\n            # Furnish Home option only in your_land\n            self.build_home()\n\n        elif choice == \"16\" and self.current_area == \"your_land\":\n            # Build Structures option only in your_land\n            self.build_structures()\n\n        elif choice == \"17\" and self.current_area == \"your_land\":\n            # Farm option only in your_land\n            self.farm()\n\n        elif choice == \"18\" and self.current_area == \"your_land\":\n            # Training option only in your_land\n            self.training()\n\n        elif choice == \"15\":\n            # Save Game (when not in your_land)\n            self.save_game()\n\n        elif choice == \"19\" and self.current_area == \"your_land\":\n            # Save Game (when in your_land)\n            self.save_game()\n\n        elif choice == \"16\":\n            # Load Game (when not in your_land)\n            self.load_game()\n\n        elif choice == \"20\" and self.current_area == \"your_land\":\n            # Load Game (when in your_land)\n            self.load_game()\n\n        elif choice == \"17\":\n            # Claim Rewards (when not in your_land)\n            self.claim_rewards()\n\n        elif choice == \"21\" and self.current_area == \"your_land\":\n            # Claim Rewards (when in your_land)\n            self.claim_rewards()\n\n        elif choice == \"18\":\n            # Quit (when not in your_land)\n            self.quit_game()\n\n        elif choice == \"22\" and self.current_area == \"your_land\":\n            # Quit (when in your_land)\n            self.quit_game()\n\n        elif choice == \"21\" and self.current_area == \"your_land\":\n            # Quit (when in your_land)\n            self.quit_game()\n\n        else:\n            print(\"Invalid choice. Please try again.\")\n\n    def fight_boss_menu(self):\n        \"\"\"Menu to select and fight a boss in the current area\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        area_data = self.areas_data.get(self.current_area, {})\n        possible_bosses = area_data.get(\"possible_bosses\", [])\n\n        if not possible_bosses:\n            print(\n                f\"There are no bosses in {area_data.get('name', self.current_area)}.\"\n            )\n            return\n\n        print(\n            f\"\\n{Colors.RED}{Colors.BOLD}=== BOSSES IN {area_data.get('name', self.current_area).upper()} ==={Colors.END}\"\n        )\n        for i, boss_name in enumerate(possible_bosses, 1):\n            boss_data = self.bosses_data.get(boss_name, {})\n            status = \"\"\n            if boss_name in self.player.bosses_killed:\n                last_killed_str = self.player.bosses_killed[boss_name]\n                try:\n                    last_killed_dt = datetime.fromisoformat(last_killed_str)\n                    diff = datetime.now() - last_killed_dt\n                    if diff.total_seconds() < 28800:\n                        status = f\" {Colors.YELLOW}(Cooldown: {int((28800 - diff.total_seconds()) // 60)}m left){Colors.END}\"\n                except Exception:\n                    pass\n            print(f\"{i}. {boss_data.get('name', boss_name)}{status}\")\n\n        choice = ask(\n            f\"Choose a boss (1-{len(possible_bosses)}) or Enter to cancel: \")\n        if choice and choice.isdigit():\n            idx = int(choice) - 1\n            if 0 <= idx < len(possible_bosses):\n                boss_name = possible_bosses[idx]\n\n                # Cooldown check\n                if boss_name in self.player.bosses_killed:\n                    last_killed_str = self.player.bosses_killed[boss_name]\n                    try:\n                        last_killed_dt = datetime.fromisoformat(\n                            last_killed_str)\n                        if (datetime.now() -\n                                last_killed_dt).total_seconds() < 28800:\n                            print(\n                                f\"{boss_name} is still recovering. Try again later.\"\n                            )\n                            return\n                    except Exception:\n                        pass\n\n                boss_data = self.bosses_data.get(boss_name)\n                if boss_data:\n                    boss = Boss(boss_data, self.dialogues_data)\n                    print(\n                        f\"\\n{Colors.RED}{Colors.BOLD}Challenge accepted!{Colors.END}\"\n                    )\n                    # Print start dialogue if available\n                    start_dialogue = boss.get_dialogue(\"on_start_battle\")\n                    if start_dialogue:\n                        print(\n                            f\"\\n{Colors.CYAN}{boss.name}:{Colors.END} {start_dialogue}\"\n                        )\n                    self.battle(boss)\n            else:\n                print(\"Invalid choice.\")\n\n    def explore(self):\n        \"\"\"Explore the current area\"\"\"\n        if not self.player:\n            print(\"No character created yet. Please create a character first.\")\n            return\n\n        # Continuous mission check on every action\n        self.update_mission_progress('check', '')\n\n        area_data = self.areas_data.get(self.current_area, {})\n        area_name = area_data.get(\"name\", \"Unknown Area\")\n\n        print(f\"\\n{Colors.CYAN}Exploring {area_name}...{Colors.END}\")\n\n        # Random encounter chance\n        if random.random() < 0.7:  # 70% chance of encounter\n            self.random_encounter()\n        else:\n            print(\"You explore the area but find nothing of interest.\")\n\n            # Small chance to find materials\n            if random.random() < 0.4:  # 40% chance to find materials\n                self._gather_materials()\n\n            # Small chance to find gold\n            if random.random() < 0.3:  # 30% chance to find gold\n                found_gold = random.randint(5, 20)\n                self.player.gold += found_gold\n                print(f\"{Colors.GOLD}You found {found_gold} gold!{Colors.END}\")\n\n    def random_encounter(self):\n        \"\"\"Handle random encounter with regular enemies\"\"\"\n        if not self.player:\n            return\n\n        area_data = self.areas_data.get(self.current_area, {})\n        possible_enemies = area_data.get(\"possible_enemies\", [])\n\n        if not possible_enemies:\n            print(\"No enemies found in this area.\")\n            return\n\n        # Regular enemy encounter\n        enemy_name = random.choice(possible_enemies)\n        enemy_data = self.enemies_data.get(enemy_name)\n\n        if enemy_data:\n            enemy = Enemy(enemy_data)\n            print(f\"\\n{Colors.RED}A wild {enemy.name} appears!{Colors.END}\")\n            self.battle(enemy)\n        else:\n            print(\"You explore the area but find no enemies.\")\n\n    def update_challenge_progress(self, challenge_type: str, value: int = 1):\n        \"\"\"Update challenge progress and check for completions\"\"\"\n        if not self.player:\n            return\n\n        for challenge in self.weekly_challenges_data.get('challenges', []):\n            if challenge['id'] in self.completed_challenges:\n                continue\n\n            if challenge['type'] == challenge_type:\n                self.challenge_progress[challenge['id']] += value\n\n                # Check if challenge is completed\n                if self.challenge_progress[\n                        challenge['id']] >= challenge['target']:\n                    self.complete_challenge(challenge)\n\n    def complete_challenge(self, challenge: Dict[str, Any]):\n        \"\"\"Complete a challenge and award rewards\"\"\"\n        if not self.player:\n            return\n\n        challenge_id = challenge['id']\n        self.completed_challenges.append(challenge_id)\n\n        reward_exp = challenge.get('reward_exp', 0)\n        reward_gold = challenge.get('reward_gold', 0)\n\n        self.player.gain_experience(reward_exp)\n        self.player.gold += reward_gold\n\n        print(\n            f\"\\n{Colors.CYAN}{Colors.BOLD}âœ“ Challenge Completed: {challenge['name']}!{Colors.END}\"\n        )\n        print(f\"  Reward: {reward_exp} EXP + {reward_gold} Gold\")\n\n    def view_challenges(self):\n        \"\"\"Display challenge status to player\"\"\"\n        if not self.player:\n            return\n\n        print(\n            f\"\\n{Colors.CYAN}{Colors.BOLD}=== WEEKLY CHALLENGES ==={Colors.END}\"\n        )\n\n        for challenge in self.weekly_challenges_data.get('challenges', []):\n            challenge_id = challenge['id']\n            is_completed = challenge_id in self.completed_challenges\n            progress = self.challenge_progress.get(challenge_id, 0)\n            target = challenge['target']\n\n            status = \"âœ“\" if is_completed else f\"{progress}/{target}\"\n            completed_text = f\"{Colors.GREEN}COMPLETED{Colors.END}\" if is_completed else status\n\n            print(f\"\\n{Colors.BOLD}{challenge['name']}{Colors.END}\")\n            print(f\"  {challenge['description']}\")\n            print(f\"  Status: {completed_text}\")\n            print(\n                f\"  Reward: {challenge['reward_exp']} EXP + {challenge['reward_gold']} Gold\"\n            )\n\n    def battle(self, enemy: Enemy):\n        \"\"\"Handle turn-based battle\"\"\"\n        if not self.player:\n            return\n\n        print(f\"\\n{Colors.BOLD}=== BATTLE ==={Colors.END}\")\n        print(f\"VS {enemy.name}\")\n\n        # Track if player fled\n        player_fled = False\n\n        # Determine who goes first using effective speed (buffs apply)\n        player_first = self.player.get_effective_speed() >= enemy.speed\n\n        while self.player.is_alive() and enemy.is_alive():\n            if player_first:\n                if not self.player_turn(enemy):\n                    player_fled = True\n                    break\n                # Companions may act after the player turn (each companion has a chance)\n                if enemy.is_alive() and self.player.companions:\n                    self.companions_act(enemy)\n                if enemy.is_alive():\n                    self.enemy_turn(enemy)\n            else:\n                self.enemy_turn(enemy)\n                if self.player.is_alive():\n                    if not self.player_turn(enemy):\n                        player_fled = True\n                        break\n                    # Companions may act after the player turn (each companion has a chance)\n                    if enemy.is_alive() and self.player.companions:\n                        self.companions_act(enemy)\n\n            # Display current HP/MP\n            player_hp_bar = create_hp_mp_bar(self.player.hp,\n                                             self.player.max_hp, 20,\n                                             Colors.RED)\n            player_mp_bar = create_hp_mp_bar(self.player.mp,\n                                             self.player.max_mp, 20,\n                                             Colors.BLUE)\n\n            # Check for boss for special health bar\n            if isinstance(enemy, Boss):\n                enemy_hp_bar = create_boss_hp_bar(enemy.hp, enemy.max_hp)\n            else:\n                enemy_hp_bar = create_hp_mp_bar(enemy.hp, enemy.max_hp, 20,\n                                                Colors.RED)\n\n            print(f\"\\n{Colors.BOLD}{self.player.name}{Colors.END}\")\n            print(f\"HP: {player_hp_bar} {self.player.hp}/{self.player.max_hp}\")\n            print(f\"MP: {player_mp_bar} {self.player.mp}/{self.player.max_mp}\")\n\n            print(f\"\\n{Colors.BOLD}{enemy.name}{Colors.END}\")\n            if isinstance(enemy, Boss):\n                print(enemy_hp_bar)\n            else:\n                print(f\"HP: {enemy_hp_bar} {enemy.hp}/{enemy.max_hp}\")\n\n            # Tick buffs (reduce durations each round)\n            if self.player.tick_buffs():\n                # Recalculate stats if buffs expired\n                self.player.update_stats_from_equipment(\n                    self.items_data, self.companions_data)\n\n        # Battle outcome\n        if player_fled:\n            print(f\"\\n{Colors.YELLOW}You fled from the battle!{Colors.END}\")\n            # Optional: Add penalty for fleeing?\n            return\n\n        if self.player.is_alive():\n            print(\n                f\"\\n{Colors.GREEN}You defeated the {enemy.name}!{Colors.END}\")\n\n            # Record boss kill for cooldown\n            if isinstance(enemy, Boss):\n                self.player.bosses_killed[\n                    enemy.name] = datetime.now().isoformat()\n\n            # Rewards\n            exp_reward = enemy.experience_reward\n            gold_reward = enemy.gold_reward\n\n            print(\n                f\"Gained {Colors.MAGENTA}{exp_reward} experience{Colors.END}\")\n            print(f\"Gained {Colors.GOLD}{gold_reward} gold{Colors.END}\")\n\n            self.player.gain_experience(exp_reward)\n            self.player.gold += gold_reward\n\n            # Update mission progress for kill\n            self.update_mission_progress('kill', enemy.name)\n\n            # Update challenge progress for kills\n            self.update_challenge_progress('kill_count')\n\n            # Loot drop\n            if enemy.loot_table and random.random(\n            ) < 0.5:  # 50% chance for loot\n                loot = random.choice(enemy.loot_table)\n                self.player.inventory.append(loot)\n                print(f\"{Colors.YELLOW}Loot acquired: {loot}!{Colors.END}\")\n                # Update mission progress for collection\n                self.update_mission_progress('collect', loot)\n            # Post-battle companion effects (e.g., post_battle_heal)\n            if self.player.companions:\n                for companion in self.player.companions:\n                    if isinstance(companion, dict):\n                        comp_id = companion.get('id')\n                        comp_name = companion.get('name')\n                    else:\n                        comp_id = None\n                        comp_name = companion\n\n                    comp_data = None\n                    for cid, cdata in self.companions_data.items():\n                        if cdata.get('name') == comp_name or cid == comp_id:\n                            comp_data = cdata\n                            break\n\n                    if not comp_data:\n                        continue\n\n                    if comp_data.get('post_battle_heal'):\n                        amt = int(comp_data.get('post_battle_heal', 0))\n                        if amt > 0:\n                            self.player.heal(amt)\n                            print(\n                                f\"{Colors.GREEN}{comp_data.get('name')} restores {amt} HP after battle!{Colors.END}\"\n                            )\n        else:\n            print(\n                f\"\\n{Colors.RED}You were defeated by the {enemy.name}...{Colors.END}\"\n            )\n            # Respawn penalty\n            self.player.hp = self.player.max_hp // 2\n            self.player.mp = self.player.max_mp // 2\n            print(\"You respawn at the starting village.\")\n            self.current_area = \"starting_village\"\n\n    def player_turn(self, enemy: Enemy) -> bool:\n        \"\"\"Player's turn in battle. Returns False if player fled.\"\"\"\n        if not self.player:\n            return True\n\n        print(f\"\\n{Colors.BOLD}Your turn!{Colors.END}\")\n        print(\"1. Attack\")\n        print(\"2. Use Item\")\n        print(\"3. Defend\")\n        print(\"4. Flee\")\n        # Can only cast spells if weapon is magic-capable\n        weapon_name: Optional[str] = self.player.equipment.get('weapon')\n        weapon_data = self.items_data.get(weapon_name,\n                                          {}) if weapon_name else {}\n        can_cast = bool(weapon_data.get('magic_weapon'))\n        if can_cast:\n            print(\"5. Cast Spell\")\n\n        choice = ask(\n            \"Choose action (1-5): \" if can_cast else \"Choose action (1-4): \")\n\n        if choice == \"1\":\n            damage = self.player.get_effective_attack()\n            actual_damage = enemy.take_damage(damage)\n            print(f\"You attack for {actual_damage} damage!\")\n        elif choice == \"2\":\n            self.use_item_in_battle()\n        elif choice == \"5\" and can_cast:\n            self.cast_spell(enemy, weapon_name)\n        elif choice == \"3\":\n            print(\"You defend, reducing incoming damage by half!\")\n            self.player.defending = True\n        elif choice == \"4\":\n            flee_chance = 0.7 if self.player.get_effective_speed(\n            ) > enemy.speed else 0.4\n            if random.random() < flee_chance:\n                print(\"You successfully fled from battle!\")\n                return False\n            else:\n                print(\"Failed to flee!\")\n                return True\n        else:\n            print(\"Invalid choice. You lose your turn!\")\n\n        return True\n\n    def companion_action(self, enemy: Enemy):\n        \"\"\"Companions help during battle with their own actions\"\"\"\n        # Backwards-compatible wrapper: pick a random companion and delegate\n        if not self.player or not self.player.companions:\n            return\n        companion = random.choice(self.player.companions)\n        self.companion_action_for(companion, enemy)\n\n    def companion_action_for(self, companion, enemy: Enemy):\n        \"\"\"Perform an action for a specific companion dict or name.\"\"\"\n        if not self.player:\n            return\n\n        # Get companion name (handle both old string format and new dict format)\n        if isinstance(companion, dict):\n            comp_name = companion.get('name')\n            comp_id = companion.get('id')\n        else:\n            comp_name = companion\n            comp_id = None\n\n        # Find companion data\n        comp_data = None\n        for cid, cdata in self.companions_data.items():\n            if cdata.get('name') == comp_name or cid == comp_id:\n                comp_data = cdata\n                break\n\n        if not comp_data:\n            return\n\n        # Prefer using defined abilities; otherwise fallback to simple actions\n        abilities = comp_data.get('abilities', [])\n        used_ability = False\n\n        for ability in abilities:\n            # Chance of triggering ability (ability chance may be percent 0-100 or 0-1)\n            chance = ability.get('chance')\n            triggered = False\n            if chance is None:\n                triggered = True\n            else:\n                # Accept either 0-1 float or 0-100 int\n                if isinstance(chance, float) and 0 <= chance <= 1:\n                    triggered = random.random() < chance\n                else:\n                    try:\n                        triggered = random.randint(1, 100) <= int(chance)\n                    except Exception:\n                        triggered = False\n\n            if not triggered:\n                continue\n\n            used_ability = True\n            atype = ability.get('type')\n\n            if atype in ('attack_boost', 'rage', 'crit_boost'):\n                # Immediate enhanced attack\n                bonus = int(\n                    ability.get('attack_bonus', 0)\n                    or ability.get('crit_damage_bonus', 0) or 0)\n                companion_damage = int(self.player.get_effective_attack() *\n                                       0.6 + comp_data.get('attack_bonus', 0) +\n                                       bonus)\n                actual_damage = enemy.take_damage(companion_damage)\n                print(\n                    f\"{Colors.CYAN}{comp_name} uses {ability.get('name')} for {actual_damage} damage!{Colors.END}\"\n                )\n\n            elif atype == 'taunt':\n                dur = int(ability.get('duration', 1))\n                # Give a temporary defense buff and mark taunt (defensive)\n                dbonus = int(\n                    ability.get('defense_bonus',\n                                comp_data.get('defense_bonus', 0)))\n                self.player.apply_buff(ability.get('name'), dur,\n                                       {'defense_bonus': dbonus})\n                print(\n                    f\"{Colors.BLUE}{comp_name} uses {ability.get('name')} and draws enemy attention!{Colors.END}\"\n                )\n\n            elif atype == 'heal':\n                # immediate heal (chance already checked)\n                heal_amt = int(\n                    ability.get(\n                        'healing',\n                        ability.get('heal', comp_data.get('healing_bonus', 0))\n                        or 0))\n                self.player.heal(heal_amt)\n                print(\n                    f\"{Colors.GREEN}{comp_name} uses {ability.get('name')} and heals you for {heal_amt} HP!{Colors.END}\"\n                )\n\n            elif atype == 'mp_regen':\n                dur = int(ability.get('duration', 3))\n                mp_per = int(\n                    ability.get('mp_per_turn', ability.get('mp_per_turn', 0)))\n                if mp_per > 0:\n                    self.player.apply_buff(ability.get('name'), dur,\n                                           {'mp_per_turn': mp_per})\n                    print(\n                        f\"{Colors.CYAN}{comp_name} grants {mp_per} MP/turn for {dur} turns!{Colors.END}\"\n                    )\n\n            elif atype == 'spell_power':\n                dur = int(ability.get('duration', 3))\n                sp = int(ability.get('spell_power_bonus', 0))\n                if sp:\n                    self.player.apply_buff(ability.get('name'), dur,\n                                           {'spell_power_bonus': sp})\n                    print(\n                        f\"{Colors.CYAN}{comp_name} increases spell power by {sp} for {dur} turns!{Colors.END}\"\n                    )\n\n            elif atype == 'party_buff':\n                dur = int(ability.get('duration', 3))\n                mods = {}\n                for k in ('attack_bonus', 'defense_bonus', 'speed_bonus'):\n                    if ability.get(k) is not None:\n                        mods[k] = int(ability.get(k))\n                if mods:\n                    self.player.apply_buff(ability.get('name'), dur, mods)\n                    print(\n                        f\"{Colors.CYAN}{comp_name} uses {ability.get('name')}, granting party buffs: {mods}!{Colors.END}\"\n                    )\n\n            else:\n                # Unknown ability: fallback to simple action\n                pass\n\n            # If an ability triggered, don't try multiple abilities this turn\n            break\n\n        if not used_ability:\n            # Fallback random behavior\n            action_type = random.choice(['attack', 'defend', 'heal'])\n\n            if action_type == 'attack' and comp_data.get('attack_bonus',\n                                                         0) > 0:\n                companion_damage = int(self.player.get_effective_attack() *\n                                       0.6 + comp_data.get('attack_bonus', 0))\n                actual_damage = enemy.take_damage(companion_damage)\n                print(\n                    f\"{Colors.CYAN}{comp_name} attacks for {actual_damage} damage!{Colors.END}\"\n                )\n\n            elif action_type == 'heal' and comp_data.get('healing_bonus',\n                                                         0) > 0:\n                heal_amount = comp_data.get('healing_bonus', 0)\n                self.player.heal(heal_amount)\n                print(\n                    f\"{Colors.GREEN}{comp_name} heals you for {heal_amount} HP!{Colors.END}\"\n                )\n\n            elif action_type == 'defend' and comp_data.get('defense_bonus',\n                                                           0) > 0:\n                print(\n                    f\"{Colors.BLUE}{comp_name} helps you defend, reducing incoming damage!{Colors.END}\"\n                )\n                self.player.defending = True\n\n    def companions_act(self, enemy: Enemy):\n        \"\"\"Each companion has a chance to act on their own each turn.\"\"\"\n        if not self.player:\n            return\n        for companion in list(self.player.companions):\n            # Default 50% chance to take an action; stronger companions could have higher chance\n            chance = 0.5\n            # read optional field from companion definition\n            if isinstance(companion, dict) and companion.get('action_chance'):\n                chance = companion.get('action_chance') or 0.5\n\n            if random.random() < chance:\n                self.companion_action_for(companion, enemy)\n\n    def enemy_turn(self, enemy: Enemy):\n        \"\"\"Enemy's turn in battle\"\"\"\n        if not self.player:\n            return\n\n        # Handle boss special abilities if it's a boss\n        if isinstance(enemy, Boss):\n            # Reduce cooldowns\n            for abil in enemy.cooldowns:\n                if enemy.cooldowns[abil] > 0:\n                    enemy.cooldowns[abil] -= 1\n\n            # Try to use a special ability\n            available_abilities = [\n                a for a in enemy.special_abilities\n                if enemy.cooldowns.get(a['name'], 0) == 0\n                and enemy.mp >= a.get('mp_cost', 0)\n            ]\n\n            # Check phase-locked abilities\n            current_phase = enemy.phases[\n                enemy.\n                current_phase_index] if enemy.current_phase_index >= 0 else {}\n            unlocked = current_phase.get(\"special_abilities_unlocked\", [])\n            if unlocked:\n                available_abilities = [\n                    a for a in available_abilities if a['name'] in unlocked\n                ]\n\n            if available_abilities and random.random() < 0.4:\n                ability = random.choice(available_abilities)\n                print(\n                    f\"\\n{Colors.RED}{enemy.name} uses {ability['name']}!{Colors.END}\"\n                )\n                print(\n                    f\"{Colors.DARK_GRAY}{ability.get('description')}{Colors.END}\"\n                )\n\n                # Pay costs\n                enemy.mp -= ability.get('mp_cost', 0)\n                enemy.cooldowns[ability['name']] = ability.get('cooldown', 0)\n\n                # Execute effect\n                if 'damage' in ability:\n                    dmg = ability['damage']\n                    if self.player.defending:\n                        dmg //= 2\n                    actual = self.player.take_damage(dmg)\n                    print(f\"It deals {actual} damage!\")\n\n                if 'stun_chance' in ability and random.random(\n                ) < ability['stun_chance']:\n                    print(\n                        f\"{Colors.YELLOW}You are stunned and skip your next turn!{Colors.END}\"\n                    )\n                    self.player.apply_buff(\"Stunned\", 1, {\"speed_bonus\": -999})\n\n                if 'heal_amount' in ability:\n                    heal = ability['heal_amount']\n                    enemy.hp = min(enemy.max_hp, enemy.hp + heal)\n                    print(f\"{enemy.name} heals for {heal} HP!\")\n\n                return  # Skip regular attack if ability used\n\n        damage = enemy.attack\n        if self.player.defending:\n            damage = damage // 2\n            self.player.defending = False\n\n        actual_damage = self.player.take_damage(damage)\n        print(f\"{enemy.name} attacks for {actual_damage} damage!\")\n\n        # Companion may help reduce damage based on defense bonus\n        if self.player.companions:\n            companion_defense_bonus = 0\n            for companion in self.player.companions:\n                if isinstance(companion, dict):\n                    comp_name = companion.get('name')\n                    comp_id = companion.get('id')\n                else:\n                    comp_name = companion\n                    comp_id = None\n\n                for cid, cdata in self.companions_data.items():\n                    if cdata.get('name') == comp_name or cid == comp_id:\n                        companion_defense_bonus += cdata.get(\n                            'defense_bonus', 0)\n                        break\n\n            if companion_defense_bonus > 0:\n                damage_reduction = int(companion_defense_bonus * 0.5)\n                actual_damage = max(1, actual_damage - damage_reduction)\n                # Companions mitigated some damage; heal back the mitigated amount\n                self.player.heal(damage_reduction)\n                print(\n                    f\"{Colors.BLUE}Companions mitigate {damage_reduction} damage!{Colors.END}\"\n                )\n\n    def use_item_in_battle(self):\n        \"\"\"Use item during battle\"\"\"\n        if not self.player:\n            return\n\n        consumables = [\n            item for item in self.player.inventory if item in self.items_data\n            and self.items_data[item].get(\"type\") == \"consumable\"\n        ]\n\n        if not consumables:\n            print(\"No consumable items available!\")\n            return\n\n        print(\"Available consumables:\")\n        for i, item in enumerate(consumables, 1):\n            item_data = self.items_data[item]\n            print(\n                f\"{i}. {item} - {item_data.get('description', 'Unknown effect')}\"\n            )\n\n        try:\n            choice = int(ask(\"Choose item (1-{}): \".format(\n                len(consumables)))) - 1\n            if 0 <= choice < len(consumables):\n                item = consumables[choice]\n                self.use_item(item)\n                self.player.inventory.remove(item)\n            else:\n                print(\"Invalid choice!\")\n        except ValueError:\n            print(\"Invalid input!\")\n\n    def cast_spell(self, enemy: Enemy, weapon_name: Optional[str] = None):\n        \"\"\"Cast a spell from the player's equipped magic weapon.\"\"\"\n        if not self.player:\n            return\n\n        # Handle case where no weapon is equipped\n        if not weapon_name:\n            print(\"You need to equip a magic weapon to cast spells.\")\n            return\n\n        # Gather spells allowed by the equipped weapon\n        available = []\n        for sname, sdata in self.spells_data.items():\n            allowed = sdata.get('allowed_weapons', [])\n            if weapon_name in allowed:\n                available.append((sname, sdata))\n\n        if not available:\n            print(\"No spells available for your weapon.\")\n            return\n\n        # Pagination for spells\n        page = 0\n        per_page = 10\n\n        while True:\n            clear_screen()\n            total_pages = (len(available) + per_page - 1) // per_page\n            if total_pages == 0:\n                total_pages = 1\n            start_idx = page * per_page\n            end_idx = start_idx + per_page\n            current_spells = available[start_idx:end_idx]\n\n            print(\n                f\"\\n{Colors.BOLD}=== SPELLS (Page {page + 1}/{total_pages}) ==={Colors.END}\"\n            )\n            print(\n                f\"MP: {Colors.BLUE}{self.player.mp}/{self.player.max_mp}{Colors.END}\\n\"\n            )\n\n            for i, (sname, sdata) in enumerate(current_spells, 1):\n                cost = sdata.get('mp_cost', 0)\n                mp_color = Colors.BLUE if self.player.mp >= cost else Colors.RED\n                print(\n                    f\"{i}. {Colors.CYAN}{sname}{Colors.END} - Cost: {mp_color}{cost} MP{Colors.END}\"\n                )\n                print(f\"   {sdata.get('description', '')}\")\n\n            print(f\"\\n{Colors.YELLOW}Options:{Colors.END}\")\n            if total_pages > 1:\n                if page > 0:\n                    print(\"P. Previous Page\")\n                if page < total_pages - 1:\n                    print(\"N. Next Page\")\n\n            print(f\"1-{len(current_spells)}. Cast Spell\")\n            print(\"B. Back\")\n\n            choice = ask(\"\\nChoose an option: \").upper()\n\n            if choice == 'B' or not choice:\n                return\n            elif choice == 'N' and page < total_pages - 1:\n                page += 1\n            elif choice == 'P' and page > 0:\n                page -= 1\n            elif choice.isdigit():\n                idx = int(choice) - 1\n                if 0 <= idx < len(current_spells):\n                    sname, sdata = current_spells[idx]\n                    break\n                else:\n                    print(\"Invalid selection.\")\n                    time.sleep(1)\n            else:\n                print(\"Invalid choice.\")\n                time.sleep(1)\n\n        cost = sdata.get('mp_cost', 0)\n        if self.player.mp < cost:\n            print(\"Not enough MP to cast that spell.\")\n            return\n\n        # Pay cost\n        self.player.mp -= cost\n\n        if sdata.get('type') == 'damage':\n            power = sdata.get('power', 0)\n            damage = power + (self.player.get_effective_attack() // 2)\n            actual = enemy.take_damage(damage)\n            print(f\"You cast {sname} for {actual} damage!\")\n\n            # Apply effects if any\n            effects = sdata.get('effects', [])\n            for effect_name in effects:\n                effect_data = self.effects_data.get(effect_name, {})\n                effect_type = effect_data.get('type', '')\n\n                if effect_type == 'damage_over_time':\n                    print(\n                        f\"{Colors.RED}{enemy.name} is afflicted with {effect_name}!{Colors.END}\"\n                    )\n                elif effect_type == 'stun':\n                    if random.random() < effect_data.get('chance', 0.5):\n                        print(\n                            f\"{Colors.YELLOW}{enemy.name} is stunned!{Colors.END}\"\n                        )\n                elif effect_type == 'mixed_effect':\n                    if random.random() < effect_data.get('chance', 0.5):\n                        print(\n                            f\"{Colors.CYAN}{enemy.name} is frozen!{Colors.END}\"\n                        )\n\n        elif sdata.get('type') == 'heal':\n            heal_amount = sdata.get('power', 0)\n            old_hp = self.player.hp\n            self.player.heal(heal_amount)\n            print(f\"You cast {sname} and healed {self.player.hp - old_hp} HP!\")\n\n            # Apply healing effects if any\n            effects = sdata.get('effects', [])\n            for effect_name in effects:\n                effect_data = self.effects_data.get(effect_name, {})\n                if effect_data.get('type') == 'healing_over_time':\n                    print(\n                        f\"{Colors.GREEN}You are affected by regeneration!{Colors.END}\"\n                    )\n\n        elif sdata.get('type') == 'buff':\n            power = sdata.get('power', 0)\n            effects = sdata.get('effects', [])\n\n            for effect_name in effects:\n                effect_data = self.effects_data.get(effect_name, {})\n                effect_type = effect_data.get('type', '')\n\n                # Collect numeric modifiers from effect_data (keys that end with _bonus or known keys)\n                modifiers: Dict[str, int] = {}\n                for k, v in effect_data.items():\n                    if isinstance(v, (int, float)) and (\n                            k.endswith('_bonus')\n                            or k in ('hp_bonus', 'mp_bonus', 'absorb_amount',\n                                     'critical_bonus')):\n                        modifiers[k] = int(v)\n\n                duration = int(\n                    effect_data.get('duration', max(3, int(power or 3))))\n                # Apply as temporary buff\n                if modifiers:\n                    self.player.apply_buff(effect_name, duration, modifiers)\n                    print(\n                        f\"{Colors.GREEN}Applied buff: {effect_name} (+{', '.join(str(v) + ' ' + k for k, v in modifiers.items())}) for {duration} turns{Colors.END}\"\n                    )\n                else:\n                    # Non-numeric effects (like reconnaissance) still applied as a marker buff\n                    self.player.apply_buff(effect_name, duration, {})\n                    if effect_type == 'damage_absorb':\n                        print(\n                            f\"{Colors.BLUE}You create a magical shield!{Colors.END}\"\n                        )\n                    elif effect_type == 'reconnaissance':\n                        print(\n                            f\"{Colors.CYAN}You can see enemy weaknesses!{Colors.END}\"\n                        )\n\n        elif sdata.get('type') == 'debuff':\n            power = sdata.get('power', 0)\n            effects = sdata.get('effects', [])\n\n            for effect_name in effects:\n                effect_data = self.effects_data.get(effect_name, {})\n                effect_type = effect_data.get('type', '')\n\n                if effect_type == 'action_block':\n                    if random.random() < effect_data.get('chance', 0.5):\n                        print(\n                            f\"{Colors.YELLOW}{enemy.name} is stunned and cannot act!{Colors.END}\"\n                        )\n\n                elif effect_type == 'accuracy_reduction':\n                    print(\n                        f\"{Colors.RED}{enemy.name}'s accuracy is reduced!{Colors.END}\"\n                    )\n\n                elif effect_type == 'speed_reduction':\n                    print(\n                        f\"{Colors.YELLOW}{enemy.name} is slowed!{Colors.END}\")\n\n                elif effect_type == 'stat_reduction':\n                    print(\n                        f\"{Colors.RED}{enemy.name}'s stats are cursed!{Colors.END}\"\n                    )\n\n        else:\n            print(f\"Unknown spell type: {sdata.get('type')}\")\n            # Refund MP for unknown spell types\n            self.player.mp += cost\n\n        # Check for cast cutscene\n        cast_cutscene = sdata.get('cast_cutscene')\n        if cast_cutscene and cast_cutscene in self.cutscenes_data:\n            self.play_cutscene(cast_cutscene)\n\n    def use_item(self, item: str):\n        \"\"\"Use an item\"\"\"\n        if not self.player:\n            return\n\n        item_data = self.items_data.get(item, {})\n        item_type = item_data.get(\"type\")\n\n        if item_type == \"consumable\":\n            if item_data.get(\"effect\") == \"heal\":\n                heal_amount = item_data.get(\"value\", 0)\n                old_hp = self.player.hp\n                self.player.heal(heal_amount)\n                print(f\"Used {item}, healed {self.player.hp - old_hp} HP!\")\n            elif item_data.get(\"effect\") == \"mp_restore\":\n                mp_amount = item_data.get(\"value\", 0)\n                old_mp = self.player.mp\n                self.player.mp = min(self.player.max_mp,\n                                     self.player.mp + mp_amount)\n                print(f\"Used {item}, restored {self.player.mp - old_mp} MP!\")\n\n    def view_inventory(self):\n        \"\"\"View character inventory\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        print(f\"\\n{Colors.BOLD}=== INVENTORY ==={Colors.END}\")\n        print(f\"Gold: {Colors.GOLD}{self.player.gold}{Colors.END}\")\n\n        if not self.player.inventory:\n            print(\"Your inventory is empty.\")\n            return\n\n        # Group items by type\n        items_by_type = {}\n        for item in self.player.inventory:\n            item_type = self.items_data.get(item, {}).get(\"type\", \"unknown\")\n            if item_type not in items_by_type:\n                items_by_type[item_type] = []\n            items_by_type[item_type].append(item)\n\n        for item_type, items in items_by_type.items():\n            print(f\"\\n{Colors.CYAN}{item_type.title()}:{Colors.END}\")\n            for item in items:\n                item_data = self.items_data.get(item, {})\n                print(f\"  - {item}\")\n                if item_data.get(\"description\"):\n                    print(f\"    {item_data['description']}\")\n\n        # Offer equip/unequip options for equipment items\n        equipable = [\n            it for it in self.player.inventory\n            if self.items_data.get(it, {}).get('type') in ('weapon', 'armor',\n                                                           'accessory',\n                                                           'offhand')\n        ]\n        if equipable:\n            print(\"\\nEquipment options:\")\n            print(\"  E. Equip an item from inventory\")\n            print(\"  U. Unequip a slot\")\n            choice = ask(\"Choose option (E/U) or press Enter to return: \")\n            if choice.lower() == 'e':\n                print(\"\\nEquipable items:\")\n                for i, item in enumerate(equipable, 1):\n                    print(\n                        f\"{i}. {item} - {self.items_data.get(item, {}).get('description','')}\"\n                    )\n                sel = ask(\n                    f\"Choose item to equip (1-{len(equipable)}) or press Enter: \"\n                )\n                if sel and sel.isdigit():\n                    idx = int(sel) - 1\n                    if 0 <= idx < len(equipable):\n                        item_name = equipable[idx]\n                        ok = self.player.equip(item_name, self.items_data)\n                        if ok:\n                            print(f\"Equipped {item_name}.\")\n                        else:\n                            print(\n                                f\"Cannot equip {item_name} (requirements not met).\"\n                            )\n            elif choice.lower() == 'u':\n                print(\"\\nCurrently equipped:\")\n                for slot in ('weapon', 'armor', 'offhand', 'accessory_1',\n                             'accessory_2', 'accessory_3'):\n                    print(\n                        f\"{slot.title()}: {self.player.equipment.get(slot, 'None')}\"\n                    )\n                slot_choice = ask(\n                    \"Enter slot to unequip (weapon/armor/offhand/accessory_1/accessory_2/accessory_3) or press Enter: \"\n                )\n                valid_slots = ('weapon', 'armor', 'offhand', 'accessory_1',\n                               'accessory_2', 'accessory_3')\n                if slot_choice in valid_slots:\n                    removed = self.player.unequip(slot_choice, self.items_data)\n                    if removed:\n                        print(f\"Unequipped {removed} from {slot_choice}.\")\n                    else:\n                        print(\"Nothing to unequip from that slot.\")\n\n    def view_missions(self):\n        \"\"\"View and manage missions\"\"\"\n        while True:\n            clear_screen()\n            print(create_section_header(\"MISSIONS\"))\n\n            # Active Missions\n            active_missions = [\n                mid for mid in self.mission_progress.keys()\n                if not self.mission_progress[mid].get('completed', False)\n            ]\n\n            if active_missions:\n                print(f\"\\n{Colors.CYAN}--- Active Missions ---{Colors.END}\")\n                for i, mid in enumerate(active_missions, 1):\n                    mission = self.missions_data.get(mid, {})\n                    progress = self.mission_progress[mid]\n\n                    if progress['type'] == 'kill':\n                        if 'current_counts' in progress:\n                            lines = [\n                                f\"{t}: {progress['current_counts'].get(t,0)}/{c}\"\n                                for t, c in progress['target_counts'].items()\n                            ]\n                            status = \", \".join(lines)\n                        else:\n                            status = f\"{progress['current_count']}/{progress['target_count']}\"\n                    else:\n                        if 'current_counts' in progress:\n                            lines = [\n                                f\"{t}: {progress['current_counts'].get(t,0)}/{c}\"\n                                for t, c in progress['target_counts'].items()\n                            ]\n                            status = \", \".join(lines)\n                        else:\n                            status = f\"{progress['current_count']}/{progress['target_count']}\"\n\n                    print(f\"{i}. {mission.get('name')} - {status}\")\n                    print(\n                        f\"   {Colors.DARK_GRAY}{mission.get('description')}{Colors.END}\"\n                    )\n\n                print(\"\\nOptions: [A] Available, [C] Cancel Mission, [B] Back\")\n            else:\n                print(\"\\nNo active missions.\")\n                print(\"\\nOptions: [A] Available Missions, [B] Back\")\n\n            choice = ask(\"\\nChoose an option: \").upper()\n\n            if choice == 'B':\n                break\n            elif choice == 'A':\n                self.available_missions_menu()\n            elif choice == 'C' and active_missions:\n                idx_str = ask(\"Enter mission number to cancel: \")\n                if idx_str.isdigit():\n                    idx = int(idx_str) - 1\n                    if 0 <= idx < len(active_missions):\n                        m_id = active_missions[idx]\n                        m_name = self.missions_data[m_id]['name']\n                        confirm = ask(\n                            f\"Are you sure you want to cancel '{m_name}'? (y/n): \"\n                        ).lower()\n                        if confirm == 'y':\n                            del self.mission_progress[m_id]\n                            print(f\"Mission '{m_name}' cancelled.\")\n                            time.sleep(1)\n                    else:\n                        print(\"Invalid mission number.\")\n                        time.sleep(1)\n\n    def available_missions_menu(self):\n        \"\"\"Menu for viewing and accepting available missions\"\"\"\n        page = 0\n        per_page = 10\n\n        while True:\n            clear_screen()\n            print(create_section_header(\"AVAILABLE MISSIONS\"))\n\n            available_missions = [\n                mid for mid in self.missions_data.keys()\n                if mid not in self.mission_progress\n                and mid not in self.completed_missions\n            ]\n\n            if not available_missions:\n                print(\"\\nNo new missions available at this time.\")\n                ask(\"\\nPress Enter to go back...\")\n                break\n\n            total_pages = (len(available_missions) + per_page - 1) // per_page\n            start_idx = page * per_page\n            end_idx = min(start_idx + per_page, len(available_missions))\n            current_page_missions = available_missions[start_idx:end_idx]\n\n            for i, mission_id in enumerate(current_page_missions, 1):\n                mission = self.missions_data.get(mission_id, {})\n                print(f\"{i}. {Colors.BOLD}{mission.get('name')}{Colors.END}\")\n                print(f\"   {mission.get('description')}\")\n\n                # Requirements\n                reqs = []\n                if mission.get('unlock_level'):\n                    level_req = mission.get('unlock_level')\n                    has_level = self.player.level >= level_req if self.player else False\n                    color = Colors.GREEN if has_level else Colors.RED\n                    reqs.append(f\"Level {color}{level_req}{Colors.END}\")\n                if mission.get('prerequisites'):\n                    for prereq_id in mission.get('prerequisites'):\n                        prereq_name = self.missions_data.get(\n                            prereq_id, {}).get('name', prereq_id)\n                        color = Colors.GREEN if prereq_id in self.completed_missions else Colors.RED\n                        reqs.append(\n                            f\"Requires: {color}{prereq_name}{Colors.END}\")\n                if reqs:\n                    print(f\"   Requirements: {', '.join(reqs)}\")\n\n            print(f\"\\nPage {page + 1}/{total_pages}\")\n            if total_pages > 1:\n                if page > 0:\n                    print(\"P. Previous Page\")\n                if page < total_pages - 1:\n                    print(\"N. Next Page\")\n\n            if current_page_missions:\n                print(f\"1-{len(current_page_missions)}. Accept Mission\")\n            print(\"B. Back\")\n\n            choice = ask(\"\\nChoose an option: \").upper()\n\n            if choice == 'B':\n                break\n            elif choice == 'N' and page < total_pages - 1:\n                page += 1\n            elif choice == 'P' and page > 0:\n                page -= 1\n            elif choice.isdigit():\n                idx = int(choice) - 1\n                if 0 <= idx < len(current_page_missions):\n                    mission_id = current_page_missions[idx]\n                    self.accept_mission(mission_id)\n                else:\n                    print(\"Invalid mission number.\")\n                    time.sleep(1)\n\n    def accept_mission(self, mission_id: str):\n        \"\"\"Accept a mission\"\"\"\n        if mission_id not in self.mission_progress:\n            mission = self.missions_data.get(mission_id, {})\n\n            # Initialize progress tracking for this mission\n            if mission:\n                mission_type = mission.get('type', 'kill')\n                target_count = mission.get('target_count', 1)\n\n                if mission_type == 'collect' and isinstance(\n                        target_count, dict):\n                    # For collect missions with multiple items\n                    self.mission_progress[mission_id] = {\n                        'current_counts': {\n                            item: 0\n                            for item in target_count.keys()\n                        },\n                        'target_counts': target_count,\n                        'completed': False,\n                        'type': mission_type\n                    }\n                else:\n                    # For kill missions or single item collect missions\n                    self.mission_progress[mission_id] = {\n                        'current_count': 0,\n                        'target_count': target_count,\n                        'completed': False,\n                        'type': mission_type\n                    }\n\n                print(f\"Mission accepted: {mission.get('name', 'Unknown')}\")\n\n                # Check for accept cutscene\n                accept_cutscene = mission.get('accept_cutscene')\n                if accept_cutscene and accept_cutscene in self.cutscenes_data:\n                    self.play_cutscene(accept_cutscene)\n\n                time.sleep(1)\n            else:\n                print(\"Error: Mission data not found.\")\n                time.sleep(1)\n        else:\n            print(\"Mission already accepted!\")\n            time.sleep(1)\n\n    def update_mission_progress(self,\n                                update_type: str,\n                                target: str,\n                                count: int = 1):\n        \"\"\"Update mission progress for a specific target\"\"\"\n        # Always check inventory-based collect missions\n        if self.player:\n            for mid, progress in self.mission_progress.items():\n                if progress.get('completed', False):\n                    continue\n                mission = self.missions_data.get(mid, {})\n                if progress['type'] == 'collect':\n                    if 'current_counts' in progress:\n                        for item in progress['target_counts'].keys():\n                            inv_count = self.player.inventory.count(item)\n                            progress['current_counts'][item] = inv_count\n\n                        all_collected = all(\n                            progress['current_counts'][item] >=\n                            progress['target_counts'][item]\n                            for item in progress['target_counts'])\n                        if all_collected:\n                            self.complete_mission(mid)\n                    else:\n                        target_item = mission.get('target', '')\n                        inv_count = self.player.inventory.count(target_item)\n                        progress['current_count'] = inv_count\n                        if progress['current_count'] >= progress[\n                                'target_count']:\n                            self.complete_mission(mid)\n\n        # Standard update logic for kills or specific increments\n        for mid, progress in self.mission_progress.items():\n            if progress.get('completed', False):\n                continue\n\n            mission = self.missions_data.get(mid, {})\n\n            if progress['type'] == 'kill' and update_type == 'kill':\n                target_enemy = mission.get('target', '').lower()\n                if target_enemy == target.lower():\n                    progress['current_count'] += count\n                    print(\n                        f\"{Colors.CYAN}[Mission Progress] {mission.get('name')}: {progress['current_count']}/{progress['target_count']}{Colors.END}\"\n                    )\n\n                    if progress['current_count'] >= progress['target_count']:\n                        self.complete_mission(mid)\n\n            elif progress['type'] == 'collect' and update_type == 'collect':\n                # Handle collection missions\n                if 'current_counts' in progress:\n                    # Multi-item collection\n                    if target in progress['current_counts']:\n                        progress['current_counts'][target] += count\n                        print(\n                            f\"{Colors.CYAN}[Mission Progress] {mission.get('name')} - {target}: {progress['current_counts'][target]}/{progress['target_counts'][target]}{Colors.END}\"\n                        )\n\n                        # Check if all items are collected\n                        all_collected = all(\n                            progress['current_counts'][item] >=\n                            progress['target_counts'][item]\n                            for item in progress['target_counts'])\n                        if all_collected:\n                            self.complete_mission(mid)\n                else:\n                    # Single item collection\n                    target_item = mission.get('target', '')\n                    if target_item == target:\n                        progress['current_count'] += count\n                        print(\n                            f\"{Colors.CYAN}[Mission Progress] {mission.get('name')}: {progress['current_count']}/{progress['target_count']}{Colors.END}\"\n                        )\n\n                        if progress['current_count'] >= progress[\n                                'target_count']:\n                            self.complete_mission(mid)\n\n    def complete_mission(self, mission_id: str):\n        \"\"\"Mark a mission as completed and notify player\"\"\"\n        if mission_id in self.mission_progress:\n            self.mission_progress[mission_id]['completed'] = True\n            mission = self.missions_data.get(mission_id, {})\n            print(\n                f\"\\n{Colors.GOLD}{Colors.BOLD}!!! MISSION COMPLETE: {mission.get('name')} !!!{Colors.END}\"\n            )\n            print(\n                f\"{Colors.YELLOW}You can now claim your rewards from the menu.{Colors.END}\"\n            )\n\n            # Check for complete cutscene\n            complete_cutscene = mission.get('complete_cutscene')\n            if complete_cutscene and complete_cutscene in self.cutscenes_data:\n                self.play_cutscene(complete_cutscene)\n\n            time.sleep(2)\n\n    def claim_rewards(self):\n        \"\"\"Claim rewards for completed missions\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        completed_missions = [\n            mid for mid, progress in self.mission_progress.items()\n            if progress.get('completed', False)\n        ]\n        if not completed_missions:\n            print(\"No completed missions to claim rewards for.\")\n            return\n\n        print(f\"\\n{Colors.BOLD}=== CLAIM REWARDS ==={Colors.END}\")\n        print(\"Completed missions:\")\n        for i, mid in enumerate(completed_missions, 1):\n            mission = self.missions_data.get(mid, {})\n            reward = mission.get('reward', {})\n            exp = reward.get('experience', 0)\n            gold = reward.get('gold', 0)\n            items = reward.get('items', [])\n            print(\n                f\"{i}. {mission.get('name')} - Exp: {exp}, Gold: {gold}, Items: {', '.join(items) if items else 'None'}\"\n            )\n\n        choice = ask(\n            f\"Claim rewards for mission (1-{len(completed_missions)}) or press Enter to cancel: \"\n        )\n        if choice and choice.isdigit():\n            idx = int(choice) - 1\n            if 0 <= idx < len(completed_missions):\n                mission_id = completed_missions[idx]\n                mission = self.missions_data.get(mission_id, {})\n                reward = mission.get('reward', {})\n\n                # Apply rewards\n                exp = reward.get('experience', 0)\n                gold = reward.get('gold', 0)\n                items = reward.get('items', [])\n\n                self.player.gain_experience(exp)\n                self.player.gold += gold\n                for item in items:\n                    self.player.inventory.append(item)\n\n                # Remove from progress and add to completed\n                del self.mission_progress[mission_id]\n                self.completed_missions.append(mission_id)\n\n                print(f\"\\n{Colors.GREEN}Rewards claimed!{Colors.END}\")\n                print(f\"Gained {Colors.MAGENTA}{exp} experience{Colors.END}\")\n                print(f\"Gained {Colors.GOLD}{gold} gold{Colors.END}\")\n                if items:\n                    print(f\"Received items: {', '.join(items)}\")\n            else:\n                print(\"Invalid choice.\")\n\n    def visit_shop(self):\n        \"\"\"Visit the shop - displays items for sale in the current area\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        area_data = self.areas_data.get(self.current_area, {})\n        area_shops = area_data.get(\"shops\", [])\n\n        # Add housing shop if in your_land\n        available_shops = list(area_shops)\n        if self.current_area == \"your_land\":\n            available_shops.append(\"housing_shop\")\n\n        if not available_shops:\n            print(\n                f\"\\n{Colors.RED}There are no shops in {area_data.get('name', self.current_area)}.{Colors.END}\"\n            )\n            return\n\n        # If multiple shops, let player choose\n        if len(available_shops) > 1:\n            print(\n                f\"\\n{Colors.BOLD}=== SHOPS IN {area_data.get('name', self.current_area).upper()} ==={Colors.END}\"\n            )\n            print(f\"Your gold: {Colors.GOLD}{self.player.gold}{Colors.END}\\n\")\n            for i, shop_id in enumerate(available_shops, 1):\n                if shop_id == \"housing_shop\":\n                    shop_name = \"Housing Shop\"\n                else:\n                    shop_data = self.shops_data.get(shop_id, {})\n                    shop_name = shop_data.get(\n                        \"name\",\n                        shop_id.replace(\"_\", \" \").title())\n                print(f\"{i}. {shop_name}\")\n\n            print(\"\\n0. Leave\")\n            choice = ask(\"Which shop would you like to visit? \")\n\n            if choice == \"0\" or not choice.isdigit():\n                return\n\n            shop_idx = int(choice) - 1\n            if 0 <= shop_idx < len(available_shops):\n                selected_shop = available_shops[shop_idx]\n            else:\n                print(\"Invalid choice.\")\n                return\n        else:\n            selected_shop = available_shops[0]\n\n        # Now visit the selected shop\n        if selected_shop == \"housing_shop\":\n            self._visit_housing_shop_inline()\n        else:\n            self.visit_specific_shop(selected_shop)\n\n    def _visit_housing_shop_inline(self):\n        \"\"\"Visit the housing shop in your_land to buy housing items\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        print(f\"\\n{Colors.BOLD}{Colors.CYAN}=== HOUSING SHOP ==={Colors.END}\")\n        print(\n            f\"{Colors.YELLOW}Welcome to the Housing Shop! Build your dream home with these items.{Colors.END}\"\n        )\n        print(f\"\\nYour gold: {Colors.GOLD}{self.player.gold}{Colors.END}\")\n        print(\n            f\"Comfort Points: {Colors.CYAN}{self.player.comfort_points}{Colors.END}\"\n        )\n        print(\n            f\"Items owned: {Colors.MAGENTA}{len(self.player.housing_owned)}{Colors.END}\"\n        )\n\n        # Get all housing items\n        housing_items = list(self.housing_data.items())\n        if not housing_items:\n            print(\"No housing items available.\")\n            return\n\n        page_size = 8\n        current_page = 0\n\n        while True:\n            start = current_page * page_size\n            end = start + page_size\n            page_items = housing_items[start:end]\n\n            if not page_items:\n                print(\"No more items.\")\n                break\n\n            print(\n                f\"\\n{Colors.CYAN}--- Page {current_page + 1} of {(len(housing_items) + page_size - 1) // page_size} ---{Colors.END}\"\n            )\n            for i, (item_id, item_data) in enumerate(page_items, 1):\n                name = item_data.get(\"name\", item_id)\n                price = item_data.get(\"price\", 0)\n                comfort = item_data.get(\"comfort_points\", 0)\n                desc = item_data.get(\"description\", \"\")\n                owned = \"âœ“\" if item_id in self.player.housing_owned else \" \"\n\n                # Color price based on affordability\n                price_color = Colors.GREEN if self.player.gold >= price else Colors.RED\n                # Color owned indicator\n                owned_color = Colors.GREEN if owned == \"âœ“\" else Colors.RED\n\n                print(\n                    f\"\\n{Colors.CYAN}{i}.{Colors.END} [{owned_color}{owned}{Colors.END}] {Colors.BOLD}{Colors.YELLOW}{name}{Colors.END}\"\n                )\n                print(f\"   {desc}\")\n                print(\n                    f\"   Price: {price_color}{price} gold{Colors.END} | Comfort: {Colors.CYAN}+{comfort}{Colors.END}\"\n                )\n\n            print(f\"\\n{Colors.YELLOW}Options:{Colors.END}\")\n            print(\n                f\"{Colors.CYAN}1-{len(page_items)}.{Colors.END} Buy/Add Housing Item\"\n            )\n            if len(housing_items) > page_size:\n                print(f\"{Colors.CYAN}N.{Colors.END} Next Page\")\n                print(f\"{Colors.CYAN}P.{Colors.END} Previous Page\")\n            print(f\"{Colors.GOLD}B.{Colors.END} Furnish/View Home\")\n            print(f\"{Colors.CYAN}Enter.{Colors.END} Leave Shop\")\n\n            choice = ask(\"\\nChoose action: \").strip().upper()\n\n            if not choice:\n                break\n            elif choice == 'N' and len(housing_items) > page_size:\n                if end < len(housing_items):\n                    current_page += 1\n            elif choice == 'P' and len(housing_items) > page_size:\n                if current_page > 0:\n                    current_page -= 1\n            elif choice == 'B':\n                self.build_home()\n            elif choice.isdigit():\n                item_idx = int(choice) - 1\n                if 0 <= item_idx < len(page_items):\n                    item_id, item_data = page_items[item_idx]\n                    name = item_data.get(\"name\", item_id)\n                    price = item_data.get(\"price\", 0)\n                    comfort = item_data.get(\"comfort_points\", 0)\n\n                    # Check if already owned\n                    if item_id in self.player.housing_owned:\n                        # Option to buy another copy or view details\n                        confirm = ask(\n                            f\"\\n{Colors.YELLOW}You already own this. Buy another copy for {Colors.GOLD}{price} gold{Colors.YELLOW}? (y/n): {Colors.END}\"\n                        ).strip().lower()\n                        if confirm != 'y':\n                            continue\n\n                    # Check if can afford\n                    if self.player.gold >= price:\n                        self.player.gold -= price\n                        self.player.housing_owned.append(item_id)\n                        self.player.comfort_points += comfort\n                        print(\n                            f\"\\n{Colors.GREEN}âœ“ Purchased {Colors.BOLD}{name}{Colors.END}{Colors.GREEN}!{Colors.END}\"\n                        )\n                        print(\n                            f\"{Colors.CYAN}Comfort points: +{comfort} (Total: {self.player.comfort_points}){Colors.END}\"\n                        )\n                    else:\n                        print(\n                            f\"\\n{Colors.RED}âœ— Not enough gold! Need {Colors.BOLD}{price}{Colors.END}{Colors.RED}, have {self.player.gold}.{Colors.END}\"\n                        )\n                else:\n                    print(f\"{Colors.RED}Invalid selection.{Colors.END}\")\n\n    def visit_specific_shop(self, shop_id):\n        \"\"\"Visit a specific shop by ID\"\"\"\n\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        shop_data = self.shops_data.get(shop_id, {})\n        if not shop_data:\n            print(f\"Shop {shop_id} not found.\")\n            return\n\n        self._visit_general_shop(shop_data)\n\n    def build_home(self):\n        \"\"\"Build and manage structures on your land\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        if not self.player.housing_owned:\n            print(\n                f\"{Colors.YELLOW}You haven't purchased any housing items yet! Visit the Housing Shop first.{Colors.END}\"\n            )\n            input(\"Press Enter to continue...\")\n            return\n\n        while True:\n            clear_screen()\n            print(\n                f\"\\n{Colors.BOLD}{Colors.CYAN}=== BUILD STRUCTURES ==={Colors.END}\"\n            )\n            print(\n                f\"{Colors.YELLOW}Manage your buildings and customize your property{Colors.END}\\n\"\n            )\n\n            print(\n                f\"Comfort Points: {Colors.CYAN}{self.player.comfort_points}{Colors.END}\\n\"\n            )\n\n            # Display building categories\n            building_types = {\n                \"house\": {\n                    \"label\": \"House\",\n                    \"slots\": 3\n                },\n                \"decoration\": {\n                    \"label\": \"Decoration\",\n                    \"slots\": 10\n                },\n                \"fencing\": {\n                    \"label\": \"Fencing\",\n                    \"slots\": 1\n                },\n                \"garden\": {\n                    \"label\": \"Garden\",\n                    \"slots\": 3\n                },\n                \"farm\": {\n                    \"label\": \"Farm\",\n                    \"slots\": 2\n                },\n                \"farming\": {\n                    \"label\": \"Farming\",\n                    \"slots\": 2\n                },\n                \"training_place\": {\n                    \"label\": \"Training Place\",\n                    \"slots\": 3\n                },\n            }\n            for b_type, info in building_types.items():\n                print(f\"{Colors.BOLD}{info['label']} Slots:{Colors.END}\")\n                for i in range(1, info[\"slots\"] + 1):\n                    slot = f\"{b_type}_{i}\"\n                    item_id = self.player.building_slots.get(slot)\n                    if item_id is not None and item_id in self.housing_data:\n                        item = self.housing_data[item_id]\n                        rarity_color = get_rarity_color(\n                            item.get('rarity', 'common'))\n                        print(\n                            f\"  {slot}: {rarity_color}{item.get('name', item_id)}{Colors.END}\"\n                        )\n                    else:\n                        print(f\"  {slot}: {Colors.GRAY}Empty{Colors.END}\")\n                print()\n\n            print(f\"{Colors.BOLD}Options:{Colors.END}\")\n            print(\"1. Place Item in Slot\")\n            print(\"2. Remove Item from Slot\")\n            print(\"3. View detailed home status\")\n            print(\"B. Back\")\n\n            choice = ask(\n                f\"\\n{Colors.CYAN}Choose option: {Colors.END}\").strip().upper()\n\n            if choice == 'B':\n                break\n            elif choice == '1':\n                self._place_housing_item()\n            elif choice == '2':\n                self.remove_housing_item()\n            elif choice == '3':\n                self.view_home_status()\n            else:\n                print(f\"{Colors.RED}Invalid choice.{Colors.END}\")\n                time.sleep(1)\n\n    def view_home_status(self):\n        \"\"\"View detailed home status and statistics\"\"\"\n        if not self.player:\n            return\n\n        print(f\"\\n{Colors.BOLD}=== HOME DETAILS ==={Colors.END}\")\n        print(\n            f\"\\nComfort Points: {Colors.CYAN}{self.player.comfort_points}{Colors.END}\"\n        )\n        placed_items = [\n            item_id for item_id in self.player.building_slots.values()\n            if item_id is not None\n        ]\n        print(f\"Total Items Placed: {len(placed_items)}\")\n        print(f\"Unique Items Placed: {len(set(placed_items))}\")\n\n        # Calculate comfort distribution\n        print(f\"\\n{Colors.BOLD}Item Breakdown:{Colors.END}\")\n        item_comforts = {}\n        for item_id in placed_items:\n            item_data = self.housing_data.get(item_id, {})\n            name = item_data.get(\"name\", item_id)\n            comfort = item_data.get(\"comfort_points\", 0)\n\n            if name not in item_comforts:\n                item_comforts[name] = {\"count\": 0, \"total_comfort\": 0}\n            item_comforts[name][\"count\"] += 1\n            item_comforts[name][\"total_comfort\"] += comfort\n\n        # Sort by total comfort contribution\n        sorted_items = sorted(item_comforts.items(),\n                              key=lambda x: x[1][\"total_comfort\"],\n                              reverse=True)\n\n        total_displayed = 0\n        for name, info in sorted_items[:10]:  # Show top 10\n            print(\n                f\"  {name}: x{info['count']} = +{info['total_comfort']} comfort\"\n            )\n            total_displayed += 1\n\n        if len(sorted_items) > 10:\n            remaining_comfort = sum(info[\"total_comfort\"]\n                                    for _, info in sorted_items[10:])\n            print(\n                f\"  ... and {len(sorted_items) - 10} more items (+{remaining_comfort} comfort)\"\n            )\n\n        ask(\"\\nPress Enter to continue...\")\n\n    def remove_housing_item(self):\n        \"\"\"Remove a housing item from a slot\"\"\"\n        if not self.player:\n            return\n        occupied_slots = [\n            slot for slot, item_id in self.player.building_slots.items()\n            if item_id is not None\n        ]\n\n        if not occupied_slots:\n            print(\"No items placed to remove.\")\n            return\n\n        print(f\"\\n{Colors.BOLD}Placed Items:{Colors.END}\")\n        for i, slot in enumerate(occupied_slots, 1):\n            item_id = self.player.building_slots[slot]\n            if item_id in self.housing_data:\n                item = self.housing_data[item_id]\n                rarity_color = get_rarity_color(item.get('rarity', 'common'))\n                print(\n                    f\"{i}. {slot}: {rarity_color}{item.get('name', item_id)}{Colors.END}\"\n                )\n\n        choice = ask(\n            f\"\\nChoose item to remove (1-{len(occupied_slots)}) or press Enter to cancel: \"\n        ).strip()\n\n        if not choice:\n            return\n\n        if not choice.isdigit():\n            print(\"Invalid choice.\")\n            return\n\n        idx = int(choice) - 1\n        if not (0 <= idx < len(occupied_slots)):\n            print(\"Invalid item number.\")\n            return\n\n        target_slot = occupied_slots[idx]\n        item_id = self.player.building_slots[target_slot]\n\n        # Remove the item\n        self.player.building_slots[target_slot] = None\n\n        # Update comfort\n        if item_id is not None:\n            item = self.housing_data.get(item_id)\n        else:\n            item = None\n        if item:\n            self.player.comfort_points -= item.get('comfort_points', 0)\n\n        print(f\"{Colors.YELLOW}Removed item from {target_slot}.{Colors.END}\")\n        input(\"Press Enter to continue...\")\n\n    def _place_housing_item(self):\n        \"\"\"Place a housing item in a slot\"\"\"\n        if not self.player:\n            return\n        if not self.player.housing_owned:\n            print(\"No housing items to place.\")\n            return\n\n        print(f\"\\n{Colors.BOLD}Available Items:{Colors.END}\")\n        for i, item_id in enumerate(self.player.housing_owned, 1):\n            if item_id in self.housing_data:\n                item = self.housing_data[item_id]\n                rarity_color = get_rarity_color(item.get('rarity', 'common'))\n                print(\n                    f\"{i}. {rarity_color}{item.get('name', item_id)}{Colors.END} ({item.get('type', 'misc')})\"\n                )\n\n        choice = ask(\n            f\"\\nChoose item (1-{len(self.player.housing_owned)}) or press Enter to cancel: \"\n        ).strip()\n\n        if not choice:\n            return\n\n        if not choice.isdigit():\n            print(\"Invalid choice.\")\n            return\n\n        idx = int(choice) - 1\n        if not (0 <= idx < len(self.player.housing_owned)):\n            print(\"Invalid item number.\")\n            return\n\n        item_id = self.player.housing_owned[idx]\n        item = self.housing_data.get(item_id)\n\n        if not item:\n            print(\"Item data not found.\")\n            return\n\n        item_type = item.get('type', 'decoration')\n\n        # Find available slots for this item type\n        available_slots = []\n        if item_type == 'house':\n            available_slots = [f\"house_{i}\" for i in range(1, 4)]\n        elif item_type == 'decoration':\n            available_slots = [f\"decoration_{i}\" for i in range(1, 11)]\n        elif item_type == 'fencing':\n            available_slots = ['fencing_1']\n        elif item_type == 'garden':\n            available_slots = [f\"garden_{i}\" for i in range(1, 4)]\n        elif item_type == 'training_place':\n            available_slots = [f\"training_place_{i}\" for i in range(1, 4)]\n        elif item_type == 'farming':\n            available_slots = [f\"farm_{i}\" for i in range(1, 3)]\n        elif item_type == 'crafting':\n            available_slots = ['crafting_1']\n        elif item_type == 'storage':\n            available_slots = ['storage_1']\n\n        # Filter to slots that are empty\n        empty_slots = [\n            slot for slot in available_slots\n            if self.player.building_slots.get(slot) is None\n        ]\n\n        if not empty_slots:\n            print(f\"No available slots for {item_type} items.\")\n            return\n\n        print(f\"\\nAvailable slots for {item_type}:\")\n        for i, slot in enumerate(empty_slots, 1):\n            print(f\"{i}. {slot}\")\n\n        slot_choice = ask(\n            f\"\\nChoose slot (1-{len(empty_slots)}) or press Enter to cancel: \"\n        ).strip()\n\n        if not slot_choice:\n            return\n\n        if not slot_choice.isdigit():\n            print(\"Invalid choice.\")\n            return\n\n        slot_idx = int(slot_choice) - 1\n        if not (0 <= slot_idx < len(empty_slots)):\n            print(\"Invalid slot number.\")\n            return\n\n        target_slot = empty_slots[slot_idx]\n\n        # Place the item\n        self.player.building_slots[target_slot] = item_id\n\n        # Update comfort\n        if item:\n            self.player.comfort_points += item.get('comfort_points', 0)\n\n        print(\n            f\"{Colors.GREEN}Placed {item.get('name', item_id)} in {target_slot}!{Colors.END}\"\n        )\n        input(\"Press Enter to continue...\")\n\n    def build_structures(self):\n        \"\"\"Build and manage structures on your land\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        while True:\n            clear_screen()\n            print(\n                f\"\\n{Colors.BOLD}{Colors.CYAN}=== BUILD STRUCTURES ==={Colors.END}\"\n            )\n            print(\n                f\"{Colors.YELLOW}Manage your buildings and customize your property{Colors.END}\\n\"\n            )\n\n            # Display building categories\n            building_types = {\n                \"house\": {\n                    \"label\": \"House\",\n                    \"slots\": 3,\n                    \"max_owned\": 0\n                },\n                \"decoration\": {\n                    \"label\": \"Decoration\",\n                    \"slots\": 10,\n                    \"max_owned\": 0\n                },\n                \"fencing\": {\n                    \"label\": \"Fencing\",\n                    \"slots\": 1,\n                    \"max_owned\": 0\n                },\n                \"garden\": {\n                    \"label\": \"Garden\",\n                    \"slots\": 3,\n                    \"max_owned\": 0\n                },\n                \"farm\": {\n                    \"label\": \"Farm\",\n                    \"slots\": 2,\n                    \"max_owned\": 0\n                },\n                \"farming\": {\n                    \"label\": \"Farming\",\n                    \"slots\": 2,\n                    \"max_owned\": 0\n                },\n                \"training_place\": {\n                    \"label\": \"Training Place\",\n                    \"slots\": 3,\n                    \"max_owned\": 0\n                },\n            }\n\n            # Count occupied slots and available items for each type\n            placed_items = {b_type: 0 for b_type in building_types}\n            available_items = {b_type: [] for b_type in building_types}\n\n            for slot_name, item_id in self.player.building_slots.items():\n                if item_id:\n                    # Extract type from slot name (e.g., \"house_1\" -> \"house\")\n                    b_type = slot_name.rsplit('_', 1)[0]\n                    if b_type in placed_items:\n                        placed_items[b_type] += 1\n\n            # Get available items from inventory\n            for item_id in self.player.housing_owned:\n                item_data = self.housing_data.get(item_id, {})\n                item_type = item_data.get(\"type\", \"decoration\")\n                available_items[item_type].append({\n                    \"id\": item_id,\n                    \"data\": item_data\n                })\n\n            # Display building slots\n            menu_idx = 1\n            print(f\"{Colors.BOLD}Building Slots:{Colors.END}\\n\")\n\n            for b_type, info in building_types.items():\n                placed = placed_items.get(b_type, 0)\n                max_slots = info[\"slots\"]\n                status_color = Colors.GREEN if placed > 0 else Colors.DARK_GRAY\n\n                print(\n                    f\"{Colors.CYAN}{menu_idx}.{Colors.END} {Colors.BOLD}{info['label']}{Colors.END} [{status_color}{placed}/{max_slots}{Colors.END}]\"\n                )\n                menu_idx += 1\n\n            print(f\"\\n{Colors.CYAN}Q.{Colors.END} Quit\")\n            choice = ask(\n                f\"\\n{Colors.CYAN}Choose a building type to manage: {Colors.END}\"\n            ).strip().upper()\n\n            if choice == 'Q':\n                break\n\n            if choice.isdigit():\n                idx = int(choice) - 1\n                types_list = list(building_types.keys())\n                if 0 <= idx < len(types_list):\n                    self.manage_building_slots(\n                        types_list[idx], building_types[types_list[idx]],\n                        available_items[types_list[idx]])\n\n    def manage_building_slots(self, b_type: str, b_info: Dict,\n                              available_items: List[Dict]):\n        \"\"\"Manage slots for a specific building type\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        while True:\n            clear_screen()\n            print(\n                f\"\\n{Colors.BOLD}{Colors.CYAN}=== {b_info['label'].upper()} SLOTS ==={Colors.END}\"\n            )\n            print(\n                f\"{Colors.YELLOW}Manage your {b_info['label'].lower()} placements{Colors.END}\\n\"\n            )\n\n            max_slots = b_info[\"slots\"]\n\n            # Display all slots for this type\n            print(f\"{Colors.BOLD}Slots:{Colors.END}\")\n            slot_list = []\n            for i in range(1, max_slots + 1):\n                slot_name = f\"{b_type}_{i}\"\n                item_id = self.player.building_slots.get(slot_name)\n\n                if item_id:\n                    item_data = self.housing_data.get(item_id, {})\n                    item_name = item_data.get(\"name\", item_id)\n                    item_price = item_data.get(\"price\", 0)\n                    swap_cost = int(item_price * 0.1)\n                    print(\n                        f\"{Colors.CYAN}{i}.{Colors.END} [{Colors.GREEN}âœ“{Colors.END}] {Colors.BOLD}{Colors.YELLOW}{item_name}{Colors.END}\"\n                    )\n                    print(\n                        f\"   Swap cost: {Colors.GOLD}{swap_cost} gold{Colors.END} (10% of {item_price})\"\n                    )\n                else:\n                    print(\n                        f\"{Colors.CYAN}{i}.{Colors.END} [{Colors.DARK_GRAY}-{Colors.END}] {Colors.DARK_GRAY}Empty{Colors.END}\"\n                    )\n\n                slot_list.append(slot_name)\n\n            print(\n                f\"\\n{Colors.YELLOW}Available items in inventory: {len(available_items)}{Colors.END}\"\n            )\n\n            for idx, item in enumerate(available_items[:3],\n                                       1):  # Show first 3 available\n                item_name = item[\"data\"].get(\"name\", item[\"id\"])\n                item_comfort = item[\"data\"].get(\"comfort_points\", 0)\n                print(\n                    f\"  â€¢ {Colors.BOLD}{item_name}{Colors.END} (+{Colors.CYAN}{item_comfort}{Colors.END} comfort)\"\n                )\n\n            if len(available_items) > 3:\n                print(\n                    f\"  â€¢ {Colors.DARK_GRAY}... and {len(available_items) - 3} more items{Colors.END}\"\n                )\n\n            print(f\"\\n{Colors.CYAN}1-{max_slots}.{Colors.END} Manage slot\")\n            print(f\"{Colors.CYAN}B.{Colors.END} Back to land menu\")\n\n            choice = ask(\n                f\"\\n{Colors.CYAN}Choose action: {Colors.END}\").strip().upper()\n\n            if choice == 'B':\n                break\n            elif choice.isdigit():\n                slot_idx = int(choice) - 1\n                if 0 <= slot_idx < len(slot_list):\n                    self.manage_slot(slot_list[slot_idx], available_items)\n\n    def manage_slot(self, slot_name: str, available_items: List[Dict]):\n        \"\"\"Manage a specific building slot\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        current_item = self.player.building_slots.get(slot_name)\n\n        while True:\n            clear_screen()\n            print(\n                f\"\\n{Colors.BOLD}{Colors.CYAN}=== MANAGE {slot_name.upper()} ==={Colors.END}\"\n            )\n\n            if current_item:\n                current_data = self.housing_data.get(current_item, {})\n                current_name = current_data.get(\"name\", current_item)\n                current_price = current_data.get(\"price\", 0)\n                swap_cost = int(current_price * 0.1)\n\n                print(\n                    f\"{Colors.BOLD}Current item:{Colors.END} {Colors.YELLOW}{current_name}{Colors.END}\"\n                )\n                print(\n                    f\"Swap cost: {Colors.GOLD}{swap_cost} gold{Colors.END}\\n\")\n            else:\n                print(f\"{Colors.GRAY}Current item: Empty{Colors.END}\\n\")\n\n            print(f\"{Colors.BOLD}Available items to place:{Colors.END}\\n\")\n\n            for idx, item in enumerate(available_items, 1):\n                item_id = item[\"id\"]\n                item_data = item[\"data\"]\n                item_name = item_data.get(\"name\", item_id)\n                item_comfort = item_data.get(\"comfort_points\", 0)\n                item_price = item_data.get(\"price\", 0)\n                swap_cost = int(item_price * 0.1)\n\n                print(\n                    f\"{Colors.CYAN}{idx}.{Colors.END} {Colors.BOLD}{Colors.YELLOW}{item_name}{Colors.END}\"\n                )\n                print(\n                    f\"   Comfort: {Colors.CYAN}+{item_comfort}{Colors.END} | Swap cost: {Colors.GOLD}{swap_cost}g{Colors.END}\"\n                )\n\n            print(f\"\\n{Colors.CYAN}C.{Colors.END} Clear this slot\")\n            print(f\"{Colors.CYAN}B.{Colors.END} Back\")\n\n            choice = ask(\n                f\"\\n{Colors.CYAN}Select item to place or action: {Colors.END}\"\n            ).strip().upper()\n\n            if choice == 'B':\n                break\n            elif choice == 'C':\n                if current_item:\n                    self.player.building_slots[slot_name] = None\n                    print(f\"\\n{Colors.GREEN}âœ“ Slot cleared!{Colors.END}\")\n                    input(\"Press Enter to continue...\")\n                    break\n                else:\n                    print(\n                        f\"\\n{Colors.YELLOW}Slot is already empty.{Colors.END}\")\n                    input(\"Press Enter to continue...\")\n            elif choice.isdigit():\n                item_idx = int(choice) - 1\n                if 0 <= item_idx < len(available_items):\n                    selected_item = available_items[item_idx]\n\n                    # Calculate cost\n                    if current_item:\n                        current_price = self.housing_data.get(\n                            current_item, {}).get(\"price\", 0)\n                        swap_cost = int(current_price * 0.1)\n                    else:\n                        swap_cost = 0\n\n                    # Check if player can afford\n                    if self.player.gold >= swap_cost:\n                        if swap_cost > 0:\n                            self.player.gold -= swap_cost\n                            print(\n                                f\"\\n{Colors.GREEN}âœ“ Paid {Colors.GOLD}{swap_cost} gold{Colors.GREEN} to swap.{Colors.END}\"\n                            )\n\n                        old_item = current_item\n                        self.player.building_slots[slot_name] = selected_item[\n                            \"id\"]\n\n                        # Update comfort points\n                        if old_item:\n                            old_comfort = self.housing_data.get(\n                                old_item, {}).get(\"comfort_points\", 0)\n                            self.player.comfort_points -= old_comfort\n\n                        new_comfort = selected_item[\"data\"].get(\n                            \"comfort_points\", 0)\n                        self.player.comfort_points += new_comfort\n\n                        item_name = selected_item[\"data\"].get(\n                            \"name\", selected_item[\"id\"])\n                        print(\n                            f\"{Colors.GREEN}âœ“ Placed {Colors.BOLD}{item_name}{Colors.END}{Colors.GREEN} in {slot_name}!{Colors.END}\"\n                        )\n                        print(\n                            f\"Total comfort: {Colors.CYAN}{self.player.comfort_points}{Colors.END}\"\n                        )\n                        input(\"Press Enter to continue...\")\n                        break\n                    else:\n                        needed = swap_cost - self.player.gold\n                        print(\n                            f\"\\n{Colors.RED}âœ— Not enough gold! Need {needed} more.{Colors.END}\"\n                        )\n                        input(\"Press Enter to continue...\")\n\n    def farm(self):\n        \"\"\"Farm crops on your land\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        # Check if player has any farm buildings\n        has_farm = any(\n            self.player.building_slots.get(f\"farm_{i}\") is not None\n            for i in range(1, 3))\n\n        if not has_farm:\n            print(\n                f\"\\n{Colors.YELLOW}You need to build a farm first! Use the 'Build Structures' option.{Colors.END}\"\n            )\n            input(\"Press Enter to continue...\")\n            return\n\n        while True:\n            clear_screen()\n            print(f\"\\n{Colors.BOLD}{Colors.CYAN}=== FARMING ==={Colors.END}\")\n            print(\n                f\"{Colors.YELLOW}Tend to your crops and harvest your bounty{Colors.END}\\n\"\n            )\n\n            # Show available crops to plant\n            crops_data = self.farming_data.get(\"crops\", {})\n\n            print(f\"{Colors.BOLD}Available Crops to Plant:{Colors.END}\\n\")\n            crops_list = list(crops_data.items())\n            for idx, (crop_id, crop_data) in enumerate(crops_list, 1):\n                name = crop_data.get(\"name\", crop_id)\n                description = crop_data.get(\"description\", \"\")\n                growth_time = crop_data.get(\"growth_time\", 0)\n                harvest = crop_data.get(\"harvest_amount\", 0)\n                print(\n                    f\"{Colors.CYAN}{idx}.{Colors.END} {Colors.BOLD}{name}{Colors.END}\"\n                )\n                print(f\"   {description}\")\n                print(\n                    f\"   Growth: {Colors.YELLOW}{growth_time} days{Colors.END} | Harvest: {Colors.GREEN}+{harvest}{Colors.END}\\n\"\n                )\n\n            print(f\"{Colors.BOLD}Farm Status:{Colors.END}\\n\")\n\n            # Show farm plot status\n            for farm_idx in range(1, 3):\n                farm_slot = f\"farm_{farm_idx}\"\n                has_building = self.player.building_slots.get(\n                    farm_slot) is not None\n\n                if has_building:\n                    print(\n                        f\"{Colors.GOLD}Farm Plot {farm_idx}:{Colors.END} {Colors.GREEN}âœ“ Active{Colors.END}\"\n                    )\n                    plots = self.player.farm_plots.get(farm_slot, [])\n                    if plots:\n                        for plant_idx, plant in enumerate(plots, 1):\n                            crop_name = self.farming_data.get(\"crops\", {}).get(\n                                plant.get(\"crop\"),\n                                {}).get(\"name\", plant.get(\"crop\"))\n                            days_left = plant.get(\"days_left\", 0)\n                            if days_left > 0:\n                                print(\n                                    f\"  {plant_idx}. {crop_name} - {Colors.YELLOW}{days_left} days{Colors.END} until ready\"\n                                )\n                            else:\n                                print(\n                                    f\"  {plant_idx}. {crop_name} - {Colors.GREEN}Ready to harvest!{Colors.END}\"\n                                )\n                    else:\n                        print(\n                            f\"  {Colors.GRAY}Empty - Ready to plant{Colors.END}\"\n                        )\n                else:\n                    print(\n                        f\"Farm Plot {farm_idx}: {Colors.DARK_GRAY}Not built{Colors.END}\"\n                    )\n                print()\n\n            print(\n                f\"{Colors.CYAN}1-{len(crops_list)}.{Colors.END} Plant a crop\")\n            print(f\"{Colors.CYAN}H.{Colors.END} Harvest crops\")\n            print(f\"{Colors.CYAN}V.{Colors.END} View inventory\")\n            print(f\"{Colors.CYAN}B.{Colors.END} Back\")\n\n            choice = ask(\n                f\"\\n{Colors.CYAN}Choose action: {Colors.END}\").strip().upper()\n\n            if choice == 'B':\n                break\n            elif choice == 'H':\n                self.harvest_crops()\n            elif choice == 'V':\n                self.view_farming_inventory()\n            elif choice.isdigit():\n                crop_idx = int(choice) - 1\n                if 0 <= crop_idx < len(crops_list):\n                    self.plant_crop(crops_list[crop_idx])\n\n    def plant_crop(self, crop_tuple):\n        \"\"\"Plant a specific crop in an available farm plot\"\"\"\n        if not self.player:\n            return\n\n        crop_id, crop_data = crop_tuple\n        crop_name = crop_data.get(\"name\", crop_id)\n        growth_time = crop_data.get(\"growth_time\", 0)\n\n        # Select which farm to plant in\n        clear_screen()\n        print(\n            f\"\\n{Colors.BOLD}{Colors.CYAN}=== PLANT {crop_name.upper()} ==={Colors.END}\\n\"\n        )\n        print(\"Select which farm plot to use:\\n\")\n\n        farm_choices = []\n        for farm_idx in range(1, 3):\n            farm_slot = f\"farm_{farm_idx}\"\n            has_building = self.player.building_slots.get(\n                farm_slot) is not None\n\n            if has_building:\n                plots = self.player.farm_plots.get(farm_slot, [])\n                plant_count = len(plots)\n                max_plots = self.farming_data.get(\"max_plots_per_farm\", 3)\n\n                print(\n                    f\"{len(farm_choices) + 1}. Farm Plot {farm_idx} - {Colors.GREEN}{plant_count}/{max_plots} plants{Colors.END}\"\n                )\n                farm_choices.append(farm_slot)\n\n        if not farm_choices:\n            print(f\"{Colors.YELLOW}No active farms available!{Colors.END}\")\n            input(\"Press Enter to continue...\")\n            return\n\n        choice = ask(\n            f\"\\nChoose farm (1-{len(farm_choices)}) or press Enter to cancel: \"\n        ).strip()\n\n        if choice and choice.isdigit():\n            farm_choice_idx = int(choice) - 1\n            if 0 <= farm_choice_idx < len(farm_choices):\n                farm_slot = farm_choices[farm_choice_idx]\n\n                # Add plant to farm\n                if farm_slot not in self.player.farm_plots:\n                    self.player.farm_plots[farm_slot] = []\n\n                max_plots = self.farming_data.get(\"max_plots_per_farm\", 3)\n                if len(self.player.farm_plots[farm_slot]) < max_plots:\n                    self.player.farm_plots[farm_slot].append({\n                        \"crop\":\n                        crop_id,\n                        \"days_left\":\n                        growth_time\n                    })\n                    print(\n                        f\"\\n{Colors.GREEN}âœ“ Planted {crop_name} in {farm_slot}!{Colors.END}\"\n                    )\n                    print(\n                        f\"It will be ready to harvest in {Colors.YELLOW}{growth_time} days{Colors.END}\"\n                    )\n                else:\n                    print(\n                        f\"\\n{Colors.YELLOW}This farm plot is full! ({max_plots}/{max_plots} plants){Colors.END}\"\n                    )\n\n                input(\"Press Enter to continue...\")\n\n    def harvest_crops(self):\n        \"\"\"Harvest ready crops from farm plots\"\"\"\n        if not self.player:\n            return\n\n        clear_screen()\n        print(\n            f\"\\n{Colors.BOLD}{Colors.CYAN}=== HARVEST CROPS ==={Colors.END}\\n\")\n\n        harvested = False\n        for farm_idx in range(1, 3):\n            farm_slot = f\"farm_{farm_idx}\"\n            plots = self.player.farm_plots.get(farm_slot, [])\n\n            if not plots:\n                continue\n\n            crops_to_remove = []\n            for plant_idx, plant in enumerate(plots):\n                crop_id = plant.get(\"crop\")\n                days_left = plant.get(\"days_left\", 0)\n\n                if days_left <= 0:\n                    crop_data = self.farming_data.get(\"crops\",\n                                                      {}).get(crop_id, {})\n                    crop_name = crop_data.get(\"name\", crop_id)\n                    harvest_amount = crop_data.get(\"harvest_amount\", 1)\n\n                    # Add crops to inventory\n                    for _ in range(harvest_amount):\n                        self.player.inventory.append(crop_name)\n\n                    print(\n                        f\"{Colors.GREEN}âœ“ Harvested {Colors.BOLD}{harvest_amount}x {crop_name}{Colors.END}{Colors.GREEN} from {farm_slot}!{Colors.END}\"\n                    )\n                    crops_to_remove.append(plant_idx)\n                    harvested = True\n\n            # Remove harvested crops (in reverse to maintain indices)\n            for idx in reversed(crops_to_remove):\n                plots.pop(idx)\n\n        if not harvested:\n            print(\n                f\"{Colors.YELLOW}No crops are ready to harvest yet.{Colors.END}\"\n            )\n\n        input(\"Press Enter to continue...\")\n\n    def view_farming_inventory(self):\n        \"\"\"View crops in inventory\"\"\"\n        if not self.player:\n            return\n\n        clear_screen()\n        print(\n            f\"\\n{Colors.BOLD}{Colors.CYAN}=== FARMING INVENTORY ==={Colors.END}\\n\"\n        )\n\n        crops_data = self.farming_data.get(\"crops\", {})\n        crop_names = {\n            crop_data.get(\"name\"): crop_id\n            for crop_id, crop_data in crops_data.items()\n        }\n\n        # Count crops in inventory\n        crop_counts = {}\n        for item in self.player.inventory:\n            if item in crop_names:\n                crop_counts[item] = crop_counts.get(item, 0) + 1\n\n        if crop_counts:\n            print(f\"{Colors.BOLD}Crops in Inventory:{Colors.END}\\n\")\n            for crop_name, count in crop_counts.items():\n                crop_id = crop_names[crop_name]\n                crop_data = crops_data.get(crop_id, {})\n                sell_price = crop_data.get(\"sell_price\", 0)\n\n                print(\n                    f\"{Colors.GREEN}âœ“{Colors.END} {Colors.BOLD}{crop_name}{Colors.END} x{count}\"\n                )\n                print(\n                    f\"  Sell price: {Colors.GOLD}{sell_price}g{Colors.END} each | Total: {Colors.GOLD}{sell_price * count}g{Colors.END}\\n\"\n                )\n\n            print(f\"{Colors.CYAN}S.{Colors.END} Sell crops\")\n            print(f\"{Colors.CYAN}C.{Colors.END} Cook crops (alchemy)\")\n            print(f\"{Colors.CYAN}B.{Colors.END} Back\")\n\n            choice = ask(\n                f\"\\n{Colors.CYAN}Choose action: {Colors.END}\").strip().upper()\n\n            if choice == 'S':\n                self.sell_crops()\n            elif choice == 'C':\n                self.visit_alchemy()  # Reuse existing alchemy system\n        else:\n            print(\n                f\"{Colors.YELLOW}You have no crops in your inventory yet.{Colors.END}\"\n            )\n            input(\"Press Enter to continue...\")\n\n    def sell_crops(self):\n        \"\"\"Sell crops for gold\"\"\"\n        if not self.player:\n            return\n\n        clear_screen()\n        print(f\"\\n{Colors.BOLD}{Colors.CYAN}=== SELL CROPS ==={Colors.END}\\n\")\n\n        crops_data = self.farming_data.get(\"crops\", {})\n        crop_names = {\n            crop_data.get(\"name\"): crop_id\n            for crop_id, crop_data in crops_data.items()\n        }\n\n        # Count crops\n        crop_counts = {}\n        for item in self.player.inventory:\n            if item in crop_names:\n                crop_counts[item] = crop_counts.get(item, 0) + 1\n\n        total_gold = 0\n        for crop_name, count in crop_counts.items():\n            crop_id = crop_names[crop_name]\n            crop_data = crops_data.get(crop_id, {})\n            sell_price = crop_data.get(\"sell_price\", 0)\n            subtotal = sell_price * count\n            total_gold += subtotal\n\n            print(\n                f\"{crop_name} x{count}: {Colors.GOLD}{subtotal}g{Colors.END}\")\n\n            # Remove from inventory\n            for _ in range(count):\n                self.player.inventory.remove(crop_name)\n\n        self.player.gold += total_gold\n        print(\n            f\"\\n{Colors.GREEN}âœ“ Sold all crops for {Colors.GOLD}{total_gold} gold{Colors.END}{Colors.GREEN}!{Colors.END}\"\n        )\n        print(f\"Total gold: {Colors.GOLD}{self.player.gold}{Colors.END}\")\n        input(\"Press Enter to continue...\")\n\n    def training(self):\n        \"\"\"Training system for improving stats using training_place buildings\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        # Check if player has any training_place buildings\n        has_training_place = any(\n            self.player.building_slots.get(f\"training_place_{i}\") is not None\n            for i in range(1, 4))\n\n        if not has_training_place:\n            print(\n                f\"\\n{Colors.YELLOW}You need to build a Training Place first! Use the 'Build Structures' option.{Colors.END}\"\n            )\n            input(\"Press Enter to continue...\")\n            return\n\n        import random\n\n        # Calculate training effectiveness based on buildings\n        training_bonus = self._calculate_training_effectiveness()\n\n        while True:\n            clear_screen()\n            print(\n                f\"\\n{Colors.BOLD}{Colors.CYAN}=== TRAINING GROUND ==={Colors.END}\"\n            )\n            print(\n                f\"{Colors.YELLOW}Train to improve your stats! Each training session affects all your stats.{Colors.END}\\n\"\n            )\n\n            # Show training facility info\n            self._display_training_facilities()\n\n            print(f\"{Colors.BOLD}Current Stats:{Colors.END}\")\n            print(\n                f\"HP: {Colors.RED}{self.player.max_hp}{Colors.END} | MP: {Colors.BLUE}{self.player.max_mp}{Colors.END}\"\n            )\n            print(\n                f\"Attack: {Colors.RED}{self.player.attack}{Colors.END} | Defense: {Colors.GREEN}{self.player.defense}{Colors.END} | Speed: {Colors.YELLOW}{self.player.speed}{Colors.END}\\n\"\n            )\n\n            print(f\"{Colors.BOLD}Training Types:{Colors.END}\\n\")\n            print(f\"{Colors.CYAN}1.{Colors.END} Morning Training (1d4)\")\n            print(\n                f\"   {Colors.GREEN}4: +4%{Colors.END} | {Colors.YELLOW}3: +2%{Colors.END} | {Colors.RED}1-2: -1%{Colors.END}\"\n            )\n            print()\n            print(f\"{Colors.CYAN}2.{Colors.END} Calm Training (1d6)\")\n            print(\n                f\"   {Colors.GREEN}6: +13%{Colors.END} | {Colors.GREEN}5: +10%{Colors.END} | {Colors.YELLOW}4: +7%{Colors.END} | {Colors.YELLOW}3: +1%{Colors.END} | {Colors.RED}1-2: -3%{Colors.END}\"\n            )\n            print()\n            print(f\"{Colors.CYAN}3.{Colors.END} Normal Training (1d8)\")\n            print(\n                f\"   {Colors.GREEN}5-8: +10%{Colors.END} | {Colors.RED}1-3: -7%{Colors.END}\"\n            )\n            print()\n            print(f\"{Colors.CYAN}4.{Colors.END} Intense Training (1d20)\")\n            print(\n                f\"   {Colors.GREEN}16-20: +20%{Colors.END} | {Colors.GREEN}11-15: +15%{Colors.END} | {Colors.YELLOW}10: +10%{Colors.END} | {Colors.RED}5-9: -10%{Colors.END} | {Colors.RED}1-4: -20%{Colors.END}\"\n            )\n            print()\n            print(f\"{Colors.CYAN}B.{Colors.END} Back\")\n\n            choice = ask(f\"\\n{Colors.CYAN}Choose training type: {Colors.END}\"\n                         ).strip().upper()\n\n            if choice == 'B':\n                break\n\n            if choice in ['1', '2', '3', '4']:\n                training_types = {\n                    '1': ('Morning Training', 4, lambda roll: 4\n                          if roll == 4 else 2 if roll == 3 else -1),\n                    '2': ('Calm Training', 6, lambda roll: 13\n                          if roll == 6 else 10 if roll == 5 else 7\n                          if roll == 4 else 1 if roll == 3 else -3),\n                    '3': ('Normal Training', 8, lambda roll: 10\n                          if roll >= 4 else -7),\n                    '4': ('Intense Training', 20, lambda roll: 20\n                          if roll >= 16 else 15 if roll >= 11 else 10\n                          if roll == 10 else -10 if roll >= 5 else -20)\n                }\n\n                name, dice_sides, calc_bonus = training_types[choice]\n\n                # Roll the dice\n                roll = random.randint(1, dice_sides)\n                base_bonus_percent = calc_bonus(roll)\n\n                # Apply training facility bonus\n                final_bonus_percent = base_bonus_percent * training_bonus\n\n                print(\n                    f\"\\n{Colors.BOLD}{Colors.CYAN}=== {name.upper()} ==={Colors.END}\"\n                )\n                print(\n                    f\"You rolled a {Colors.YELLOW}{roll}{Colors.END} on a d{dice_sides}!\"\n                )\n\n                if training_bonus > 1.0:\n                    bonus_description = f\" (x{training_bonus:.1f} from facilities)\"\n                elif training_bonus < 1.0:\n                    bonus_description = f\" (x{training_bonus:.1f} from poor facilities)\"\n                else:\n                    bonus_description = \"\"\n\n                if final_bonus_percent > 0:\n                    print(\n                        f\"{Colors.GREEN}Success!{Colors.END} All stats increase by {Colors.GREEN}+{final_bonus_percent:.1f}%{Colors.END}{bonus_description}\"\n                    )\n                elif final_bonus_percent < 0:\n                    print(\n                        f\"{Colors.RED}Training failed!{Colors.END} All stats decrease by {Colors.RED}{abs(final_bonus_percent):.1f}%{Colors.END}{bonus_description}\"\n                    )\n                else:\n                    print(f\"{Colors.YELLOW}No change in stats.{Colors.END}\")\n\n                # Calculate stat changes\n                old_stats = {\n                    'max_hp': self.player.max_hp,\n                    'max_mp': self.player.max_mp,\n                    'attack': self.player.attack,\n                    'defense': self.player.defense,\n                    'speed': self.player.speed\n                }\n\n                # Apply percentage changes\n                if final_bonus_percent != 0:\n                    percent_multiplier = 1 + (final_bonus_percent / 100)\n\n                    self.player.max_hp = max(\n                        1, int(self.player.max_hp * percent_multiplier))\n                    self.player.max_mp = max(\n                        1, int(self.player.max_mp * percent_multiplier))\n                    self.player.attack = max(\n                        1, int(self.player.attack * percent_multiplier))\n                    self.player.defense = max(\n                        1, int(self.player.defense * percent_multiplier))\n                    self.player.speed = max(\n                        1, int(self.player.speed * percent_multiplier))\n\n                    # Ensure current HP/MP don't exceed new maxes\n                    self.player.hp = min(self.player.hp, self.player.max_hp)\n                    self.player.mp = min(self.player.mp, self.player.max_mp)\n\n                print(f\"\\n{Colors.BOLD}Stat Changes:{Colors.END}\")\n                print(\n                    f\"HP: {Colors.RED}{old_stats['max_hp']} â†’ {self.player.max_hp}{Colors.END}\"\n                )\n                print(\n                    f\"MP: {Colors.BLUE}{old_stats['max_mp']} â†’ {self.player.max_mp}{Colors.END}\"\n                )\n                print(\n                    f\"Attack: {Colors.RED}{old_stats['attack']} â†’ {self.player.attack}{Colors.END}\"\n                )\n                print(\n                    f\"Defense: {Colors.GREEN}{old_stats['defense']} â†’ {self.player.defense}{Colors.END}\"\n                )\n                print(\n                    f\"Speed: {Colors.YELLOW}{old_stats['speed']} â†’ {self.player.speed}{Colors.END}\"\n                )\n\n                input(\"\\nPress Enter to continue...\")\n            else:\n                print(f\"{Colors.RED}Invalid choice.{Colors.END}\")\n                time.sleep(1)\n\n    def _calculate_training_effectiveness(self) -> float:\n        \"\"\"Calculate training effectiveness multiplier based on training facilities\"\"\"\n        if not self.player:\n            return 1.0\n\n        total_comfort = 0\n        facility_count = 0\n        rarity_multipliers = {\n            'common': 1.0,\n            'uncommon': 1.2,\n            'rare': 1.4,\n            'epic': 1.6,\n            'legendary': 1.8\n        }\n\n        # Check all training_place slots\n        for i in range(1, 4):\n            slot = f\"training_place_{i}\"\n            building_id = self.player.building_slots.get(slot)\n\n            if building_id and building_id in self.housing_data:\n                building = self.housing_data[building_id]\n                comfort = building.get('comfort_points', 0)\n                rarity = building.get('rarity', 'common')\n\n                # Apply rarity multiplier to comfort points\n                rarity_mult = rarity_multipliers.get(rarity, 1.0)\n                effective_comfort = comfort * rarity_mult\n\n                total_comfort += effective_comfort\n                facility_count += 1\n\n        if facility_count == 0:\n            return 1.0\n\n        # Calculate average effective comfort\n        avg_comfort = total_comfort / facility_count\n\n        # Convert comfort to training multiplier\n        # Base multiplier of 1.0, +0.1 per 10 comfort points\n        base_multiplier = 1.0\n        comfort_bonus = avg_comfort / 10 * 0.1\n\n        return base_multiplier + comfort_bonus\n\n    def _display_training_facilities(self):\n        \"\"\"Display information about the player's training facilities\"\"\"\n        if not self.player:\n            return\n\n        print(f\"{Colors.BOLD}Training Facilities:{Colors.END}\")\n\n        facilities = []\n        for i in range(1, 4):\n            slot = f\"training_place_{i}\"\n            building_id = self.player.building_slots.get(slot)\n\n            if building_id and building_id in self.housing_data:\n                building = self.housing_data[building_id]\n                name = building.get('name', building_id)\n                rarity = building.get('rarity', 'common')\n                comfort = building.get('comfort_points', 0)\n\n                # Color code by rarity\n                rarity_colors = {\n                    'common': Colors.GRAY,\n                    'uncommon': Colors.GREEN,\n                    'rare': Colors.BLUE,\n                    'epic': Colors.MAGENTA,\n                    'legendary': Colors.GOLD\n                }\n\n                color = rarity_colors.get(rarity, Colors.WHITE)\n                facilities.append(\n                    f\"{color}{name} ({rarity}, {comfort} comfort){Colors.END}\")\n\n        if facilities:\n            for facility in facilities:\n                print(f\"  â€¢ {facility}\")\n\n            effectiveness = self._calculate_training_effectiveness()\n            if effectiveness > 1.0:\n                print(\n                    f\"  {Colors.GREEN}Training Effectiveness: x{effectiveness:.1f} (better facilities = better results){Colors.END}\"\n                )\n            elif effectiveness < 1.0:\n                print(\n                    f\"  {Colors.YELLOW}Training Effectiveness: x{effectiveness:.1f} (upgrade facilities for better results){Colors.END}\"\n                )\n            else:\n                print(\n                    f\"  {Colors.GRAY}Training Effectiveness: x{effectiveness:.1f}{Colors.END}\"\n                )\n        else:\n            print(f\"  {Colors.YELLOW}No training facilities built{Colors.END}\")\n\n        print()\n\n    def visit_tavern(self):\n        \"\"\"Visit the tavern to hire companions.\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        print(f\"\\n{Colors.BOLD}=== TAVERN ==={Colors.END}\")\n        print(\n            \"Welcome to The Rusty Tankard. Here you can hire companions to join your party.\"\n        )\n        print(f\"Your gold: {Colors.GOLD}{self.player.gold}{Colors.END}\")\n\n        companions = list(self.companions_data.items())\n        if not companions:\n            print(\"No companions are available at the moment.\")\n            return\n\n        page_size = 6\n        current_page = 0\n\n        while True:\n            start = current_page * page_size\n            end = start + page_size\n            page_items = companions[start:end]\n\n            print(\n                f\"\\n--- Page {current_page + 1} of {(len(companions) + page_size - 1) // page_size} ---\"\n            )\n            for i, (cid, cdata) in enumerate(page_items, 1):\n                price = cdata.get('price', '?')\n                desc = cdata.get('description', '')\n                print(\n                    f\"{i}. {cdata.get('name', cid)} - {Colors.GOLD}{price} gold{Colors.END}\"\n                )\n                print(f\"   {desc}\")\n\n            print(\"Shortcuts: N-next, P-prev, Enter-leave\")\n            choice = ask(\n                f\"\\nHire companion (1-{len(page_items)}) or press Enter to leave: \"\n            )\n\n            if not choice:\n                break\n            elif choice.lower() == 'n':\n                if end < len(companions):\n                    current_page += 1\n                else:\n                    print(\"No more pages.\")\n            elif choice.lower() == 'p':\n                if current_page > 0:\n                    current_page -= 1\n                else:\n                    print(\"Already on first page.\")\n            elif choice.isdigit():\n                idx = int(choice) - 1\n                if 0 <= idx < len(page_items):\n                    cid, cdata = page_items[idx]\n                    price = cdata.get('price', 0)\n                    if self.player.gold >= price:\n                        if len(self.player.companions) >= 4:\n                            print(\n                                \"You already have the maximum number of companions (4).\"\n                            )\n                            continue\n                        self.player.gold -= price\n                        # Create companion data with equipment and level\n                        companion_data = {\n                            \"id\": cid,\n                            \"name\": cdata.get('name', cid),\n                            \"level\": 1,\n                            \"equipment\": {\n                                \"weapon\": None,\n                                \"armor\": None,\n                                \"accessory\": None\n                            }\n                        }\n                        self.player.companions.append(companion_data)\n                        print(\n                            f\"Hired {cdata.get('name', cid)} for {price} gold!\"\n                        )\n                        # Recalculate stats with new companion bonus\n                        self.player.update_stats_from_equipment(\n                            self.items_data, self.companions_data)\n                    else:\n                        print(\"Not enough gold!\")\n                else:\n                    print(\"Invalid choice.\")\n\n    def visit_market(self):\n        \"\"\"Visit the Elite Market - browse and buy items from the API at 50% off\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        if not self.market_api:\n            print(\"Market API not available.\")\n            return\n\n        print(\n            f\"\\n{Colors.MAGENTA}{Colors.BOLD}=== ELITE MARKET ==={Colors.END}\")\n        print(\"Welcome to the Elite Market! All items sold at 50% OFF!\")\n        if self.player:\n            print(f\"\\nYour gold: {Colors.GOLD}{self.player.gold}{Colors.END}\")\n\n        # Check cooldown\n        remaining = self.market_api.get_cooldown_remaining()\n        if remaining and remaining.total_seconds() > 0:\n            mins = int(remaining.total_seconds() // 60)\n            secs = int(remaining.total_seconds() % 60)\n            print(\n                f\"\\n{Colors.YELLOW}Market cooldown: {mins}m {secs}s remaining{Colors.END}\"\n            )\n\n        # Fetch market data\n        market_data = self.market_api.fetch_market_data()\n        if not market_data or not market_data.get('ok'):\n            print(\n                f\"\\n{Colors.RED}{Colors.BOLD}Market is currently closed!{Colors.END}\"\n            )\n            print(\n                f\"{Colors.YELLOW}Merchants have travelled to another distant far place!{Colors.END}\"\n            )\n            print(\n                f\"{Colors.YELLOW}Please wait until the merchants arrive!{Colors.END}\"\n            )\n            return\n\n        items = self.market_api.get_all_items()\n        if not items:\n            print(\"No items available in the market.\")\n            return\n\n        # Get filter options from player\n        print(f\"\\n{Colors.CYAN}=== BROWSE ITEMS ==={Colors.END}\")\n        print(\"Filters available:\")\n        print(\"  1. All Items\")\n        print(\"  2. By Type (weapon, armor, consumable, etc.)\")\n        print(\"  3. By Rarity (common, uncommon, rare, legendary)\")\n        print(\"  4. By Class (Mage, Warrior, Rogue, etc.)\")\n        print(\"  5. By Max Price\")\n        print(\"  R. Refresh market (forces new fetch)\")\n\n        choice = ask(\"\\nChoose filter (1-5, R) or press Enter to browse all: \"\n                     ).strip().upper()\n\n        filtered_items = items\n\n        if choice == '1' or not choice:\n            pass  # All items\n        elif choice == '2':\n            print(\n                \"\\nItem types: weapon, armor, consumable, accessory, material, offhand\"\n            )\n            item_type = ask(\"Enter type: \").strip().lower()\n            filtered_items = self.market_api.filter_items(item_type=item_type)\n        elif choice == '3':\n            print(\"\\nRarities: common, uncommon, rare, legendary\")\n            rarity = ask(\"Enter rarity: \").strip().lower()\n            filtered_items = self.market_api.filter_items(rarity=rarity)\n        elif choice == '4':\n            print(\"\\nClasses: Warrior, Mage, Rogue, Hunter, Bard, etc.\")\n            class_req = ask(\"Enter class: \").strip()\n            filtered_items = self.market_api.filter_items(class_req=class_req)\n        elif choice == '5':\n            try:\n                max_price = int(ask(\"Enter max price: \").strip())\n                filtered_items = self.market_api.filter_items(\n                    max_price=max_price)\n            except ValueError:\n                print(\"Invalid price, showing all items.\")\n        elif choice == 'R':\n            filtered_items = self.market_api.get_all_items()\n            # Force refresh\n            self.market_api.fetch_market_data(force_refresh=True)\n            filtered_items = self.market_api.get_all_items()\n\n        if not filtered_items:\n            print(\"No items match your filters.\")\n            return\n\n        # Sort by market price by default\n        filtered_items = sorted(filtered_items,\n                                key=lambda x: x.get('marketPrice', 0))\n\n        # Paginate and display items\n        page_size = 8\n        current_page = 0\n\n        while True:\n            start = current_page * page_size\n            end = start + page_size\n            page_items = filtered_items[start:end]\n\n            if not page_items:\n                print(\"No more items.\")\n                break\n\n            print(\n                f\"\\n--- Page {current_page + 1} of {(len(filtered_items) + page_size - 1) // page_size} ---\"\n            )\n\n            for i, item in enumerate(page_items, 1):\n                name = item.get('name', 'Unknown')\n                item_type = item.get('type', 'unknown')\n                rarity = item.get('rarity', 'common')\n                original_price = item.get('originalPrice', 0)\n                market_price = item.get('marketPrice', 0)\n                desc = item.get('description',\n                                '')[:60]  # Truncate long descriptions\n                reqs = item.get('requirements')\n                class_req = reqs.get('class') if reqs else None\n                level_req = reqs.get('level', 1) if reqs else 1\n\n                # Color by rarity\n                rarity_color = get_rarity_color(rarity)\n                price_color = Colors.GREEN if market_price <= self.player.gold else Colors.RED\n\n                print(f\"\\n{i}. {rarity_color}{name}{Colors.END} ({item_type})\")\n                print(f\"   {Colors.DARK_GRAY}{desc}{Colors.END}\")\n                print(\n                    f\"   {rarity_color}{rarity.title()}{Colors.END} | Level {level_req}\"\n                    + (f\" | {Colors.CYAN}{class_req}{Colors.END}\"\n                       if class_req else \"\"))\n                print(\n                    f\"   {price_color}{market_price}{Colors.END} gold (was {original_price})\"\n                )\n\n            print(f\"\\n{Colors.YELLOW}Options:{Colors.END}\")\n            print(f\"1-{len(page_items)}. Buy Item\")\n            if len(filtered_items) > page_size:\n                print(\"N. Next Page\")\n                print(\"P. Previous Page\")\n            print(\"F. Filter Items\")\n            print(\"Enter. Return to Main Menu\")\n\n            choice = ask(\"\\nChoose action: \").strip().upper()\n\n            if not choice:\n                break\n            elif choice == 'N' and len(filtered_items) > page_size:\n                if end < len(filtered_items):\n                    current_page += 1\n            elif choice == 'P' and len(filtered_items) > page_size:\n                if current_page > 0:\n                    current_page -= 1\n            elif choice == 'F':\n                # Apply filter\n                print(\"\\nRefine search:\")\n                print(\"  1. By Type\")\n                print(\"  2. By Rarity\")\n                print(\"  3. By Class\")\n                print(\"  4. By Max Price\")\n                sub_choice = ask(\"Choose filter: \").strip()\n                if sub_choice == '1':\n                    item_type = ask(\"Enter type: \").strip().lower()\n                    filtered_items = [\n                        it for it in filtered_items\n                        if it.get('type', '').lower() == item_type\n                    ]\n                elif sub_choice == '2':\n                    rarity = ask(\"Enter rarity: \").strip().lower()\n                    filtered_items = [\n                        it for it in filtered_items\n                        if it.get('rarity', '').lower() == rarity\n                    ]\n                elif sub_choice == '3':\n                    class_req = ask(\"Enter class: \").strip()\n                    filtered_items = [\n                        it for it in filtered_items\n                        if (it.get('requirements') or {}\n                            ).get('class', '').lower() == class_req.lower()\n                    ]\n                elif sub_choice == '4':\n                    try:\n                        max_price = int(ask(\"Enter max price: \").strip())\n                        filtered_items = [\n                            it for it in filtered_items\n                            if it.get('marketPrice', 0) <= max_price\n                        ]\n                    except ValueError:\n                        pass\n                current_page = 0\n            elif choice.isdigit():\n                item_idx = int(choice) - 1\n                if 0 <= item_idx < len(page_items):\n                    item = page_items[item_idx]\n                    name = item.get('name', '')\n                    market_price = item.get('marketPrice', 0)\n\n                    if self.player.gold >= market_price:\n                        self.player.gold -= market_price\n                        self.player.inventory.append(name)\n                        print(\n                            f\"\\n{Colors.GREEN}Purchased {name} for {market_price} gold!{Colors.END}\"\n                        )\n                        self.update_mission_progress('collect', name)\n                    else:\n                        print(\n                            f\"\\n{Colors.RED}Not enough gold! Need {market_price}, have {self.player.gold}.{Colors.END}\"\n                        )\n                else:\n                    print(\"Invalid selection.\")\n\n    def manage_companions(self):\n        \"\"\"Manage hired companions.\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        while True:\n            print(f\"\\n{Colors.BOLD}=== COMPANIONS ==={Colors.END}\")\n            print(f\"Active companions: {len(self.player.companions)}/4\")\n\n            if not self.player.companions:\n                print(\n                    \"You have no companions yet. Visit the tavern to hire some!\"\n                )\n                return\n\n            # Display active companions\n            for i, companion in enumerate(self.player.companions, 1):\n                if isinstance(companion, dict):\n                    comp_name = companion.get('name')\n                    comp_level = companion.get('level', 1)\n                else:\n                    comp_name = companion\n                    comp_level = 1\n\n                # Find companion data to show bonuses\n                comp_data = None\n                for cid, cdata in self.companions_data.items():\n                    if cdata.get('name') == comp_name:\n                        comp_data = cdata\n                        break\n\n                print(\n                    f\"\\n{i}. {Colors.CYAN}{comp_name}{Colors.END} (Level {comp_level})\"\n                )\n                if comp_data:\n                    bonuses = []\n                    if comp_data.get('attack_bonus'):\n                        bonuses.append(f\"+{comp_data.get('attack_bonus')} ATK\")\n                    if comp_data.get('defense_bonus'):\n                        bonuses.append(\n                            f\"+{comp_data.get('defense_bonus')} DEF\")\n                    if comp_data.get('speed_bonus'):\n                        bonuses.append(f\"+{comp_data.get('speed_bonus')} SPD\")\n                    if comp_data.get('healing_bonus'):\n                        bonuses.append(\n                            f\"+{comp_data.get('healing_bonus')} Healing\")\n                    if comp_data.get('mp_bonus'):\n                        bonuses.append(f\"+{comp_data.get('mp_bonus')} MP\")\n\n                    if bonuses:\n                        print(f\"   Bonuses: {', '.join(bonuses)}\")\n                    print(f\"   {comp_data.get('description', '')}\")\n\n            print(\"\\nOptions:\")\n            print(\"D - Dismiss a companion\")\n            print(\"E - Equip item on companion\")\n            print(\"Enter - Return to main menu\")\n\n            choice = ask(\"Choose action: \").strip().lower()\n\n            if not choice:\n                break\n            elif choice == 'd':\n                # Dismiss companion\n                if self.player.companions:\n                    try:\n                        idx = int(\n                            ask(f\"Dismiss which companion (1-{len(self.player.companions)})? \"\n                                )) - 1\n                        if 0 <= idx < len(self.player.companions):\n                            dismissed = self.player.companions.pop(idx)\n                            if isinstance(dismissed, dict):\n                                print(\n                                    f\"{Colors.RED}Dismissed {dismissed.get('name')}.{Colors.END}\"\n                                )\n                            else:\n                                print(\n                                    f\"{Colors.RED}Dismissed {dismissed}.{Colors.END}\"\n                                )\n                            # Recalculate stats after dismissal\n                            self.player.update_stats_from_equipment(\n                                self.items_data, self.companions_data)\n                        else:\n                            print(\"Invalid selection.\")\n                    except ValueError:\n                        print(\"Invalid input.\")\n            elif choice == 'e':\n                # Equip item on companion\n                print(\"Companion equipment feature coming soon!\")\n                # TODO: Implement companion equipment\n            else:\n                print(\"Invalid choice.\")\n\n    def travel(self):\n        \"\"\"Travel to connected areas from the current area.\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        current = self.current_area\n        area_data = self.areas_data.get(current, {})\n        connections = area_data.get(\"connections\", [])\n\n        print(f\"\\n{Colors.BOLD}=== TRAVEL ==={Colors.END}\")\n        print(f\"Current location: {area_data.get('name', current)}\")\n        if not connections:\n            print(\"No connected areas to travel to.\")\n            return\n\n        print(\"Connected areas:\")\n        for i, aid in enumerate(connections, 1):\n            a = self.areas_data.get(aid, {})\n            print(f\"{i}. {a.get('name', aid)} - {a.get('description','')}\")\n\n        choice = ask(\n            f\"Travel to (1-{len(connections)}) or press Enter to cancel: \")\n        if choice and choice.isdigit():\n            idx = int(choice) - 1\n            if 0 <= idx < len(connections):\n                new_area = connections[idx]\n                self.current_area = new_area\n                print(\n                    f\"Traveling to {self.areas_data.get(new_area, {}).get('name', new_area)}...\"\n                )\n\n                # Check for area cutscene\n                area_data = self.areas_data.get(new_area, {})\n                cutscene_id = area_data.get('first_time_enter_cutscene')\n                if cutscene_id and cutscene_id in self.cutscenes_data:\n                    cutscene = self.cutscenes_data[cutscene_id]\n                    is_iterable = cutscene.get('iterable', False)\n                    if is_iterable or new_area not in self.visited_areas:\n                        self.play_cutscene(cutscene_id)\n                        if not is_iterable:\n                            self.visited_areas.add(new_area)\n\n                # small chance encounter on travel\n                if random.random() < 0.3:\n                    self.random_encounter()\n\n    def shop_sell(self):\n        \"\"\"Sell items from the player's inventory to the shop.\"\"\"\n        if not self.player:\n            return\n\n        sellable = [it for it in self.player.inventory]\n        if not sellable:\n            print(\"You have nothing to sell.\")\n            return\n\n        print(\"\\nYour inventory:\")\n        for i, item in enumerate(sellable, 1):\n            equip_marker = ''\n            for slot, eq in self.player.equipment.items():\n                if eq == item:\n                    equip_marker = ' (equipped)'\n            price = self.items_data.get(item, {}).get('price', 0)\n            sell_price = price // 2 if price else 0\n            print(f\"{i}. {item}{equip_marker} - Sell for {sell_price} gold\")\n\n        choice = ask(\n            f\"Choose item to sell (1-{len(sellable)}) or press Enter to cancel: \"\n        )\n        if not choice or not choice.isdigit():\n            return\n        idx = int(choice) - 1\n        if not (0 <= idx < len(sellable)):\n            print(\"Invalid selection.\")\n            return\n\n        item = sellable[idx]\n        # Prevent selling equipped items\n        if item in self.player.equipment.values():\n            print(\"Unequip the item before selling it.\")\n            return\n\n        price = self.items_data.get(item, {}).get('price', 0)\n        sell_price = price // 2 if price else 0\n        self.player.inventory.remove(item)\n        self.player.gold += sell_price\n        print(f\"Sold {item} for {sell_price} gold.\")\n\n    def rest(self):\n        \"\"\"Rest in a safe area to recover HP and MP for gold.\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        area_data = self.areas_data.get(self.current_area, {})\n        area_name = area_data.get(\"name\", \"Unknown Area\")\n        can_rest = area_data.get(\"can_rest\", False)\n        rest_cost = area_data.get(\"rest_cost\", 0)\n\n        if not can_rest:\n            print(\n                f\"\\n{Colors.RED}You cannot rest in {area_name}. It's too dangerous!{Colors.END}\"\n            )\n            return\n\n        print(\n            f\"\\n{Colors.CYAN}=== REST IN {area_name.upper()} ==={Colors.END}\")\n        print(f\"Rest Cost: {Colors.GOLD}{rest_cost} gold{Colors.END}\")\n        print(\n            f\"Current HP: {Colors.RED}{self.player.hp}/{self.player.max_hp}{Colors.END}\"\n        )\n        print(\n            f\"Current MP: {Colors.BLUE}{self.player.mp}/{self.player.max_mp}{Colors.END}\"\n        )\n\n        if self.player.gold < rest_cost:\n            print(\n                f\"\\n{Colors.RED}You don't have enough gold to rest! Need {rest_cost}, have {self.player.gold}.{Colors.END}\"\n            )\n            return\n\n        choice = ask(f\"Rest for {rest_cost} gold? (y/n): \")\n        if choice.lower() != 'y':\n            print(\"You decide not to rest.\")\n            return\n\n        # Deduct gold and restore HP/MP\n        self.player.gold -= rest_cost\n        old_hp = self.player.hp\n        old_mp = self.player.mp\n        self.player.hp = self.player.max_hp\n        self.player.mp = self.player.max_mp\n\n        print(\n            f\"\\n{Colors.GREEN}You rest and recover your strength...{Colors.END}\"\n        )\n        print(\n            f\"HP restored: {old_hp} â†’ {Colors.GREEN}{self.player.hp}{Colors.END}\"\n        )\n        print(\n            f\"MP restored: {old_mp} â†’ {Colors.GREEN}{self.player.mp}{Colors.END}\"\n        )\n        print(f\"Gold remaining: {Colors.GOLD}{self.player.gold}{Colors.END}\")\n\n    def save_game(self, filename_prefix: str = \"\"):\n        \"\"\"Save the game with an optional filename prefix (keeps backward compatible signature).\n\n        If `filename_prefix` is provided it will be prepended to the filename\n        (useful for error/unstable saves like 'err_save_unstable_').\n        \"\"\"\n        if not self.player:\n            print(\"No character to save.\")\n            return\n\n        save_data = {\n            \"player\": {\n                \"name\":\n                self.player.name,\n                \"uuid\":\n                self.player.uuid,\n                \"character_class\":\n                self.player.character_class,\n                \"level\":\n                self.player.level,\n                \"experience\":\n                self.player.experience,\n                \"experience_to_next\":\n                self.player.experience_to_next,\n                \"max_hp\":\n                self.player.max_hp,\n                \"hp\":\n                self.player.hp,\n                \"max_mp\":\n                self.player.max_mp,\n                \"mp\":\n                self.player.mp,\n                \"attack\":\n                self.player.attack,\n                \"defense\":\n                self.player.defense,\n                \"speed\":\n                self.player.speed,\n                \"inventory\":\n                self.player.inventory,\n                \"gold\":\n                self.player.gold,\n                \"equipment\":\n                self.player.equipment,\n                \"companions\":\n                self.player.companions,\n                \"base_stats\": {\n                    \"base_max_hp\": self.player.base_max_hp,\n                    \"base_max_mp\": self.player.base_max_mp,\n                    \"base_attack\": self.player.base_attack,\n                    \"base_defense\": self.player.base_defense,\n                    \"base_speed\": self.player.base_speed\n                },\n                \"class_data\":\n                self.player.class_data,\n                \"rank\":\n                self.player.rank,\n                \"active_buffs\":\n                self.player.active_buffs,\n                \"housing_owned\":\n                self.player.housing_owned\n                if hasattr(self.player, 'housing_owned') else [],\n                \"comfort_points\":\n                self.player.comfort_points\n                if hasattr(self.player, 'comfort_points') else 0,\n                \"building_slots\":\n                self.player.building_slots\n                if hasattr(self.player, 'building_slots') else {},\n                \"farm_plots\":\n                self.player.farm_plots\n                if hasattr(self.player, 'farm_plots') else {}\n            },\n            \"current_area\": self.current_area,\n            \"visited_areas\": list(self.visited_areas),\n            \"mission_progress\": self.mission_progress,\n            \"completed_missions\": self.completed_missions,\n            \"save_version\": \"3.0\",\n            \"save_time\": datetime.now().isoformat(),\n            \"bosses_killed\": self.player.bosses_killed if self.player else {}\n        }\n\n        saves_dir = \"data/saves\"\n        os.makedirs(saves_dir, exist_ok=True)\n\n        safe_prefix = filename_prefix or \"\"\n        # sanitize prefix to avoid accidental path chars\n        safe_prefix = safe_prefix.replace('/', '_')\n\n        # Check if overwrite by UUID is enabled\n        overwrite_by_uuid = self.mod_manager.settings.get(\n            \"overwrite_save_by_uuid\", False)\n        if overwrite_by_uuid and not filename_prefix:\n            # Find existing save file with same UUID\n            existing_save = None\n            for f in os.listdir(saves_dir):\n                if f.endswith(\n                        '.json'\n                ) and f\"{self.player.uuid[:8]}\" in f and not f.startswith(\n                        'err_save'):\n                    existing_save = f\n                    break\n\n            if existing_save:\n                filename = os.path.join(saves_dir, existing_save)\n            else:\n                # No existing save found, create new one with timestamp\n                timestamp = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n                filename = f\"{saves_dir}/{safe_prefix}{self.player.name}_{self.player.uuid[:8]}_save_{timestamp}_{self.player.character_class}_{self.player.level}.json\"\n        else:\n            # Default behavior: create new save with timestamp\n            timestamp = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n            filename = f\"{saves_dir}/{safe_prefix}{self.player.name}_{self.player.uuid[:8]}_save_{timestamp}_{self.player.character_class}_{self.player.level}.json\"\n\n        with open(filename, 'w') as f:\n            json.dump(save_data, f, indent=2)\n\n        print(f\"Game saved successfully: {filename}\")\n\n    def load_game(self):\n        \"\"\"Load a saved game with enhanced equipment handling and backward compatibility\"\"\"\n        saves_dir = \"data/saves\"\n        if not os.path.exists(saves_dir):\n            print(\"No save files found.\")\n            return\n\n        save_files = [f for f in os.listdir(saves_dir) if f.endswith('.json')]\n        if not save_files:\n            print(\"No save files found.\")\n            return\n\n        print(\"Available save files:\")\n        for i, save_file in enumerate(save_files, 1):\n            character_name = save_file.replace('_save.json', '')\n            print(f\"{i}. {character_name}\")\n\n        choice = ask(\n            f\"Load save (1-{len(save_files)}) or press Enter to cancel: \")\n        if choice and choice.isdigit():\n            save_index = int(choice) - 1\n            if 0 <= save_index < len(save_files):\n                save_file = save_files[save_index]\n                filename = os.path.join(str(saves_dir), save_file)\n\n                try:\n                    with open(filename, 'r') as f:\n                        save_data = json.load(f)\n\n                    # Check save version for compatibility\n                    save_version = save_data.get(\"save_version\", \"1.0\")\n\n                    # Recreate player\n                    player_data = save_data[\"player\"]\n                    player_uuid = player_data.get(\"uuid\")\n                    self.player = Character(player_data[\"name\"],\n                                            player_data[\"character_class\"],\n                                            self.classes_data,\n                                            player_uuid=player_uuid)\n\n                    # Restore stats\n                    self.player.level = player_data[\"level\"]\n                    self.player.experience = player_data[\"experience\"]\n                    self.player.experience_to_next = player_data[\n                        \"experience_to_next\"]\n                    self.player.max_hp = player_data[\"max_hp\"]\n                    self.player.hp = player_data[\"hp\"]\n                    self.player.max_mp = player_data[\"max_mp\"]\n                    self.player.mp = player_data[\"mp\"]\n                    self.player.attack = player_data[\"attack\"]\n                    self.player.defense = player_data[\"defense\"]\n                    self.player.speed = player_data[\"speed\"]\n                    self.player.inventory = player_data[\"inventory\"]\n                    self.player.gold = player_data[\"gold\"]\n                    # Restore rank and active buffs if present\n                    self.player.rank = player_data.get(\"rank\",\n                                                       self.player.rank)\n                    self.player.active_buffs = player_data.get(\n                        \"active_buffs\", self.player.active_buffs)\n\n                    # NEW: Load companions with backward compatibility\n                    self.player.companions = player_data.get(\"companions\", [])\n\n                    # NEW: Load housing data with backward compatibility\n                    self.player.housing_owned = player_data.get(\n                        \"housing_owned\", [])\n                    self.player.comfort_points = player_data.get(\n                        \"comfort_points\", 0)\n                    self.player.building_slots = player_data.get(\n                        \"building_slots\", {})\n                    self.player.farm_plots = player_data.get(\n                        \"farm_plots\", {\n                            \"farm_1\": [],\n                            \"farm_2\": []\n                        })\n\n                    # NEW: Enhanced equipment loading with validation\n                    self._load_equipment_data(player_data, save_version)\n\n                    self.current_area = save_data[\"current_area\"]\n                    self.visited_areas = set(save_data.get(\n                        \"visited_areas\", []))\n\n                    # Mission system load with backward compatibility\n                    self.mission_progress = save_data.get(\n                        \"mission_progress\", {})\n                    self.completed_missions = save_data.get(\n                        \"completed_missions\", [])\n\n                    # Load boss kill cooldowns\n                    if self.player:\n                        self.player.bosses_killed = save_data.get(\n                            \"bosses_killed\", {})\n\n                    # Backward compatibility for old saves using current_missions\n                    if not self.mission_progress and \"current_missions\" in save_data:\n                        for mid in save_data[\"current_missions\"]:\n                            mission = self.missions_data.get(mid)\n                            if mission:\n                                mission_type = mission.get('type', 'kill')\n                                target_count = mission.get('target_count', 1)\n                                if mission_type == 'collect' and isinstance(\n                                        target_count, dict):\n                                    self.mission_progress[mid] = {\n                                        'current_counts': {\n                                            item: 0\n                                            for item in target_count.keys()\n                                        },\n                                        'target_counts': target_count,\n                                        'completed': False,\n                                        'type': mission_type\n                                    }\n                                else:\n                                    self.mission_progress[mid] = {\n                                        'current_count': 0,\n                                        'target_count': target_count,\n                                        'completed': False,\n                                        'type': mission_type\n                                    }\n\n                    # Recalculate stats with equipment and companions\n                    if self.player:\n                        # Ensure rank matches loaded level\n                        try:\n                            self.player._update_rank()\n                        except Exception:\n                            pass\n                        self.player.update_stats_from_equipment(\n                            self.items_data, self.companions_data)\n                        print(\n                            f\"Game loaded successfully! Welcome back, {self.player.name}!\"\n                        )\n                        self.player.display_stats()\n\n                except Exception as e:\n                    print(f\"Error loading save file: {e}\")\n\n    def _load_equipment_data(self, player_data: Dict, save_version: str):\n        \"\"\"Load and validate equipment data with backward compatibility\"\"\"\n        if not self.player:\n            return\n\n        # NEW: Handle enhanced save format (v2.0+)\n        if save_version >= \"2.0\":\n            # Load equipment if present\n            equipment: Dict[str, Optional[str]] = player_data.get(\n                \"equipment\", {\n                    \"weapon\": None,\n                    \"armor\": None,\n                    \"accessory\": None\n                })\n            self.player.equipment = equipment\n\n            # Load base stats if present for equipment recalculation\n            base_stats = player_data.get(\"base_stats\", {})\n            if base_stats:\n                self.player.base_max_hp = base_stats.get(\n                    \"base_max_hp\", self.player.base_max_hp)\n                self.player.base_max_mp = base_stats.get(\n                    \"base_max_mp\", self.player.base_max_mp)\n                self.player.base_attack = base_stats.get(\n                    \"base_attack\", self.player.base_attack)\n                self.player.base_defense = base_stats.get(\n                    \"base_defense\", self.player.base_defense)\n                self.player.base_speed = base_stats.get(\n                    \"base_speed\", self.player.base_speed)\n\n            # Load class data if present\n            class_data = player_data.get(\"class_data\", {})\n            if class_data:\n                self.player.class_data = class_data\n                self.player.level_up_bonuses = class_data.get(\n                    \"level_up_bonuses\", {})\n\n            # Validate equipped items exist and meet requirements\n            self._validate_and_fix_equipment()\n\n            # Recalculate stats from equipment\n            self.player.update_stats_from_equipment(self.items_data)\n\n        else:\n            # OLD: Backward compatibility for v1.0 saves\n            print(\n                f\"{Colors.YELLOW}Loading legacy save (v{save_version}). Equipment may not be restored.{Colors.END}\"\n            )\n\n            # Try to find equipment in inventory for old saves\n            equipment: Dict[str, Optional[str]] = {\n                \"weapon\": None,\n                \"armor\": None,\n                \"accessory\": None\n            }\n\n            # Heuristic: look for likely equipped items in inventory\n            for item in player_data.get(\"inventory\", []):\n                item_data = self.items_data.get(item, {})\n                item_type = item_data.get(\"type\")\n\n                if item_type == \"weapon\" and not equipment[\"weapon\"]:\n                    equipment[\"weapon\"] = item\n                elif item_type == \"armor\" and not equipment[\"armor\"]:\n                    equipment[\"armor\"] = item\n                elif item_type == \"accessory\" and not equipment[\"accessory\"]:\n                    equipment[\"accessory\"] = item\n\n            self.player.equipment = equipment\n            self._validate_and_fix_equipment()\n            self.player.update_stats_from_equipment(self.items_data)\n\n    def _validate_and_fix_equipment(self):\n        \"\"\"Validate equipped items and auto-unequip invalid ones\"\"\"\n        if not self.player:\n            return\n\n        invalid_items = []\n\n        for slot in (\"weapon\", \"armor\", \"accessory\"):\n            item_name = self.player.equipment.get(slot)\n            if not item_name:\n                continue\n\n            # Check if item still exists in game data\n            if item_name not in self.items_data:\n                invalid_items.append(\n                    (slot, item_name, \"Item no longer exists\"))\n                self.player.equipment[slot] = None\n                continue\n\n            item_data = self.items_data[item_name]\n\n            # Check if item type matches slot\n            if item_data.get(\"type\") != slot:\n                invalid_items.append((slot, item_name, \"Item type mismatch\"))\n                self.player.equipment[slot] = None\n                continue\n\n            # Check requirements\n            requirements = item_data.get(\"requirements\", {})\n            if requirements:\n                level_req = requirements.get(\"level\", 0)\n                class_req = requirements.get(\"class\")\n\n                if self.player.level < level_req:\n                    invalid_items.append(\n                        (slot, item_name, f\"Level {level_req} required\"))\n                    self.player.equipment[slot] = None\n                    continue\n\n                if class_req and class_req != self.player.character_class:\n                    invalid_items.append(\n                        (slot, item_name, f\"{class_req} class required\"))\n                    self.player.equipment[slot] = None\n                    continue\n\n        # Report any items that were auto-unequipped\n        if invalid_items:\n            print(\n                f\"\\n{Colors.YELLOW}Some equipped items were invalid and have been unequipped:{Colors.END}\"\n            )\n            for slot, item_name, reason in invalid_items:\n                print(f\"  - {slot.title()}: {item_name} ({reason})\")\n            print(\n                f\"{Colors.YELLOW}Please check your inventory and re-equip valid items.{Colors.END}\"\n            )\n\n    def save_on_error(self,\n                      exc_info=None,\n                      filename_prefix: str = \"err_save_unstable_\"):\n        \"\"\"Attempt to save the current game state and write a traceback log when an error occurs.\n\n        This is intended for use in exception and signal handlers. It will try to save the\n        current player state with a filename prefixed by `filename_prefix` and also write a\n        `.log` file containing the traceback.\n        \"\"\"\n        try:\n            # Build a safe player name for filenames\n            pname = (self.player.name if self.player\n                     and getattr(self.player, 'name', None) else 'unknown')\n            # Try to save using the standard save function with prefix\n            try:\n                self.save_game(filename_prefix=filename_prefix)\n            except Exception as se:\n                print(f\"Error while saving game on error: {se}\")\n\n            # Write traceback log\n            try:\n                saves_dir = \"data/saves\"\n                os.makedirs(saves_dir, exist_ok=True)\n                ts = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n                safe_prefix = (filename_prefix or '').replace('/', '_')\n                logname = f\"{saves_dir}/{safe_prefix}{pname}_error_{ts}.log\"\n                if exc_info is None:\n                    exc_info = sys.exc_info()\n                # exc_info may be a tuple (etype, value, tb) or an exception instance\n                # Ensure exc_info is a 3-tuple (etype, value, tb)\n                if not (isinstance(exc_info, tuple) and len(exc_info) == 3):\n                    exc_info = sys.exc_info()\n\n                et, ev, tbobj = exc_info\n                buf = io.StringIO()\n                traceback.print_exception(et, ev, tbobj, file=buf)\n                tb = buf.getvalue()\n                with open(logname, 'w') as lf:\n                    lf.write(tb)\n                print(f\"Error traceback written to: {logname}\")\n            except Exception as le:\n                print(f\"Failed to write error log: {le}\")\n        except Exception as e:\n            print(f\"Unexpected failure during save_on_error: {e}\")\n\n    def quit_game(self):\n        \"\"\"Quit the game\"\"\"\n        print(\"\\nHave you saved your progress? (yes/no) (CASE SENSITIVE!!!)\")\n        response = input(\">>> \").strip().lower()\n        if response == \"no\":\n            clear_screen()\n            print(\"Saving your progress...\")\n            self.save_game()\n            print(\"Progress saved!\")\n        print(\"Thank you for playing Our Legacy!\")\n        print(\"Your legacy will be remembered...\")\n        sys.exit(0)\n\n    def _gather_materials(self):\n        \"\"\"Gather materials based on current area's difficulty and theme.\"\"\"\n        if not self.player:\n            return\n\n        area_data = self.areas_data.get(self.current_area, {})\n        difficulty = area_data.get('difficulty', 1)\n\n        # Define material pools by difficulty tier\n        # Tier 1: Basic materials (difficulty 1-2)\n        tier1_materials = [\n            \"Herb\", \"Spring Water\", \"Leather\", \"Leather Strip\", \"Hardwood\",\n            \"Stone Block\", \"Coal\", \"Iron Ore\", \"Goblin Ear\", \"Wolf Fang\",\n            \"Bone Fragment\"\n        ]\n\n        # Tier 2: Uncommon materials (difficulty 3)\n        tier2_materials = [\n            \"Mana Herb\", \"Gold Nugget\", \"Steel Ingot\", \"Orc Tooth\",\n            \"Serpent Tail\", \"Crystal Shard\", \"Venom Sac\", \"Swamp Scale\",\n            \"Ancient Relic\", \"Wind Elemental Essence\", \"Demon Blood\"\n        ]\n\n        # Tier 3: Rare materials (difficulty 4)\n        tier3_materials = [\n            \"Dark Crystal\", \"Ice Crystal\", \"Void Crystal\", \"Shadow Essence\",\n            \"Fire Essence\", \"Ice Essence\", \"Starlight Shard\",\n            \"Eternal Essence\", \"Poison Crystal\", \"Lightning Crystal\"\n        ]\n\n        # Tier 4: Legendary materials (difficulty 5-6)\n        tier4_materials = [\n            \"Dragon Scale\", \"Dragon Bone\", \"Phoenix Feather\", \"Fire Gem\",\n            \"Soul Fragment\", \"Demon Heart\", \"Golem Core\",\n            \"Storm Elemental Core\", \"Zephyr's Scale\", \"Wind Dragon's Heart\",\n            \"Eternal Feather\", \"Dragon Heart\", \"Void Heart\"\n        ]\n\n        # Select materials based on difficulty\n        available_materials = []\n        if difficulty <= 2:\n            available_materials = tier1_materials.copy()\n            if random.random() < 0.3:  # 30% chance for tier 2\n                available_materials.extend(tier2_materials)\n        elif difficulty == 3:\n            available_materials = tier1_materials + tier2_materials\n            if random.random() < 0.4:  # 40% chance for tier 3\n                available_materials.extend(tier3_materials)\n        elif difficulty == 4:\n            available_materials = tier2_materials + tier3_materials\n            if random.random() < 0.3:  # 30% chance for tier 4\n                available_materials.extend(tier4_materials)\n        else:  # difficulty 5-6\n            available_materials = tier3_materials + tier4_materials\n            if random.random() < 0.2:  # 20% chance for tier 2\n                available_materials.extend(tier2_materials)\n\n        # Filter to only materials that actually exist in items_data\n        valid_materials = [\n            m for m in available_materials if m in self.items_data\n        ]\n\n        if not valid_materials:\n            return\n\n        # Gather 1-3 random materials\n        num_materials = random.randint(1, 3)\n        gathered = {}\n\n        for _ in range(num_materials):\n            material = random.choice(valid_materials)\n            quantity = random.randint(1, 3)\n            gathered[material] = gathered.get(material, 0) + quantity\n\n        # Add gathered materials to inventory\n        found_text = []\n        for material, qty in gathered.items():\n            for _ in range(qty):\n                self.player.inventory.append(material)\n\n            # Get material info for display\n            item_data = self.items_data.get(material, {})\n            rarity = item_data.get('rarity', 'common')\n            color = get_rarity_color(rarity)\n            found_text.append(f\"{color}{qty}x {material}{Colors.END}\")\n\n        # Display gathered materials\n        print(f\"\\n{Colors.YELLOW}You found materials:{Colors.END}\")\n        for text in found_text:\n            print(f\"  - {text}\")\n\n        # Update mission progress for collected materials\n        for material in gathered.keys():\n            self.update_mission_progress('collect', material)\n\n    def visit_dungeons(self):\n        \"\"\"Visit the dungeon menu to select and enter dungeons\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        print(f\"\\n{Colors.BOLD}=== DUNGEONS ==={Colors.END}\")\n        print(\"Welcome to the Dungeon Portal! Choose your challenge:\")\n\n        # Check if player is in a dungeon\n        if self.current_dungeon:\n            print(\n                f\"\\n{Colors.YELLOW}You are currently in: {self.current_dungeon['name']}{Colors.END}\"\n            )\n            print(\n                f\"Progress: Room {self.dungeon_progress + 1}/{len(self.dungeon_rooms)}\"\n            )\n\n            choice = ask(\"Continue dungeon (C) or Exit (E)? \").strip().upper()\n            if choice == 'C':\n                self.continue_dungeon()\n            elif choice == 'E':\n                self.exit_dungeon()\n            return\n\n        # Show available dungeons (filter by allowed_areas)\n        all_dungeons = self.dungeons_data.get('dungeons', [])\n        if not all_dungeons:\n            print(\"No dungeons available.\")\n            return\n\n        # Filter dungeons by allowed_areas for current location\n        dungeons = []\n        for dungeon in all_dungeons:\n            allowed_areas = dungeon.get('allowed_areas', [])\n            if not allowed_areas or self.current_area in allowed_areas:\n                dungeons.append(dungeon)\n\n        if not dungeons:\n            print(\n                f\"\\n{Colors.YELLOW}No dungeons available in {self.current_area}.{Colors.END}\"\n            )\n            print(\"Travel to other areas to find dungeons.\")\n            return\n\n        print(\n            f\"\\n{Colors.CYAN}Available Dungeons in {self.current_area}:{Colors.END}\"\n        )\n        for i, dungeon in enumerate(dungeons, 1):\n            name = dungeon['name']\n            difficulty = dungeon['difficulty']\n            rooms = dungeon['rooms']\n            desc = dungeon['description']\n\n            # Check if player meets minimum level requirement\n            min_level = difficulty[0] * 5  # Rough level requirement\n            level_ok = self.player.level >= min_level\n\n            status = f\"{Colors.GREEN}Available{Colors.END}\" if level_ok else f\"{Colors.RED}Level {min_level}+ required{Colors.END}\"\n\n            print(\n                f\"{i}. {Colors.BOLD}{name}{Colors.END} (Difficulty {difficulty[0]}-{difficulty[1]}, {rooms} rooms)\"\n            )\n            print(f\"   {desc}\")\n            print(f\"   Status: {status}\")\n\n        choice = ask(\n            f\"\\nChoose dungeon (1-{len(dungeons)}) or press Enter to cancel: \")\n        if choice and choice.isdigit():\n            idx = int(choice) - 1\n            if 0 <= idx < len(dungeons):\n                dungeon = dungeons[idx]\n                min_level = dungeon['difficulty'][0] * 5\n                if self.player.level >= min_level:\n                    self.enter_dungeon(dungeon)\n                    clear_screen()\n                else:\n                    print(\n                        f\"You need to be at least level {min_level} to enter this dungeon.\"\n                    )\n            else:\n                print(\"Invalid choice.\")\n\n    def enter_dungeon(self, dungeon: Dict[str, Any]):\n        \"\"\"Enter a dungeon and generate rooms\"\"\"\n        print(\n            f\"\\n{Colors.MAGENTA}{Colors.BOLD}Entering {dungeon['name']}!{Colors.END}\"\n        )\n        print(dungeon['description'])\n\n        # Set dungeon state\n        self.current_dungeon = dungeon\n        self.dungeon_progress = 0\n        self.dungeon_state = {\n            'start_time': datetime.now().isoformat(),\n            'total_rooms': dungeon['rooms'],\n            'current_room': 0\n        }\n\n        # Generate dungeon rooms based on weights\n        self.generate_dungeon_rooms(dungeon)\n\n        # Start with first room\n        self.continue_dungeon()\n\n    def generate_dungeon_rooms(self, dungeon: Dict[str, Any]):\n        \"\"\"Generate dungeon rooms based on room weights\"\"\"\n        room_weights = dungeon.get('room_weights', {})\n        total_rooms = dungeon.get('rooms', 5)\n\n        self.dungeon_rooms = []\n\n        # Validate room_weights\n        if not room_weights or sum(room_weights.values()) == 0:\n            # Default room weights if none provided or sum is zero\n            room_weights = {\n                'battle': 40,\n                'question': 20,\n                'chest': 15,\n                'empty': 15,\n                'trap_chest': 5,\n                'multi_choice': 5\n            }\n\n        if total_rooms <= 0:\n            total_rooms = 5\n\n        # Create weighted room list\n        room_types = []\n        weights = []\n\n        for room_type, weight in room_weights.items():\n            room_types.append(room_type)\n            weights.append(weight)\n\n        # Generate rooms\n        for i in range(total_rooms):\n            # Last room is always boss room\n            if i == total_rooms - 1:\n                room_type = 'boss'\n            else:\n                room_type = random.choices(room_types, weights=weights, k=1)[0]\n\n            room_data = {\n                'type': room_type,\n                'room_number': i + 1,\n                'difficulty': dungeon.get('difficulty', [1, 3])[0] +\n                (i * 0.5)  # Scale difficulty\n            }\n\n            self.dungeon_rooms.append(room_data)\n\n    def continue_dungeon(self):\n        \"\"\"Continue through the current dungeon\"\"\"\n        if not self.current_dungeon or not self.dungeon_rooms:\n            print(\"No active dungeon.\")\n            return\n\n        # Loop through rooms until dungeon is complete\n        while self.current_dungeon and self.dungeon_progress < len(\n                self.dungeon_rooms):\n            # Get current room\n            room = self.dungeon_rooms[self.dungeon_progress]\n\n            print(\n                f\"\\n{Colors.CYAN}{Colors.BOLD}=== Room {room['room_number']} ==={Colors.END}\"\n            )\n\n            # Handle room based on type\n            room_type = room['type']\n            if room_type == 'question':\n                self.handle_question_room(room)\n            elif room_type == 'battle':\n                self.handle_battle_room(room)\n            elif room_type == 'chest':\n                self.handle_chest_room(room)\n            elif room_type == 'trap_chest':\n                self.handle_trap_chest_room(room)\n            elif room_type == 'multi_choice':\n                self.handle_multi_choice_room(room)\n            elif room_type == 'empty':\n                self.handle_empty_room(room)\n            elif room_type == 'boss':\n                self.handle_boss_room(room)\n\n            # Check if player died during room\n            if not self.player or not self.player.is_alive():\n                return\n\n        # Dungeon complete\n        if self.current_dungeon and self.dungeon_progress >= len(\n                self.dungeon_rooms):\n            self.complete_dungeon()\n\n    def handle_question_room(self, room: Dict[str, Any]):\n        \"\"\"Handle a question/riddle room\"\"\"\n        if not self.player:\n            return\n        print(\"You encounter a mystical pedestal with glowing runes...\")\n\n        # Get random question from challenge templates\n        challenge_templates = self.dungeons_data.get('challenge_templates', {})\n        question_template = challenge_templates.get('question', {})\n\n        if not question_template or not question_template.get('types'):\n            print(\"No questions available. You proceed safely.\")\n            self.advance_room()\n            return\n\n        question_data = random.choice(question_template['types'])\n\n        print(f\"\\n{Colors.YELLOW}{Colors.BOLD}Riddle:{Colors.END}\")\n        print(question_data['question'])\n\n        # Show hints if available\n        if question_data.get('hints'):\n            print(\n                f\"\\n{Colors.DARK_GRAY}Hints available (type 'hint' to see them){Colors.END}\"\n            )\n\n        time_limit = question_data.get('time_limit', 60)\n        start_time = time.time()\n        answered_correctly = False\n        attempts = 0\n        max_attempts = question_data.get('max_attempts', 3)\n\n        while attempts < max_attempts:\n            answer = ask(\n                f\"Your answer ({max_attempts - attempts} tries left, or type 'leave'): \"\n            ).strip().lower()\n\n            if answer == 'leave':\n                print(\"You decide to give up on the riddle.\")\n                break\n\n            if answer == 'hint' and question_data.get('hints'):\n                print(f\"\\n{Colors.CYAN}Hints:{Colors.END}\")\n                for i, hint in enumerate(question_data['hints'], 1):\n                    print(f\"{i}. {hint}\")\n                continue\n\n            # Check time limit\n            elapsed = time.time() - start_time\n            if elapsed > time_limit:\n                print(f\"{Colors.RED}Time's up!{Colors.END}\")\n                break\n\n            # Check answer\n            correct_answer = question_data.get('answer', '').lower()\n            if answer == correct_answer:\n                print(f\"{Colors.GREEN}Correct!{Colors.END}\")\n                answered_correctly = True\n\n                # Give rewards\n                reward = question_data.get('success_reward', {})\n                if reward.get('gold') and self.player:\n                    self.player.gold += reward['gold']\n                    print(f\"You gained {reward['gold']} gold!\")\n                if reward.get('experience') and self.player:\n                    self.player.gain_experience(reward['experience'])\n                    print(f\"You gained {reward['experience']} experience!\")\n                break\n            else:\n                attempts += 1\n                print(f\"{Colors.RED}Incorrect.{Colors.END}\")\n\n                # Show close matches\n                close = difflib.get_close_matches(answer, [correct_answer],\n                                                  n=1,\n                                                  cutoff=0.6)\n                if close:\n                    print(\n                        f\"{Colors.YELLOW}Close, but not quite right.{Colors.END}\"\n                    )\n                else:\n                    print(\n                        f\"{Colors.YELLOW}Try again or ask for a hint.{Colors.END}\"\n                    )\n\n        # Handle outcome\n        if answered_correctly:\n            self.advance_room()\n        else:\n            # Failed - take damage\n            damage = question_data.get('failure_damage', 15)\n            if self.player:\n                actual_damage = self.player.take_damage(damage)\n                print(\n                    f\"You took {actual_damage} damage from the failed riddle!\")\n\n                if self.player.is_alive():\n                    self.advance_room()\n                else:\n                    self.dungeon_death()\n            else:\n                self.advance_room()\n\n    def handle_battle_room(self, room: Dict[str, Any]):\n        \"\"\"Handle a battle room with enemies\"\"\"\n        if not self.player:\n            print(\"No player available for battle.\")\n            self.advance_room()\n            return\n\n        if not hasattr(self,\n                       'enemies_data') or not self.enemies_data or not hasattr(\n                           self, 'areas_data') or not self.areas_data:\n            print(\"Game data missing. You proceed safely.\")\n            self.advance_room()\n            return\n\n        print(\"You hear the sounds of combat approaching...\")\n\n        # Generate enemies based on difficulty\n        difficulty = room.get('difficulty', 1)\n        enemy_count = random.randint(1, max(1, int(difficulty)))\n\n        # Get enemies from current area or fallback with valid enemy checks\n        area_enemies = self.areas_data.get(self.current_area,\n                                           {}).get('possible_enemies', [])\n        if not area_enemies:\n            # Only use fallback enemies that actually exist in enemies_data\n            fallback_enemies = ['goblin', 'orc', 'skeleton']\n            area_enemies = [\n                e for e in fallback_enemies if e in self.enemies_data\n            ]\n            # If still no valid enemies, use all available enemies from enemies_data\n            if not area_enemies:\n                area_enemies = list(self.enemies_data.keys()\n                                    )[:5]  # Use first 5 enemies as last resort\n\n        enemies = []\n        for _ in range(enemy_count):\n            if not area_enemies:\n                break\n            enemy_name = random.choice(area_enemies)\n            enemy_data = self.enemies_data.get(enemy_name)\n            if enemy_data and all(k in enemy_data for k in [\n                    'name', 'hp', 'attack', 'defense', 'speed',\n                    'experience_reward', 'gold_reward'\n            ]):\n                # Scale enemy stats by difficulty\n                scaled_data = enemy_data.copy()\n                scaled_data['hp'] = int(scaled_data['hp'] *\n                                        (0.8 + difficulty * 0.2))\n                scaled_data['attack'] = int(scaled_data['attack'] *\n                                            (0.8 + difficulty * 0.2))\n                scaled_data['defense'] = int(scaled_data['defense'] *\n                                             (0.8 + difficulty * 0.2))\n\n                enemy = Enemy(scaled_data)\n                enemies.append(enemy)\n\n        # Handle case where no valid enemies were found\n        if not enemies:\n            print(\n                f\"{Colors.YELLOW}No enemies found! You proceed safely.{Colors.END}\"\n            )\n            self.advance_room()\n            return\n\n        print(f\"You encounter {len(enemies)} enemy(ies)!\")\n\n        # Battle each enemy\n        for i, enemy in enumerate(enemies):\n            if enemy is None:  # skip None enemies\n                continue\n            if self.player is None or not self.player.is_alive():\n                break\n\n            if len(enemies) > 1:\n                print(\n                    f\"\\n{Colors.RED}Enemy {i+1} of {len(enemies)}:{Colors.END}\"\n                )\n\n            self.battle(enemy)\n\n        if self.player and self.player.is_alive():\n            print(f\"{Colors.GREEN}You cleared the battle room!{Colors.END}\")\n            self.advance_room()\n        else:\n            self.dungeon_death()\n\n    def handle_chest_room(self, room: Dict[str, Any]):\n        \"\"\"Handle a treasure chest room\"\"\"\n        if not self.player:\n            print(\"No player available for chest room.\")\n            self.advance_room()\n            return\n        print(\"You find a chest in the center of the room!\")\n\n        # Determine chest quality based on difficulty\n        difficulty = room.get('difficulty', 1)\n        if difficulty >= 8:\n            chest_type = 'legendary'\n        elif difficulty >= 5:\n            chest_type = 'large'\n        elif difficulty >= 3:\n            chest_type = 'medium'\n        else:\n            chest_type = 'small'\n\n        chest_templates = self.dungeons_data.get('chest_templates', {})\n        chest_data = chest_templates.get(chest_type,\n                                         chest_templates.get('small', {}))\n\n        print(f\"It's a {chest_data.get('name', 'chest')}!\")\n\n        # Generate rewards\n        gold_min, gold_max = chest_data.get('gold_range', [50, 150])\n        gold_reward = random.randint(gold_min, gold_max)\n\n        item_count_min, item_count_max = chest_data.get(\n            'item_count_range', [1, 2])\n        item_count = random.randint(item_count_min, item_count_max)\n\n        exp_reward = chest_data.get('experience', 100)\n\n        # Give rewards\n        self.player.gold += gold_reward\n        self.player.gain_experience(exp_reward)\n\n        print(f\"\\n{Colors.GOLD}You found {gold_reward} gold!{Colors.END}\")\n        print(\n            f\"{Colors.MAGENTA}You gained {exp_reward} experience!{Colors.END}\")\n\n        # Generate items\n        item_rarities = chest_data.get('item_rarity', ['common'])\n        guaranteed_legendary = chest_data.get('guaranteed_legendary', False)\n\n        items_found = []\n\n        # Handle guaranteed legendary items\n        if guaranteed_legendary:\n            count = guaranteed_legendary if isinstance(guaranteed_legendary,\n                                                       int) else 1\n            legendary_items = [\n                item for item in self.items_data.values()\n                if item.get('rarity') == 'legendary'\n            ]\n            if legendary_items:\n                for _ in range(min(count, len(legendary_items))):\n                    item = random.choice(legendary_items)\n                    items_found.append(item['name'])\n                    self.player.inventory.append(item['name'])\n                    self.update_mission_progress('collect', item['name'])\n            else:\n                # No legendary items available, add bonus gold instead\n                bonus_gold = 100 * count\n                self.player.gold += bonus_gold\n                print(\n                    f\"{Colors.YELLOW}No legendary items found! Added {bonus_gold} bonus gold instead.{Colors.END}\"\n                )\n\n        # Generate random items - with safety checks for empty item lists\n        for _ in range(item_count - len(items_found)):\n            rarity = random.choice(item_rarities)\n            possible_items = [\n                item for item in self.items_data.values()\n                if item.get('rarity') == rarity\n            ]\n\n            if possible_items:\n                item = random.choice(possible_items)\n                items_found.append(item['name'])\n                self.player.inventory.append(item['name'])\n                self.update_mission_progress('collect', item['name'])\n            else:\n                # No items of this rarity, add bonus gold instead\n                bonus_gold = random.randint(25, 75)\n                self.player.gold += bonus_gold\n                print(\n                    f\"{Colors.DARK_GRAY}No items of {rarity} rarity found. Added {bonus_gold} gold instead.{Colors.END}\"\n                )\n\n        if items_found:\n            print(f\"{Colors.YELLOW}Items found:{Colors.END}\")\n            for item in items_found:\n                item_data = self.items_data.get(item, {})\n                color = get_rarity_color(item_data.get('rarity', 'common'))\n                print(f\"  - {color}{item}{Colors.END}\")\n\n        self.advance_room()\n\n    def handle_trap_chest_room(self, room: Dict[str, Any]):\n        \"\"\"Handle a trapped chest room\"\"\"\n        if not self.player:\n            print(\"No player available for trap chest room.\")\n            self.advance_room()\n            return\n        print(\"You find a suspicious chest with strange markings...\")\n\n        choice = ask(\"Open the chest (O) or leave it (L)? \").strip().upper()\n\n        if choice == 'L':\n            print(\"You wisely decide to leave the chest alone.\")\n            self.advance_room()\n            return\n\n        # Roll for trap\n        trap_chance = 0.7  # 70% chance of trap\n        if random.random() < trap_chance:\n            print(f\"{Colors.RED}TRAP TRIGGERED!{Colors.END}\")\n\n            # Get random trap\n            trap_templates = self.dungeons_data.get('challenge_templates',\n                                                    {}).get('trap', {})\n            trap_types = trap_templates.get('types', [])\n\n            if trap_types:\n                trap = random.choice(trap_types)\n                print(trap['description'])\n\n                # Roll d20 for trap avoidance\n                roll = random.randint(1, 20)\n                threshold = trap_templates.get('success_threshold', 10)\n\n                # Apply difficulty modifier\n                difficulty_mod = trap.get('difficulty', 'normal')\n                mod_data = trap_templates.get('difficulty_modifiers',\n                                              {}).get(difficulty_mod, {})\n                threshold += mod_data.get('threshold',\n                                          0) - 10  # Adjust threshold\n\n                print(f\"You roll a {roll} (need {threshold}+ to succeed)\")\n\n                if roll >= threshold:\n                    print(\n                        f\"{Colors.GREEN}You successfully avoid the trap!{Colors.END}\"\n                    )\n\n                    # Success reward\n                    reward = trap_templates.get('success_reward', {})\n                    if reward.get('gold'):\n                        self.player.gold += reward['gold']\n                        print(f\"You found {reward['gold']} gold in the chest!\")\n                    if reward.get('experience'):\n                        self.player.gain_experience(reward['experience'])\n                        print(f\"You gained {reward['experience']} experience!\")\n\n    def handle_multi_choice_room(self, room: Dict[str, Any]):\n        \"\"\"Handle a multiple choice decision room\"\"\"\n        if not self.player:\n            print(\"No player available for multi-choice room.\")\n            self.advance_room()\n            return\n        print(\"You come to a crossroads with multiple paths...\")\n\n        # Get random selection challenge\n        challenge_templates = self.dungeons_data.get('challenge_templates', {})\n        selection_template = challenge_templates.get('selection', {})\n\n        if not selection_template.get('types'):\n            print(\"The paths seem safe. You proceed.\")\n            self.advance_room()\n            return\n\n        challenge = random.choice(selection_template['types'])\n\n        print(f\"\\n{Colors.YELLOW}{Colors.BOLD}Decision:{Colors.END}\")\n        print(challenge['question'])\n\n        options = challenge.get('options', [])\n        for i, option in enumerate(options, 1):\n            print(f\"{i}. {option['text']}\")\n\n        time_limit = challenge.get('time_limit', 30)\n        start_time = time.time()\n\n        choice = ask(f\"Your choice (1-{len(options)}): \").strip()\n\n        # Check time limit\n        elapsed = time.time() - start_time\n        if elapsed > time_limit:\n            print(f\"{Colors.RED}You took too long to decide!{Colors.END}\")\n            # Random bad outcome\n            bad_options = [\n                opt for opt in options if not opt.get('correct', False)\n            ]\n            if bad_options:\n                outcome = random.choice(bad_options)\n            else:\n                outcome = options[0]\n        elif choice.isdigit() and 1 <= int(choice) <= len(options):\n            outcome = options[int(choice) - 1]\n        else:\n            print(\"Invalid choice.\")\n            return\n\n        print(f\"\\n{outcome['reason']}\")\n\n        if outcome.get('correct', False):\n            # Success reward\n            reward = challenge.get('success_reward', {})\n            if self.player:\n                if reward.get('gold'):\n                    self.player.gold += reward['gold']\n                    print(f\"You gained {reward['gold']} gold!\")\n                if reward.get('experience'):\n                    self.player.gain_experience(reward['experience'])\n                    print(f\"You gained {reward['experience']} experience!\")\n        else:\n            # Failure penalty\n            if self.player:\n                damage = challenge.get('failure_damage', 10)\n                actual_damage = self.player.take_damage(damage)\n                print(f\"You took {actual_damage} damage!\")\n\n                if not self.player.is_alive():\n                    self.dungeon_death()\n                    return\n\n        self.advance_room()\n\n    def handle_empty_room(self, room: Dict[str, Any]):\n        \"\"\"Handle an empty room\"\"\"\n        print(\"This room appears to be empty...\")\n\n        # Small chance for hidden treasure or encounter\n        if random.random() < 0.3:  # 30% chance\n            if random.random() < 0.5:\n                # Hidden treasure\n                if self.player:\n                    gold_found = random.randint(10, 50)\n                    self.player.gold += gold_found\n                    print(\n                        f\"{Colors.GOLD}You found {gold_found} gold hidden in the room!{Colors.END}\"\n                    )\n            else:\n                # Random encounter\n                print(\"You hear a noise...\")\n                time.sleep(1)\n                self.random_encounter()\n                if self.player and not self.player.is_alive():\n                    self.dungeon_death()\n                    return\n        else:\n            print(\"Nothing of interest here.\")\n\n        self.advance_room()\n\n    def handle_boss_room(self, room: Dict[str, Any]):\n        \"\"\"Handle the boss room\"\"\"\n        dungeon = self.current_dungeon\n        if dungeon:\n            boss_id = dungeon.get('boss_id')\n        else:\n            boss_id = None\n\n        if boss_id and boss_id in self.bosses_data:\n            boss_data = self.bosses_data[boss_id]\n            boss = Boss(boss_data, self.dialogues_data)\n\n            print(f\"\\n{Colors.RED}{Colors.BOLD}BOSS BATTLE!{Colors.END}\")\n            print(f\"You face {boss.name}!\")\n            print(boss.description)\n\n            # Print start dialogue if available\n            start_dialogue = boss.get_dialogue(\"on_start_battle\")\n            if start_dialogue:\n                print(\n                    f\"\\n{Colors.CYAN}{boss.name}:{Colors.END} {start_dialogue}\"\n                )\n\n            self.battle(boss)\n\n            if self.player and self.player.is_alive():\n                print(f\"\\n{Colors.GREEN}{Colors.BOLD}VICTORY!{Colors.END}\")\n                print(f\"You defeated {boss.name}!\")\n\n                # Boss rewards\n                exp_reward = boss.experience_reward * 2  # Double XP for bosses\n                gold_reward = boss.gold_reward * 2\n\n                self.player.gain_experience(exp_reward)\n                self.player.gold += gold_reward\n\n                print(\n                    f\"Gained {Colors.MAGENTA}{exp_reward} experience{Colors.END}\"\n                )\n                print(f\"Gained {Colors.GOLD}{gold_reward} gold{Colors.END}\")\n\n                # Boss loot\n                if boss.loot_table:\n                    loot = random.choice(boss.loot_table)\n                    self.player.inventory.append(loot)\n                    print(f\"{Colors.YELLOW}Boss loot: {loot}!{Colors.END}\")\n                    self.update_mission_progress('collect', loot)\n\n                self.complete_dungeon()\n            else:\n                self.dungeon_death()\n        else:\n            # Boss not found - try to find a suitable replacement or generate a generic boss\n            print(\n                f\"{Colors.YELLOW}Boss data not found. A powerful enemy appears!{Colors.END}\"\n            )\n\n            # Try to use dungeon completion rewards as a \"boss substitute\"\n            dungeon = self.current_dungeon\n            if dungeon:\n                completion_reward = dungeon.get('completion_reward', {})\n                exp_reward = completion_reward.get('experience',\n                                                   500) // 2  # Half reward\n                gold_reward = completion_reward.get('gold', 300) // 2\n\n                if self.player:\n                    self.player.gain_experience(exp_reward)\n                    self.player.gold += gold_reward\n\n                    print(\"You defeated the mysterious guardian!\")\n                    print(\n                        f\"Gained {Colors.MAGENTA}{exp_reward} experience{Colors.END}\"\n                    )\n                    print(\n                        f\"Gained {Colors.GOLD}{gold_reward} gold{Colors.END}\")\n\n                    # Give a random item from completion reward if available\n                    items = completion_reward.get('items', [])\n                    if items:\n                        loot = random.choice(items)\n                        self.player.inventory.append(loot)\n                        print(\n                            f\"{Colors.YELLOW}Special item: {loot}!{Colors.END}\"\n                        )\n\n            self.complete_dungeon()\n\n    def advance_room(self):\n        \"\"\"Advance to the next room\"\"\"\n        self.dungeon_progress += 1\n        if self.dungeon_progress < len(self.dungeon_rooms):\n            self.dungeon_state['current_room'] = self.dungeon_progress\n\n        if self.dungeon_progress >= len(self.dungeon_rooms):\n            self.complete_dungeon()\n        else:\n            print(f\"\\n{Colors.CYAN}Moving to the next room...{Colors.END}\")\n            time.sleep(1)\n            clear_screen()\n\n    def complete_dungeon(self):\n        \"\"\"Complete the current dungeon\"\"\"\n        if not self.current_dungeon:\n            return\n\n        dungeon = self.current_dungeon\n        print(f\"\\n{Colors.GOLD}{Colors.BOLD}DUNGEON COMPLETE!{Colors.END}\")\n        print(f\"You successfully cleared {dungeon['name']}!\")\n\n        # Calculate completion time\n        start_time_str = self.dungeon_state.get('start_time')\n        if start_time_str:\n            try:\n                start_time = datetime.fromisoformat(start_time_str)\n            except (ValueError, TypeError):\n                start_time = datetime.now()\n        else:\n            start_time = datetime.now()\n        end_time = datetime.now()\n        duration = end_time - start_time\n\n        print(\n            f\"Completion time: {duration.seconds // 60}m {duration.seconds % 60}s\"\n        )\n\n        # Update challenge for dungeon completion\n        self.update_challenge_progress('dungeon_complete')\n\n        # Give completion rewards\n        completion_reward = dungeon.get('completion_reward', {})\n        if completion_reward and self.player:\n            print(\n                f\"\\n{Colors.GOLD}{Colors.BOLD}Completion Rewards:{Colors.END}\")\n\n            # Gold reward\n            gold_reward = completion_reward.get('gold', 0)\n            if gold_reward > 0:\n                self.player.gold += gold_reward\n                print(f\"  {Colors.GOLD}+{gold_reward} gold{Colors.END}\")\n\n            # Experience reward\n            exp_reward = completion_reward.get('experience', 0)\n            if exp_reward > 0:\n                self.player.gain_experience(exp_reward)\n                print(\n                    f\"  {Colors.MAGENTA}+{exp_reward} experience{Colors.END}\")\n\n            # Item rewards\n            items = completion_reward.get('items', [])\n            if items:\n                print(f\"  {Colors.YELLOW}Items received:{Colors.END}\")\n                for item_name in items:\n                    self.player.inventory.append(item_name)\n                    item_data = self.items_data.get(item_name, {})\n                    color = get_rarity_color(item_data.get('rarity', 'common'))\n                    print(f\"    - {color}{item_name}{Colors.END}\")\n                    self.update_mission_progress('collect', item_name)\n\n        # Clear dungeon state\n        self.current_dungeon = None\n        self.dungeon_progress = 0\n        self.dungeon_rooms = []\n        self.dungeon_state = {}\n\n    def exit_dungeon(self):\n        \"\"\"Exit the current dungeon\"\"\"\n        if not self.player:\n            return\n\n        # Check for none here\n        if self.current_dungeon is not None:\n            print(\n                f\"\\n{Colors.YELLOW}Exiting {self.current_dungeon['name']}...{Colors.END}\"\n            )\n        else:\n            print(f\"\\n{Colors.YELLOW}Exiting dungeon...{Colors.END}\")\n\n        # Optional: penalty for early exit\n        if self.dungeon_progress > 0 and self.player:\n            penalty_gold = min(self.player.gold // 10,\n                               100)  # 10% of gold or 100 max\n            if penalty_gold > 0:\n                self.player.gold -= penalty_gold\n                print(\n                    f\"{Colors.RED}Exit penalty: Lost {penalty_gold} gold{Colors.END}\"\n                )\n\n        # Clear dungeon state\n        self.current_dungeon = None\n        self.dungeon_progress = 0\n        self.dungeon_rooms = []\n        self.dungeon_state = {}\n\n    def dungeon_death(self):\n        \"\"\"Handle death in dungeon\"\"\"\n        if not self.player:\n            return\n        print(\n            f\"\\n{Colors.RED}{Colors.BOLD}You have fallen in the dungeon!{Colors.END}\"\n        )\n        print(\n            f\"\\n{Colors.RED}{Colors.BOLD}You have fallen in the dungeon!{Colors.END}\"\n        )\n\n        if self.player:\n            # Death penalty\n            self.player.hp = self.player.max_hp // 2\n            self.player.mp = self.player.max_mp // 2\n\n            # Lose some gold\n            gold_loss = min(self.player.gold // 5,\n                            200)  # 20% of gold or 200 max\n            self.player.gold -= gold_loss\n            print(f\"You lost {gold_loss} gold to the dungeon spirits.\")\n\n        # Return to starting village\n        self.current_area = \"starting_village\"\n        print(\"You respawn at the starting village.\")\n\n        # Clear dungeon state\n        self.current_dungeon = None\n        self.dungeon_progress = 0\n        self.dungeon_rooms = []\n        self.dungeon_state = {}\n\n    def visit_alchemy(self):\n        \"\"\"Visit the Alchemy workshop to craft items\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        if not self.crafting_data or not self.crafting_data.get('recipes'):\n            print(\"No crafting recipes available.\")\n            return\n\n        print(\n            f\"\\n{Colors.MAGENTA}{Colors.BOLD}=== ALCHEMY WORKSHOP ==={Colors.END}\"\n        )\n        print(\n            \"Welcome to the Alchemy Workshop! Here you can craft potions, elixirs, and items.\"\n        )\n        print(f\"\\nYour gold: {Colors.GOLD}{self.player.gold}{Colors.END}\")\n\n        # Display available materials from inventory\n        self._display_crafting_materials()\n\n        while True:\n            clear_screen()\n            print(f\"\\n{Colors.BOLD}=== ALCHEMY WORKSHOP ==={Colors.END}\")\n            print(\n                \"Categories: [P]otions, [E]lixirs, [E]ntchantments, [U]tility, [A]ll\"\n            )\n            print(\"[C]raft Item, [M]aterials, [B]ack to Menu\")\n\n            choice = ask(\"\\nChoose an option: \").strip().upper()\n\n            if choice == 'B' or not choice:\n                break\n            elif choice == 'P':\n                self._display_recipes_by_category('Potions')\n            elif choice == 'E':\n                # Ask which type of E (Elixirs or Enchantments)\n                print(\"E - Elixirs, N - Enchantments\")\n                sub = ask(\"Choose (E/N): \").strip().upper()\n                if sub == 'E':\n                    self._display_recipes_by_category('Elixirs')\n                elif sub == 'N':\n                    self._display_recipes_by_category('Enchantments')\n            elif choice == 'U':\n                self._display_recipes_by_category('Utility')\n            elif choice == 'A':\n                self._display_all_recipes()\n            elif choice == 'C':\n                self._craft_item()\n            elif choice == 'M':\n                self._display_crafting_materials()\n            else:\n                print(\"Invalid choice.\")\n\n    def _display_crafting_materials(self):\n        \"\"\"Display materials available in player's inventory\"\"\"\n        if not self.player:\n            return\n\n        print(f\"\\n{Colors.CYAN}=== YOUR MATERIALS ==={Colors.END}\")\n\n        # Get all material categories\n        material_categories = self.crafting_data.get('material_categories', {})\n\n        # Collect all possible materials\n        all_materials = set()\n        for materials in material_categories.values():\n            all_materials.update(materials)\n\n        # Count materials in inventory\n        material_counts = {}\n        for item in self.player.inventory:\n            if item in all_materials:\n                material_counts[item] = material_counts.get(item, 0) + 1\n\n        if not material_counts:\n            print(\"No crafting materials in your inventory.\")\n            print(\n                \"Materials can be found as drops from enemies or purchased from shops.\"\n            )\n            return\n\n        print(f\"{'Material':<25} {'Quantity':<10}\")\n        print(\"-\" * 35)\n        for material, count in sorted(material_counts.items()):\n            print(f\"{material:<25} {count:<10}\")\n\n    def _display_recipes_by_category(self, category: str):\n        \"\"\"Display recipes filtered by category\"\"\"\n        if not self.crafting_data:\n            return\n\n        recipes = self.crafting_data.get('recipes', {})\n        category_recipes = [(rid, rdata) for rid, rdata in recipes.items()\n                            if rdata.get('category') == category]\n\n        if not category_recipes:\n            print(f\"\\nNo recipes found in category: {category}\")\n            return\n\n        print(f\"\\n{Colors.BOLD}=== {category.upper()} ==={Colors.END}\")\n        for i, (rid, rdata) in enumerate(category_recipes, 1):\n            name = rdata.get('name', rid)\n            rarity = rdata.get('rarity', 'common')\n            rarity_color = get_rarity_color(rarity)\n            print(f\"{i}. {rarity_color}{name}{Colors.END}\")\n\n    def _display_all_recipes(self):\n        \"\"\"Display all available recipes\"\"\"\n        if not self.crafting_data:\n            return\n\n        recipes = self.crafting_data.get('recipes', {})\n        if not recipes:\n            print(\"\\nNo recipes available.\")\n            return\n\n        page_size = 10\n        recipe_list = list(recipes.items())\n        current_page = 0\n\n        while True:\n            start = current_page * page_size\n            end = start + page_size\n            page_items = recipe_list[start:end]\n\n            print(f\"\\n{Colors.BOLD}=== ALL RECIPES ==={Colors.END}\")\n            for i, (rid, rdata) in enumerate(page_items, 1):\n                name = rdata.get('name', rid)\n                category = rdata.get('category', 'Unknown')\n                rarity = rdata.get('rarity', 'common')\n                rarity_color = get_rarity_color(rarity)\n                print(\n                    f\"{start + i}. {rarity_color}{name}{Colors.END} ({category})\"\n                )\n\n            total_pages = (len(recipe_list) + page_size - 1) // page_size\n            print(f\"\\nPage {current_page + 1}/{total_pages}\")\n\n            if total_pages > 1:\n                if current_page > 0:\n                    print(\"P. Previous Page\")\n                if current_page < total_pages - 1:\n                    print(\"N. Next Page\")\n            print(\"C. Craft Item\")\n            print(\"B. Back\")\n\n            choice = ask(\"\\nChoose an option: \").strip().upper()\n\n            if choice == 'B':\n                break\n            elif choice == 'N' and current_page < total_pages - 1:\n                current_page += 1\n            elif choice == 'P' and current_page > 0:\n                current_page -= 1\n            elif choice == 'C':\n                self._craft_item()\n            else:\n                print(\"Invalid choice.\")\n\n    def _craft_item(self):\n        \"\"\"Craft an item using materials from inventory\"\"\"\n        if not self.player or not self.crafting_data:\n            print(\"Cannot craft items.\")\n            return\n\n        recipes = self.crafting_data.get('recipes', {})\n\n        # Show all recipes for selection\n        print(f\"\\n{Colors.BOLD}=== CRAFT ITEM ==={Colors.END}\")\n        recipe_names = list(recipes.keys())\n\n        for i, rid in enumerate(recipe_names, 1):\n            rdata = recipes[rid]\n            name = rdata.get('name', rid)\n            rarity = rdata.get('rarity', 'common')\n            rarity_color = get_rarity_color(rarity)\n            print(f\"{i}. {rarity_color}{name}{Colors.END}\")\n\n        choice = ask(\n            f\"\\nChoose recipe (1-{len(recipe_names)}) or press Enter to cancel: \"\n        ).strip()\n\n        if not choice:\n            return\n\n        if not choice.isdigit():\n            print(\"Invalid choice.\")\n            return\n\n        idx = int(choice) - 1\n        if not (0 <= idx < len(recipe_names)):\n            print(\"Invalid recipe number.\")\n            return\n\n        recipe_id = recipe_names[idx]\n        recipe = recipes[recipe_id]\n\n        # Check skill requirement\n        skill_req = recipe.get('skill_requirement', 1)\n        if self.player.level < skill_req:\n            print(\n                f\"\\n{Colors.RED}You need at least level {skill_req} to craft this item.{Colors.END}\"\n            )\n            return\n\n        # Get materials required\n        materials_needed = recipe.get('materials', {})\n\n        # Check if player has materials\n        missing_materials = []\n        for material, quantity in materials_needed.items():\n            in_inventory = self.player.inventory.count(material)\n            if in_inventory < quantity:\n                missing_materials.append(\n                    f\"{material} (need {quantity}, have {in_inventory})\")\n\n        if missing_materials:\n            print(f\"\\n{Colors.RED}Missing materials:{Colors.END}\")\n            for m in missing_materials:\n                print(f\"  - {m}\")\n            print(\"\\nGather more materials before crafting.\")\n            return\n\n        # Show craft confirmation\n        output_items = recipe.get('output', {})\n        print(f\"\\n{Colors.BOLD}=== CRAFT CONFIRMATION ==={Colors.END}\")\n        print(f\"Recipe: {recipe.get('name')}\")\n        print(\n            f\"Output: {', '.join(f'{qty}x {item}' for item, qty in output_items.items())}\"\n        )\n        print(\"\\nMaterials to consume:\")\n        for material, quantity in materials_needed.items():\n            print(f\"  - {quantity}x {material}\")\n\n        confirm = ask(\"\\nCraft this item? (y/n): \").strip().lower()\n        if confirm != 'y':\n            print(\"Crafting cancelled.\")\n            return\n\n        # Consume materials\n        for material, quantity in materials_needed.items():\n            for _ in range(quantity):\n                self.player.inventory.remove(material)\n\n        # Add crafted items to inventory\n        for item, quantity in output_items.items():\n            for _ in range(quantity):\n                self.player.inventory.append(item)\n                self.update_mission_progress('collect', item)\n\n        print(\n            f\"\\n{Colors.GREEN}Successfully crafted {recipe.get('name')}!{Colors.END}\"\n        )\n        for item, quantity in output_items.items():\n            print(f\"  Received: {quantity}x {item}\")\n\n    def _visit_general_shop(self, shop_data):\n        \"\"\"Visit a general shop (not housing)\"\"\"\n        if not self.player:\n            print(\"No character created yet.\")\n            return\n\n        shop_name = shop_data.get(\"name\", \"Shop\")\n        welcome_msg = shop_data.get(\"welcome_message\",\n                                    f\"Welcome to {shop_name}!\")\n        items = shop_data.get(\"items\", [])\n        max_buy = shop_data.get(\"max_buy\", 99)\n\n        print(f\"\\n{Colors.BOLD}=== {shop_name.upper()} ==={Colors.END}\")\n        print(welcome_msg)\n        print(f\"Your gold: {Colors.GOLD}{self.player.gold}{Colors.END}\")\n\n        if not items:\n            print(\"This shop has no items available.\")\n            return\n\n        # Group items by type for better display\n        item_details = []\n        for item_id in items:\n            if item_id in self.items_data:\n                item = self.items_data[item_id]\n                item_details.append({\n                    'id': item_id,\n                    'name': item.get('name', item_id),\n                    'type': item.get('type', 'misc'),\n                    'rarity': item.get('rarity', 'common'),\n                    'price': item.get('price', 0),\n                    'description': item.get('description', '')\n                })\n\n        if not item_details:\n            print(\"No valid items found in this shop.\")\n            return\n\n        page_size = 8\n        current_page = 0\n\n        while True:\n            start = current_page * page_size\n            end = start + page_size\n            page_items = item_details[start:end]\n\n            print(f\"\\n--- Items (Page {current_page + 1}) ---\")\n            for i, item in enumerate(page_items, 1):\n                rarity_color = get_rarity_color(item['rarity'])\n                owned_count = self.player.inventory.count(item['id'])\n                can_buy_more = owned_count < max_buy\n\n                status = \"\"\n                if not can_buy_more:\n                    status = f\" {Colors.RED}(Max owned: {max_buy}){Colors.END}\"\n                elif owned_count > 0:\n                    status = f\" {Colors.YELLOW}(Owned: {owned_count}){Colors.END}\"\n\n                print(\n                    f\"{start + i}. {rarity_color}{item['name']}{Colors.END} - {Colors.GOLD}{item['price']}g{Colors.END}{status}\"\n                )\n                print(f\"   {item['description']}\")\n\n            total_pages = (len(item_details) + page_size - 1) // page_size\n            print(f\"\\nPage {current_page + 1}/{total_pages}\")\n\n            if total_pages > 1:\n                if current_page > 0:\n                    print(\"P. Previous Page\")\n                if current_page < total_pages - 1:\n                    print(\"N. Next Page\")\n            print(\"B. Back\")\n\n            choice = ask(\"\\nChoose item to buy or option: \").strip().upper()\n\n            if choice == 'B':\n                break\n            elif choice == 'N' and current_page < total_pages - 1:\n                current_page += 1\n            elif choice == 'P' and current_page > 0:\n                current_page -= 1\n            elif choice.isdigit():\n                item_idx = int(choice) - 1\n                if 0 <= item_idx < len(item_details):\n                    item = item_details[item_idx]\n                    owned_count = self.player.inventory.count(item['id'])\n\n                    if owned_count >= max_buy:\n                        print(\n                            f\"{Colors.RED}You already own the maximum amount ({max_buy}) of this item.{Colors.END}\"\n                        )\n                        continue\n\n                    if self.player.gold >= item['price']:\n                        self.player.gold -= item['price']\n                        self.player.inventory.append(item['id'])\n                        print(\n                            f\"{Colors.GREEN}Purchased {item['name']} for {item['price']} gold!{Colors.END}\"\n                        )\n                        self.update_mission_progress('collect', item['id'])\n                    else:\n                        print(\n                            f\"{Colors.RED}Not enough gold! Need {item['price']}, have {self.player.gold}.{Colors.END}\"\n                        )\n                else:\n                    print(\"Invalid item number.\")\n            else:\n                print(\"Invalid choice.\")\n        \"\"\"Build structures - alias for build_home for now\"\"\"\n        self.build_home()\n\n    def run(self):\n        \"\"\"Main game loop\"\"\"\n        choice = self.display_welcome()\n\n        if choice == \"new_game\":\n            self.create_character()\n        elif choice == \"load_game\":\n            self.load_game()\n            if not self.player:\n                print(\"No game loaded. Starting new game...\")\n                self.create_character()\n\n        # Main game loop\n        while True:\n            self.main_menu()\n\n\ndef main():\n    \"\"\"Main entry point\"\"\"\n    game = Game()\n    game.save_on_error = game.save_on_error  # Ensure it's reachable\n\n    # Setup global handlers for Ctrl+C and uncaught exceptions so we can save before exit\n    try:\n        # SIGINT handler\n        def _handle_sigint(signum, frame):\n            print(\n                \"\\nReceived interrupt (SIGINT). Attempting to save before exit...\"\n            )\n            try:\n                game.save_on_error(filename_prefix=\"err_save_unstable_\")\n            finally:\n                sys.exit(1)\n\n        signal.signal(signal.SIGINT, _handle_sigint)\n\n        # Unhandled exception hook\n        def _handle_exception(exc_type, exc_value, exc_tb):\n            print(\n                \"Unhandled exception occurred. Attempting to save game before exiting...\"\n            )\n            try:\n                game.save_on_error((exc_type, exc_value, exc_tb),\n                                   filename_prefix=\"err_save_unstable_\")\n            except Exception:\n                pass\n            # Print the traceback to stderr then exit\n            traceback.print_exception(exc_type, exc_value, exc_tb)\n            sys.exit(1)\n\n        sys.excepthook = _handle_exception\n    except Exception:\n        # If handler setup fails, continue without it\n        pass\n\n    game.run()\n\n\nif __name__ == \"__main__\":\n    clear_screen()\n    main()\n","path":null,"size_bytes":279388,"size_tokens":null},"gui_all.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nOur Legacy - GUI All Version\nA comprehensive GUI wrapper for the full project using Py2GUI.\nThis version integrates the launcher and all modules into a single GUI experience.\n\"\"\"\n\nimport builtins\nimport sys\nimport re\nimport os\n\n# Add current directory to path for imports\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\n# Import py2gui functions\nfrom py2gui import (display, user_type_in, clear, run as gui_run, set_theme,\n                    exit_gui)\n\n# Import the main components\nimport launcher\nfrom launcher import LauncherExit\nimport main\nimport storyland\nimport storywrite\nimport chat\n\n# Color code patterns for stripping\nCOLOR_PATTERN = re.compile(r'\\x1b\\[[0-9;]*m')\nANSI_PATTERN = re.compile(r'\\033\\[[0-9;]*m')\n\n\ndef strip_colors(text):\n    \"\"\"Remove all ANSI color codes from text\"\"\"\n    if text is None:\n        return \"\"\n    text = str(text)\n    text = COLOR_PATTERN.sub('', text)\n    text = ANSI_PATTERN.sub('', text)\n    # Also strip any Colors class references\n    text = re.sub(r'Colors\\.[A-Z_]+', '', text)\n    return text\n\n\ndef gui_print(*args, sep=' ', end='\\n', **_kwargs):\n    \"\"\"Replacement for print() that outputs to GUI\"\"\"\n    text = sep.join(str(arg) for arg in args) + end\n    text = strip_colors(text)\n    display(text, parse_ansi=False)\n\n\ndef gui_input(prompt=\"\"):\n    \"\"\"Replacement for input() that uses GUI input\"\"\"\n    prompt = strip_colors(prompt)\n    result = user_type_in(prompt)\n    return result if result is not None else \"\"\n\n\n# Monkey patch built-in functions globally\nbuiltins.print = gui_print\nbuiltins.input = gui_input\n\n\n# Shared NoColors class\nclass NoColors:\n    \"\"\"Color class that returns empty strings (no colors)\"\"\"\n\n    def __getattr__(self, _name):\n        return \"\"\n\n\n# Apply patches to all modules\nmodules_to_patch = [main, storyland, storywrite, chat, launcher]\nfor mod in modules_to_patch:\n    if hasattr(mod, 'clear_screen'):\n        setattr(mod, 'clear_screen', clear)\n    if hasattr(mod, 'clear'):\n        setattr(mod, 'clear', clear)\n    setattr(mod, 'Colors', NoColors())\n\n# Specific patches for modules\nif hasattr(main, 'ask'):\n    setattr(main, 'ask', gui_input)\n\n\n# Launcher specific GUI functions\ndef gui_run_main():\n    clear()\n    display(\"=== Starting Main Game ===\\n\")\n    try:\n        main.main()\n    except (SystemExit, KeyboardInterrupt):\n        pass\n    except Exception as e:\n        display(f\"\\nError in Main Game: {str(e)}\\n\")\n    display(\"\\nReturning to launcher...\")\n    clear()\n\n\ndef gui_run_storyland():\n    clear()\n    display(\"=== Starting Storyland (Mod Browser) ===\\n\")\n    try:\n        storyland.main()\n    except (SystemExit, KeyboardInterrupt):\n        pass\n    except Exception as e:\n        display(f\"\\nError in Storyland: {str(e)}\\n\")\n    display(\"\\nReturning to launcher...\")\n    clear()\n\n\ndef gui_run_storywrite():\n    clear()\n    display(\"=== Starting Storywrite (Mod Uploader) ===\\n\")\n    try:\n        storywrite.main_menu()\n    except (SystemExit, KeyboardInterrupt):\n        pass\n    except Exception as e:\n        display(f\"\\nError in Storywrite: {str(e)}\\n\")\n    display(\"\\nReturning to launcher...\")\n    clear()\n\n\ndef gui_run_chat():\n    clear()\n    display(\"=== Starting Chat Client ===\\n\")\n    try:\n        chat_client = chat.EnhancedChatClient()\n        chat_client.run()\n    except (SystemExit, KeyboardInterrupt):\n        pass\n    except Exception as e:\n        display(f\"\\nError in Chat: {str(e)}\\n\")\n    display(\"\\nReturning to launcher...\")\n    clear()\n\n\ndef gui_show_credits():\n    clear()\n    display(\"===============================================\\n\")\n    display(\"                Our Legacy Team\\n\")\n    display(\"===============================================\\n\")\n    display(\"Andy64lol - Project Lead, Developer\\n\")\n    display(\"\\nBtw if you're interested in joining please contact us!\\n\")\n    display(\"\\nReturning to launcher...\")\n    clear()\n\n\n# Override launcher functions to stay within the same process/GUI\nlauncher.run_main = gui_run_main\nlauncher.run_storyland = gui_run_storyland\nlauncher.run_storywrite = gui_run_storywrite\nlauncher.run_chat = gui_run_chat\nlauncher.show_credits = gui_show_credits\n\n\ndef run_full_gui():\n    \"\"\"Run the complete integrated GUI\"\"\"\n    clear()\n    display(\"=== Our Legacy===\\n\")\n    display(\"Welcome to the unified interface for all components.\\n\\n\")\n\n    try:\n        launcher.main_menu()\n    except (LauncherExit, SystemExit):\n        display(\"\\nExiting application...\")\n        exit_gui()\n    except Exception as e:\n        display(f\"\\nFatal error: {str(e)}\\n\")\n        display(\"Press Enter to exit...\")\n        input()\n        exit_gui()\n\n\nif __name__ == \"__main__\":\n    set_theme(\"dark\")\n    gui_run(run_full_gui)","path":null,"size_bytes":4715,"size_tokens":null},"chat.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nChat CLI for Our Legacy\nChat-like interface with clean message display and input separation.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport json\nimport threading\nimport requests\nimport readline\nimport signal\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Tuple\nfrom urllib.parse import quote\n\n# ANSI Color Codes with enhanced styling\nclass Colors:\n    RESET = '\\033[0m'\n    BOLD = '\\033[1m'\n    DIM = '\\033[2m'\n    ITALIC = '\\033[3m'\n    UNDERLINE = '\\033[4m'\n    \n    # Foreground colors\n    BLACK = '\\033[30m'\n    RED = '\\033[31m'\n    GREEN = '\\033[32m'\n    YELLOW = '\\033[33m'\n    BLUE = '\\033[34m'\n    MAGENTA = '\\033[35m'\n    CYAN = '\\033[36m'\n    WHITE = '\\033[37m'\n    \n    # Bright foreground colors\n    BRIGHT_RED = '\\033[91m'\n    BRIGHT_GREEN = '\\033[92m'\n    BRIGHT_YELLOW = '\\033[93m'\n    BRIGHT_BLUE = '\\033[94m'\n    BRIGHT_MAGENTA = '\\033[95m'\n    BRIGHT_CYAN = '\\033[96m'\n    BRIGHT_WHITE = '\\033[97m'\n    \n    # Chat-specific colors\n    CHAT_NAME_SELF = BRIGHT_GREEN + BOLD\n    CHAT_NAME_OTHER = BRIGHT_CYAN\n    CHAT_NAME_SYSTEM = BRIGHT_YELLOW\n    CHAT_TIMESTAMP = DIM + WHITE\n    CHAT_STATUS = BRIGHT_MAGENTA\n    CHAT_DIVIDER = BRIGHT_BLUE\n    CHAT_WELCOME = BRIGHT_CYAN + BOLD\n    CHAT_INPUT = BRIGHT_WHITE\n    CHAT_PROMPT = BRIGHT_GREEN\n\n\ndef clear_screen():\n    \"\"\"Clear the terminal screen.\"\"\"\n    os.system('cls' if os.name == 'nt' else 'clear')\n\ndef get_terminal_width():\n    \"\"\"Get terminal width, default to 80 if cannot determine.\"\"\"\n    try:\n        return os.get_terminal_size().columns\n    except:\n        return 80\n\ndef print_wide_divider(width: Optional[int] = None, color: str = Colors.CHAT_DIVIDER):\n    \"\"\"Print a wide divider line with =============.\"\"\"\n    if width is None:\n        width = get_terminal_width()\n    divider_length = 12  # Fixed length for =============\n    if width < divider_length:\n        divider_length = width\n    \n    # Center the divider\n    padding = (width - divider_length) // 2\n    padding = max(padding, 0)\n    print(f\"{color}{' ' * padding}{'=' * divider_length}{Colors.RESET}\")\n\ndef print_centered_text(text: str, width: Optional[int] = None, color: str = Colors.RESET):\n    \"\"\"Print centered text with wide dividers above and below.\"\"\"\n    if width is None:\n        width = get_terminal_width()\n    \n    # Calculate padding for centering\n    padding = (width - len(text)) // 2\n    padding = max(padding, 0)\n    \n    # Print with wide dividers\n    print_wide_divider(width, Colors.CHAT_DIVIDER)\n    print(f\"{color}{' ' * padding}{text}{Colors.RESET}\")\n    print_wide_divider(width, Colors.CHAT_DIVIDER)\n\ndef print_section_header(title: str, width: Optional[int] = None, color: str = Colors.CHAT_STATUS):\n    \"\"\"Print a section header with centered title and wide dividers.\"\"\"\n    if width is None:\n        width = get_terminal_width()\n    \n    print_wide_divider(width, color)\n    \n    # Center the title\n    padding = (width - len(title)) // 2\n    padding = max(padding, 0)\n    print(f\"{color}{' ' * padding}{title}{Colors.RESET}\")\n    \n    print_wide_divider(width, color)\n\ndef print_chat_divider(width: Optional[int] = None, color: str = Colors.DIM):\n    \"\"\"Print a chat message divider.\"\"\"\n    if width is None:\n        width = get_terminal_width()\n    print(f\"{color}{'=' * width}{Colors.RESET}\")\n\n# Configuration\nPING_URL = \"https://our-legacy.vercel.app/api/ping\"\nSEND_MESSAGE_URL = \"https://our-legacy.vercel.app/api/send_message\"\nCREATE_USER_URL = \"https://our-legacy.vercel.app/api/create_user\"\nGLOBAL_CHAT_URL = \"https://raw.githubusercontent.com/andy64lol/globalchat/refs/heads/main/global_chat.json\"\nUSERS_URL = \"https://raw.githubusercontent.com/andy64lol/globalchat/refs/heads/main/users.json\"\nALIAS_FILE = \"data/saves/username.txt\"\nCOOLDOWN_SECONDS = 20\nAUTO_REFRESH_SECONDS = 10\nBAN_CHECK_SECONDS = 90  # Check ban status every 90 seconds\nMAX_MESSAGE_LENGTH = 300\nMESSAGES_PER_PAGE = 10\nMAX_FETCH_MESSAGES = 10  # Only fetch last 10 messages for performance\n\nclass EnhancedChatClient:\n    def __init__(self):\n        self.alias = None\n        self.last_message_time = 0\n        self.messages: List[Dict] = []\n        self.current_page = 0\n        self.auto_refresh = True\n        self.connection_ok = False\n        self.last_refresh_time = 0\n        self.is_exiting = False\n        self.terminal_width = get_terminal_width()\n        self.last_message_count = 0  # Track displayed messages for incremental updates\n        self.message_queue = []  # Queue for async message updates\n        self.fetch_lock = threading.Lock()  # Lock for thread-safe fetching\n        self.users_list: List[Dict] = []  # Cached users list\n        self.is_banned = False  # Ban status\n        self.last_ban_check = 0  # Last ban check time\n        \n        # Set up terminal resize handler (Unix/Linux only)\n        try:\n            signal.signal(signal.SIGWINCH, self._handle_resize)\n        except (AttributeError, ValueError):\n            # Windows doesn't have SIGWINCH, ignore\n            pass\n        \n        # Load or create alias\n        self.check_alias()\n    \n    def _handle_resize(self, signum, frame):\n        \"\"\"Handle terminal resize event.\"\"\"\n        self.terminal_width = get_terminal_width()\n    \n    def fetch_users(self) -> List[Dict]:\n        \"\"\"Fetch users list from repository.\"\"\"\n        try:\n            response = requests.get(USERS_URL, timeout=10)\n            if response.status_code == 200:\n                data = response.json()\n                if isinstance(data, list):\n                    self.users_list = data\n                    return data\n        except Exception as e:\n            print(f\"{Colors.BRIGHT_RED}Error fetching users: {e}{Colors.RESET}\")\n        return []\n    \n    def check_alias_exists(self, alias: str) -> bool:\n        \"\"\"Check if alias already exists in users.json.\"\"\"\n        # Use the API endpoint for more reliable checking\n        try:\n            response = requests.get(\n                f\"{CREATE_USER_URL}?alias={quote(alias)}\",\n                timeout=10\n            )\n            if response.status_code == 200:\n                data = response.json()\n                return data.get('exists', False)\n        except Exception as e:\n            print(f\"{Colors.BRIGHT_YELLOW}Warning: Could not check alias availability online, falling back to local check{Colors.RESET}\")\n        \n        # Fallback to local check\n        users = self.fetch_users()\n        for user in users:\n            if isinstance(user, dict) and user.get('alias', '').lower() == alias.lower():\n                return True\n        return False\n    \n    def is_user_banned(self, alias: str) -> bool:\n        \"\"\"Check if user is banned.\"\"\"\n        users = self.fetch_users()\n        for user in users:\n            if isinstance(user, dict) and user.get('alias', '').lower() == alias.lower():\n                return user.get('blacklisted', False)\n        return False\n    \n    def check_alias(self):\n        \"\"\"Check if alias exists, if not create one.\"\"\"\n        if os.path.exists(ALIAS_FILE):\n            try:\n                with open(ALIAS_FILE, 'r') as f:\n                    self.alias = f.read().strip()\n                # Check if banned on startup\n                if self.is_user_banned(self.alias):\n                    print(f\"{Colors.BRIGHT_RED}You are banned from the chat.{Colors.RESET}\")\n                    sys.exit(1)\n                self.show_welcome_back()\n            except Exception as e:\n                print(f\"{Colors.BRIGHT_RED}Error loading alias: {e}{Colors.RESET}\")\n                self.create_alias()\n        else:\n            self.create_alias()\n    \n    def show_welcome_back(self):\n        \"\"\"Show enhanced welcome back message.\"\"\"\n        clear_screen()\n        width = self.terminal_width\n        \n        print(f\"\\n\\n\")\n        print_centered_text(\"OUR LEGACY CHAT\", width, Colors.CHAT_WELCOME)\n        print(f\"\\n\")\n        print_centered_text(f\"Welcome back, {self.alias}!\", width, Colors.BRIGHT_GREEN)\n        print(f\"\\n\")\n        print_centered_text(\"Connecting to chat server...\", width, Colors.DIM)\n        \n        # Quick connection indicator (0.1s for responsiveness)\n        print(f\"{Colors.DIM}...{Colors.RESET}\", flush=True)\n        time.sleep(0.1)\n        clear_screen()\n    \n    def create_alias(self):\n        \"\"\"Create a new alias with enhanced UI.\"\"\"\n        clear_screen()\n        width = self.terminal_width\n        \n        print(f\"\\n\\n\")\n        print_centered_text(\"OUR LEGACY CHAT\", width, Colors.CHAT_WELCOME)\n        print(f\"\\n\")\n        print_centered_text(\"Create Your Chat Identity\", width, Colors.BRIGHT_WHITE)\n        print(f\"\\n\")\n        print_wide_divider(width, Colors.DIM)\n        \n        while True:\n            print(f\"\\n{Colors.BRIGHT_GREEN}Enter your chat alias (max 20 characters):{Colors.RESET}\")\n            print(f\"{Colors.DIM}Allowed: letters, numbers, spaces, underscores, hyphens{Colors.RESET}\")\n            print(f\"\\n{Colors.BRIGHT_CYAN}Alias: {Colors.RESET}\", end='')\n            \n            alias = input().strip()\n            \n            if not alias:\n                print(f\"{Colors.BRIGHT_RED}Alias cannot be empty.{Colors.RESET}\")\n                continue\n            \n            if len(alias) > 20:\n                print(f\"{Colors.BRIGHT_RED}Alias too long (max 20 characters).{Colors.RESET}\")\n                continue\n            \n            if not all(c.isalnum() or c in '_- ' for c in alias):\n                print(f\"{Colors.BRIGHT_RED}Only letters, numbers, spaces, underscores, and hyphens.{Colors.RESET}\")\n                continue\n            \n            # Check if alias already exists\n            if self.check_alias_exists(alias):\n                print(f\"{Colors.BRIGHT_RED}Username '{alias}' is already taken. Please choose another.{Colors.RESET}\")\n                continue\n            \n            # Show confirmation\n            print(f\"\\n{Colors.BRIGHT_GREEN}You chose: {Colors.BRIGHT_CYAN}{alias}{Colors.RESET}\")\n            print(f\"\\n{Colors.DIM}Confirm this alias? (y/n): {Colors.RESET}\", end='')\n            \n            confirm = input().lower().strip()\n            \n            if confirm == 'y':\n                self.alias = alias\n                self.save_alias()\n                break\n            else:\n                print(f\"{Colors.YELLOW}Let's try again.{Colors.RESET}\")\n                continue\n    \n    def register_user_online(self, alias: str) -> bool:\n        \"\"\"Register new user to GitHub repository via API.\"\"\"\n        max_retries = 3\n        for attempt in range(max_retries):\n            try:\n                payload = {\n                    \"alias\": alias,\n                    \"metadata\": {\n                        \"permissions\": \"user\"\n                    }\n                }\n                \n                response = requests.post(\n                    CREATE_USER_URL,\n                    json=payload,\n                    headers={\"Content-Type\": \"application/json\"},\n                    timeout=15\n                )\n                \n                if response.status_code == 201:\n                    return True\n                elif response.status_code == 409:\n                    # User already exists - this is actually fine for recovery\n                    print(f\"{Colors.BRIGHT_YELLOW}Note: Username already registered online{Colors.RESET}\")\n                    return True\n                else:\n                    error_msg = f\"HTTP {response.status_code}\"\n                    try:\n                        error_data = response.json()\n                        error_msg = error_data.get('error', error_msg)\n                    except:\n                        pass\n                    print(f\"{Colors.BRIGHT_YELLOW}Registration attempt {attempt + 1} failed: {error_msg}{Colors.RESET}\")\n                    \n            except Exception as e:\n                print(f\"{Colors.BRIGHT_YELLOW}Registration attempt {attempt + 1} error: {e}{Colors.RESET}\")\n            \n            if attempt < max_retries - 1:\n                time.sleep(1)  # Wait before retry\n        \n        return False\n\n    def save_alias(self):\n        \"\"\"Save alias to file with enhanced confirmation and online registration.\"\"\"\n        try:\n            if self.alias is None:\n                return\n            \n            # First, register online (enforce username uniqueness)\n            print(f\"\\n{Colors.DIM}Registering username online...{Colors.RESET}\")\n            online_success = self.register_user_online(self.alias)\n            \n            if not online_success:\n                print(f\"{Colors.BRIGHT_RED}Failed to register username online. Please try again later.{Colors.RESET}\")\n                # Don't exit - allow local-only mode for offline usage\n                print(f\"{Colors.BRIGHT_YELLOW}Continuing in local-only mode...{Colors.RESET}\")\n                time.sleep(1)\n            \n            os.makedirs(os.path.dirname(ALIAS_FILE), exist_ok=True)\n            \n            with open(ALIAS_FILE, 'w') as f:\n                f.write(self.alias)\n            \n            # Set read-only permissions\n            try:\n                os.chmod(ALIAS_FILE, 0o444)\n            except Exception:\n                pass  # Permissions may not work on all systems\n            \n            # Try to make immutable (Linux only)\n            try:\n                if os.name != 'nt':  # chattr is Linux-specific\n                    os.system(f'chattr +i \"{ALIAS_FILE}\" 2>/dev/null')\n            except:\n                pass\n            \n            # Enhanced success message\n            clear_screen()\n            width = self.terminal_width\n            \n            print(f\"\\n\\n\")\n            print_centered_text(\"ALIAS CREATED\", width, Colors.BRIGHT_GREEN)\n            print(f\"\\n\")\n            print_centered_text(f\"Welcome, {self.alias}!\", width, Colors.BRIGHT_CYAN)\n            print(f\"\\n\")\n            if online_success:\n                print_centered_text(\"Your identity is now secured and registered.\", width, Colors.DIM)\n            else:\n                print_centered_text(\"Your identity is saved locally (offline mode).\", width, Colors.BRIGHT_YELLOW)\n            print(f\"\\n\")\n            print_centered_text(\"Entering chat...\", width, Colors.DIM)\n            \n            # Minimal delay for user to read (0.1s)\n            time.sleep(0.1)\n            \n        except Exception as e:\n            print(f\"{Colors.BRIGHT_RED}Error saving alias: {e}{Colors.RESET}\")\n            sys.exit(1)\n    \n    def check_connection(self) -> bool:\n        \"\"\"Check if server is reachable.\"\"\"\n        try:\n            response = requests.get(PING_URL, timeout=5)\n            self.connection_ok = response.status_code == 200\n            return self.connection_ok\n        except:\n            self.connection_ok = False\n            return False\n    \n    def fetch_messages(self) -> bool:\n        \"\"\"Fetch messages from global chat - optimized for incremental updates.\"\"\"\n        with self.fetch_lock:\n            try:\n                response = requests.get(GLOBAL_CHAT_URL, timeout=10)\n                \n                if response.status_code == 200:\n                    data = response.json()\n                    \n                    # Handle different JSON structures\n                    if isinstance(data, dict):\n                        all_messages = data.get('messages', [])\n                    elif isinstance(data, list):\n                        all_messages = data\n                    else:\n                        all_messages = []\n                    \n                    # Only take last N messages for performance\n                    if len(all_messages) > MAX_FETCH_MESSAGES:\n                        all_messages = all_messages[-MAX_FETCH_MESSAGES:]\n                    \n                    # Normalize messages\n                    normalized = []\n                    for msg in all_messages:\n                        if isinstance(msg, dict):\n                            normalized.append(msg)\n                        elif isinstance(msg, str):\n                            try:\n                                parsed = json.loads(msg)\n                                if isinstance(parsed, dict):\n                                    normalized.append(parsed)\n                                else:\n                                    normalized.append({\n                                        'author': 'System',\n                                        'content': str(parsed),\n                                        'timestamp': int(time.time() * 1000)\n                                    })\n                            except:\n                                normalized.append({\n                                    'author': 'System',\n                                    'content': msg,\n                                    'timestamp': int(time.time() * 1000)\n                                })\n                    \n                    # Atomic update: check, update state, and queue in one operation\n                    old_count = len(self.messages)\n                    has_changes = normalized != self.messages\n                    \n                    if has_changes:\n                        self.messages = normalized\n                        self.last_refresh_time = time.time()\n                        # Queue new messages for display\n                        new_count = len(normalized)\n                        if new_count > old_count:\n                            # Only queue truly new messages\n                            self.message_queue.extend(normalized[old_count:])\n                        elif new_count < old_count:\n                            # Messages were deleted/archived, clear queue and refresh all\n                            self.message_queue = []\n                    \n                    return has_changes\n                    \n                return False\n                \n            except Exception as e:\n                return False\n    \n    def display_new_messages(self):\n        \"\"\"Display only new messages from queue (incremental update).\"\"\"\n        if not self.message_queue:\n            return\n        \n        width = self.terminal_width\n        \n        while self.message_queue:\n            msg = self.message_queue.pop(0)\n            \n            if isinstance(msg, dict):\n                author = msg.get('author', 'Unknown')\n                content = msg.get('content', '')\n                timestamp = msg.get('timestamp', int(time.time() * 1000))\n            else:\n                author = 'Unknown'\n                content = str(msg)\n                timestamp = int(time.time() * 1000)\n            \n            # Format timestamp\n            time_str = self.format_timestamp(timestamp)\n            \n            # Determine message style\n            if author == self.alias:\n                name_color = Colors.CHAT_NAME_SELF\n                prefix = f\"{Colors.DIM}[{time_str}]{Colors.RESET} {name_color}{author}{Colors.RESET}: \"\n            elif author == 'System' or author == 'Unknown':\n                name_color = Colors.CHAT_NAME_SYSTEM\n                prefix = f\"{Colors.DIM}[{time_str}]{Colors.RESET} {name_color}*** {author}{Colors.RESET}: \"\n            else:\n                name_color = Colors.CHAT_NAME_OTHER\n                prefix = f\"{Colors.DIM}[{time_str}]{Colors.RESET} {name_color}{author}{Colors.RESET}: \"\n            \n            print(f\"{prefix}{Colors.BRIGHT_WHITE}{content}{Colors.RESET}\")\n            print_chat_divider(width, Colors.DIM)\n    \n    def format_timestamp(self, timestamp_ms: int) -> str:\n        \"\"\"Format timestamp for display.\"\"\"\n        try:\n            dt = datetime.fromtimestamp(timestamp_ms / 1000)\n            now = datetime.now()\n            \n            if dt.date() == now.date():\n                return dt.strftime(\"%H:%M:%S\")\n            elif (now.date() - dt.date()).days == 1:\n                return f\"Yesterday {dt.strftime('%H:%M')}\"\n            else:\n                return dt.strftime(\"%m/%d %H:%M\")\n        except:\n            return \"??:??\"\n    \n    def display_messages(self, show_header: bool = True, incremental: bool = False):\n        \"\"\"Display messages in a chat-like format with clean separation.\n        \n        Args:\n            show_header: Whether to show header and clear screen\n            incremental: If True, only display new messages from queue\n        \"\"\"\n        # Handle incremental updates (no clear, just append)\n        if incremental and not show_header:\n            self.display_new_messages()\n            return\n        \n        # Full refresh - only clear when explicitly requested for header mode\n        # This reduces flickering significantly\n        if show_header:\n            clear_screen()\n        \n        width = self.terminal_width\n        \n        # Header with connection status\n        if show_header:\n            status_icon = f\"{Colors.BRIGHT_GREEN}â—{Colors.RESET}\" if self.connection_ok else f\"{Colors.BRIGHT_RED}â—{Colors.RESET}\"\n            status_text = f\"OUR LEGACY CHAT {status_icon}\"\n            \n            print_section_header(status_text, width, Colors.CHAT_STATUS)\n            print(f\"{Colors.DIM}Connected as: {self.alias}{Colors.RESET}\")\n            print_chat_divider(width, Colors.CHAT_STATUS)\n        \n        if not self.messages:\n            print(f\"\\n{Colors.DIM}No messages yet. Be the first to say something!{Colors.RESET}\\n\")\n            self.last_message_count = 0\n            return\n        \n        # Always show last page (most recent messages)\n        total_messages = len(self.messages)\n        total_pages = max((total_messages + MESSAGES_PER_PAGE - 1) // MESSAGES_PER_PAGE, 1)\n        self.current_page = min(self.current_page, total_pages - 1)  # Ensure valid page\n        self.current_page = max(0, self.current_page)  # Ensure non-negative\n        \n        start_idx = self.current_page * MESSAGES_PER_PAGE\n        end_idx = min(start_idx + MESSAGES_PER_PAGE, total_messages)\n        \n        # Ensure valid indices\n        start_idx = max(0, min(start_idx, total_messages - 1)) if total_messages > 0 else 0\n        end_idx = max(start_idx, min(end_idx, total_messages))\n        \n        # Display messages\n        displayed_count = 0\n        for idx in range(start_idx, end_idx):\n            if idx >= len(self.messages):\n                break\n                \n            msg = self.messages[idx]\n            \n            if isinstance(msg, dict):\n                author = msg.get('author', 'Unknown')\n                content = msg.get('content', '')\n                timestamp = msg.get('timestamp', int(time.time() * 1000))\n            else:\n                author = 'Unknown'\n                content = str(msg)\n                timestamp = int(time.time() * 1000)\n            \n            # Format timestamp\n            time_str = self.format_timestamp(timestamp)\n            \n            # Determine message style\n            if author == self.alias:\n                # Own message\n                name_color = Colors.CHAT_NAME_SELF\n                prefix = f\"{Colors.DIM}[{time_str}]{Colors.RESET} {name_color}{author}{Colors.RESET}: \"\n            elif author == 'System' or author == 'Unknown':\n                # System message\n                name_color = Colors.CHAT_NAME_SYSTEM\n                prefix = f\"{Colors.DIM}[{time_str}]{Colors.RESET} {name_color}*** {author}{Colors.RESET}: \"\n            else:\n                # Other user's message\n                name_color = Colors.CHAT_NAME_OTHER\n                prefix = f\"{Colors.DIM}[{time_str}]{Colors.RESET} {name_color}{author}{Colors.RESET}: \"\n            \n            # Display message in list-like format\n            print(f\"{prefix}{Colors.BRIGHT_WHITE}{content}{Colors.RESET}\")\n            displayed_count += 1\n            \n            # Message separator (keeping the requested =================)\n            if idx < end_idx - 1 and displayed_count < MESSAGES_PER_PAGE:\n                print_chat_divider(width, Colors.DIM)\n        \n        # Update last message count\n        self.last_message_count = total_messages\n    \n    def display_input_area(self):\n        \"\"\"Display the compact input area.\"\"\"\n        width = self.terminal_width\n        \n        # Print compact input area\n        print()\n        print_chat_divider(width, Colors.CHAT_STATUS)\n    \n    def get_cooldown_status(self) -> int:\n        \"\"\"Get remaining cooldown time.\"\"\"\n        current_time = time.time()\n        time_since_last = current_time - self.last_message_time\n        \n        if time_since_last < COOLDOWN_SECONDS:\n            return COOLDOWN_SECONDS - int(time_since_last)\n        return 0\n    \n    def send_message(self, content: str) -> bool:\n        \"\"\"Send a message to the server.\"\"\"\n        # Check cooldown\n        cooldown = self.get_cooldown_status()\n        if cooldown > 0:\n            print(f\"{Colors.BRIGHT_YELLOW}Please wait {cooldown} seconds before sending another message.{Colors.RESET}\")\n            return False\n        \n        # Check message length\n        if len(content) > MAX_MESSAGE_LENGTH:\n            print(f\"{Colors.BRIGHT_RED}Message too long (max {MAX_MESSAGE_LENGTH} characters).{Colors.RESET}\")\n            return False\n        \n        if not content.strip():\n            print(f\"{Colors.BRIGHT_YELLOW}Message cannot be empty.{Colors.RESET}\")\n            return False\n        \n        try:\n            payload = {\n                \"message\": content,\n                \"author\": self.alias\n            }\n            \n            response = requests.post(\n                SEND_MESSAGE_URL,\n                json=payload,\n                headers={\"Content-Type\": \"application/json\"},\n                timeout=10\n            )\n            \n            if response.status_code == 200:\n                self.last_message_time = time.time()\n                return True\n            else:\n                error_msg = f\"HTTP {response.status_code}\"\n                if response.text:\n                    try:\n                        error_data = response.json()\n                        error_msg = error_data.get('error', error_msg)\n                    except:\n                        pass\n                print(f\"{Colors.BRIGHT_RED}Failed to send: {error_msg}{Colors.RESET}\")\n                return False\n                \n        except Exception as e:\n            print(f\"{Colors.BRIGHT_RED}Error: {e}{Colors.RESET}\")\n            return False\n    \n    def show_help(self):\n        \"\"\"Show help information with wide dividers.\"\"\"\n        clear_screen()\n        width = self.terminal_width\n        \n        print(f\"\\n\")\n        print_centered_text(\"CHAT COMMANDS HELP\", width, Colors.BRIGHT_CYAN)\n        \n        print(f\"\\n{Colors.BRIGHT_WHITE}Basic Commands:{Colors.RESET}\")\n        print_chat_divider(width, Colors.DIM)\n        print(f\"  {Colors.BRIGHT_GREEN}/r{Colors.RESET}           - {Colors.DIM}Refresh messages{Colors.RESET}\")\n        print(f\"  {Colors.BRIGHT_GREEN}/next{Colors.RESET}       - {Colors.DIM}Next page{Colors.RESET}\")\n        print(f\"  {Colors.BRIGHT_GREEN}/prev{Colors.RESET}       - {Colors.DIM}Previous page{Colors.RESET}\")\n        print(f\"  {Colors.BRIGHT_GREEN}/auto{Colors.RESET}       - {Colors.DIM}Toggle auto-refresh{Colors.RESET}\")\n        print(f\"  {Colors.BRIGHT_GREEN}/clear{Colors.RESET}      - {Colors.DIM}Clear screen{Colors.RESET}\")\n        print(f\"  {Colors.BRIGHT_GREEN}/status{Colors.RESET}     - {Colors.DIM}Show connection status{Colors.RESET}\")\n        print(f\"  {Colors.BRIGHT_GREEN}/exit{Colors.RESET}      - {Colors.DIM}Quit chat{Colors.RESET}\")\n        print(f\"  {Colors.BRIGHT_GREEN}/help{Colors.RESET}       - {Colors.DIM}Show this help{Colors.RESET}\")\n        \n        print(f\"\\n{Colors.BRIGHT_YELLOW}Message Format:{Colors.RESET}\")\n        print_chat_divider(width, Colors.DIM)\n        print(f\"  {Colors.CHAT_NAME_OTHER}Other users{Colors.RESET} - Messages from others\")\n        print(f\"  {Colors.CHAT_NAME_SELF}You{Colors.RESET}        - Your messages (with >>> prefix)\")\n        print(f\"  {Colors.CHAT_NAME_SYSTEM}System{Colors.RESET}     - System notifications\")\n        \n        print(f\"\\n{Colors.BRIGHT_MAGENTA}Tips:{Colors.RESET}\")\n        print_chat_divider(width, Colors.DIM)\n        print(f\"  {Colors.DIM}â€¢ Press Ctrl+C to exit anytime{Colors.RESET}\")\n        print(f\"  {Colors.DIM}â€¢ Use â†‘/â†“ arrow keys for message history{Colors.RESET}\")\n        print(f\"  {Colors.DIM}â€¢ Cooldown: {COOLDOWN_SECONDS} seconds between messages{Colors.RESET}\")\n        print(f\"  {Colors.DIM}â€¢ Auto-refresh: {AUTO_REFRESH_SECONDS}s interval{Colors.RESET}\")\n        print(f\"  {Colors.DIM}â€¢ Max message length: {MAX_MESSAGE_LENGTH} characters{Colors.RESET}\")\n        \n        print(f\"\\n{Colors.DIM}Press Enter to return to chat...{Colors.RESET}\")\n        input()\n    \n    def ban_check_thread(self):\n        \"\"\"Background thread for checking ban status every 90 seconds.\"\"\"\n        while not self.is_exiting:\n            current_time = time.time()\n            if current_time - self.last_ban_check >= BAN_CHECK_SECONDS:\n                try:\n                    if self.alias and self.is_user_banned(self.alias):\n                        self.is_banned = True\n                        print(f\"\\n{Colors.BRIGHT_RED}You have been banned from the chat. Exiting...{Colors.RESET}\")\n                        self.is_exiting = True\n                        break\n                    self.last_ban_check = current_time\n                except:\n                    pass\n            time.sleep(5)  # Check every 5 seconds if it's time to check ban\n    \n    def auto_refresh_thread(self):\n        \"\"\"Background thread for auto-refreshing messages - non-blocking.\"\"\"\n        while not self.is_exiting:\n            if self.auto_refresh:\n                current_time = time.time()\n                if current_time - self.last_refresh_time >= AUTO_REFRESH_SECONDS:\n                    try:\n                        if self.fetch_messages():\n                            # Queue new messages for display (don't block input)\n                            # Main loop will display them on next iteration\n                            pass\n                    except:\n                        pass\n            # Shorter sleep for more responsive updates\n            time.sleep(0.5)\n    \n    def run(self):\n        \"\"\"Main chat loop with enhanced initialization - optimized.\"\"\"\n        # Start with connection check\n        if not self.check_connection():\n            print(f\"{Colors.BRIGHT_RED}Warning: Cannot connect to server. Some features may be limited.{Colors.RESET}\")\n            time.sleep(1)\n        \n        # Display initial messages\n        self.fetch_messages()\n        \n        # Start background threads\n        auto_refresh_thread = threading.Thread(target=self.auto_refresh_thread, daemon=True)\n        ban_check_thread = threading.Thread(target=self.ban_check_thread, daemon=True)\n        auto_refresh_thread.start()\n        ban_check_thread.start()\n        \n        # Main loop\n        while not self.is_exiting:\n            try:\n                # Display messages and input area\n                self.display_messages(show_header=True)\n                self.display_input_area()\n                \n                # Display prompt\n                cooldown = self.get_cooldown_status()\n                if cooldown > 0:\n                    prompt = f\"{Colors.BRIGHT_YELLOW}(Wait {cooldown}s) Enter message or /help: {Colors.RESET}\"\n                else:\n                    prompt = f\"{Colors.BRIGHT_GREEN}Enter message or /help: {Colors.RESET}\"\n                \n                print(f\"{prompt}\", end='')\n                sys.stdout.flush()\n                \n                # Get user input\n                try:\n                    user_input = input().strip()\n                except EOFError:\n                    # Handle Ctrl+D\n                    print(f\"\\n{Colors.BRIGHT_CYAN}Goodbye!{Colors.RESET}\")\n                    break\n                \n                if not user_input:\n                    # Just refresh display\n                    continue\n                \n                # Handle commands\n                if user_input.startswith('/'):\n                    cmd = user_input.lower().strip()\n                    \n                    if cmd == '/r' or cmd == '/refresh':\n                        print(f\"{Colors.DIM}Refreshing messages...{Colors.RESET}\")\n                        if self.fetch_messages():\n                            self.display_messages(show_header=True)\n                            self.display_input_area()\n                        else:\n                            print(f\"{Colors.BRIGHT_YELLOW}No new messages{Colors.RESET}\")\n                        continue\n                    \n                    elif cmd == '/next' or cmd == '/n':\n                        total_pages = max((len(self.messages) + MESSAGES_PER_PAGE - 1) // MESSAGES_PER_PAGE, 1)\n                        if self.current_page < total_pages - 1:\n                            self.current_page += 1\n                        else:\n                            print(f\"{Colors.BRIGHT_YELLOW}Already at last page{Colors.RESET}\")\n                            time.sleep(0.5)\n                        self.display_messages(show_header=True)\n                        self.display_input_area()\n                        continue\n                    \n                    elif cmd == '/prev' or cmd == '/p':\n                        if self.current_page > 0:\n                            self.current_page -= 1\n                        else:\n                            print(f\"{Colors.BRIGHT_YELLOW}Already at first page{Colors.RESET}\")\n                            time.sleep(0.5)\n                        self.display_messages(show_header=True)\n                        self.display_input_area()\n                        continue\n                    \n                    elif cmd == '/auto':\n                        self.auto_refresh = not self.auto_refresh\n                        status = \"ON\" if self.auto_refresh else \"OFF\"\n                        color = Colors.BRIGHT_CYAN if self.auto_refresh else Colors.BRIGHT_YELLOW\n                        print(f\"{color}Auto-refresh: {status}{Colors.RESET}\")\n                        time.sleep(0.5)\n                        continue\n                    \n                    elif cmd == '/clear' or cmd == '/c':\n                        clear_screen()\n                        self.display_messages(show_header=True)\n                        self.display_input_area()\n                        continue\n                    \n                    elif cmd == '/status' or cmd == '/s':\n                        if self.check_connection():\n                            print(f\"{Colors.BRIGHT_GREEN}âœ“ Connected to server{Colors.RESET}\")\n                        else:\n                            print(f\"{Colors.BRIGHT_RED}âœ— Cannot connect to server{Colors.RESET}\")\n                        time.sleep(1)\n                        continue\n                    \n                    elif cmd == '/exit' or cmd == '/quit' or cmd == '/q':\n                        print(f\"\\n{Colors.BRIGHT_CYAN}Goodbye!{Colors.RESET}\")\n                        self.is_exiting = True\n                        break\n                    \n                    elif cmd == '/help' or cmd == '/h':\n                        self.show_help()\n                        self.display_messages(show_header=True)\n                        self.display_input_area()\n                        continue\n                    \n                    else:\n                        print(f\"{Colors.BRIGHT_RED}Unknown command: {user_input}{Colors.RESET}\")\n                        print(f\"{Colors.DIM}Type /help for available commands{Colors.RESET}\")\n                        time.sleep(1)\n                        continue\n                \n                # Send message\n                if self.send_message(user_input):\n                    # Auto-refresh after sending\n                    time.sleep(0.5)  # Wait for server to update\n                    self.fetch_messages()\n                    # Display updated messages\n                    self.display_messages(show_header=True)\n                    self.display_input_area()\n                else:\n                    # Wait a moment for user to read error message\n                    time.sleep(1)\n                \n            except KeyboardInterrupt:\n                print(f\"\\n{Colors.BRIGHT_CYAN}Goodbye!{Colors.RESET}\")\n                self.is_exiting = True\n                break\n            except Exception as e:\n                print(f\"\\n{Colors.BRIGHT_RED}Unexpected error: {e}{Colors.RESET}\")\n                time.sleep(1)\n                continue\n        \n        # Cleanup\n        self.is_exiting = True\n        time.sleep(0.5)  # Give threads time to exit\n\n\ndef main():\n    \"\"\"Entry point.\"\"\"\n    chat = EnhancedChatClient()\n    \n    try:\n        chat.run()\n    except KeyboardInterrupt:\n        print(f\"\\n{Colors.BRIGHT_CYAN}Goodbye!{Colors.RESET}\")\n    except Exception as e:\n        print(f\"{Colors.BRIGHT_RED}Fatal error: {e}{Colors.RESET}\")\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n","path":null,"size_bytes":37082,"size_tokens":null},"py2gui.py":{"content":"\"\"\"\nPy2GUI - Enhanced Python Terminal-style GUI\nFixed version: Fixed potential errors and issues\n\"\"\"\nimport tkinter as tk\nfrom tkinter import scrolledtext, simpledialog, Menu, Frame, Entry, Button, StringVar, font\nimport queue\nimport threading\nimport traceback\nimport re\nimport json\nimport os\nimport sys\nfrom typing import Callable, Any, Optional, List, Tuple, Dict, Set\nimport warnings\n\n\nclass Py2GUI:\n    def __init__(self, title: str = \"Py2GUI\", width: int = 80, height: int = 20, config_file: str = \"config.json\"):\n        \"\"\"Initialize Py2GUI instance\"\"\"\n        self.root = tk.Tk()\n        self.root.title(title)\n        self.root.resizable(True, True)\n        self.width = width\n        self.height = height\n        self.running = True\n        self.config_file = config_file\n        \n        # Load configuration\n        self.config = self._load_config()\n        \n        # Extended ANSI color configuration\n        self.ansi_colors = {\n            # Basic colors\n            '30': '#000000',        # Black\n            '31': '#ff0000',        # Red\n            '32': '#00ff00',        # Green\n            '33': '#ffff00',        # Yellow\n            '34': '#0000ff',        # Blue\n            '35': '#ff00ff',        # Magenta\n            '36': '#00ffff',        # Cyan\n            '37': '#ffffff',        # White\n            \n            # Bright colors\n            '90': '#808080',        # Gray\n            '91': '#ff8080',        # Bright red\n            '92': '#80ff80',        # Bright green\n            '93': '#ffff80',        # Bright yellow\n            '94': '#8080ff',        # Bright blue\n            '95': '#ff80ff',        # Bright magenta\n            '96': '#80ffff',        # Bright cyan\n            '97': '#ffffff',        # Bright white\n            \n            # Background colors\n            '40': '#1a1a1a',        # Black background\n            '41': '#ff0000',        # Red background\n            '42': '#00ff00',        # Green background\n            '43': '#ffff00',        # Yellow background\n            '44': '#0000ff',        # Blue background\n            '45': '#ff00ff',        # Magenta background\n            '46': '#00ffff',        # Cyan background\n            '47': '#ffffff',        # White background\n            \n            # Extended 256 colors\n            '38;5;0': '#000000',    # Black\n            '38;5;1': '#800000',    # Dark red\n            '38;5;2': '#008000',    # Dark green\n            '38;5;3': '#808000',    # Dark yellow\n            '38;5;4': '#000080',    # Dark blue\n            '38;5;5': '#800080',    # Dark magenta\n            '38;5;6': '#008080',    # Dark cyan\n            '38;5;7': '#c0c0c0',    # Light gray\n            '38;5;8': '#808080',    # Dark gray\n            '38;5;9': '#ff0000',    # Red\n            '38;5;10': '#00ff00',   # Green\n            '38;5;11': '#ffff00',   # Yellow\n            '38;5;12': '#0000ff',   # Blue\n            '38;5;13': '#ff00ff',   # Magenta\n            '38;5;14': '#00ffff',   # Cyan\n            '38;5;15': '#ffffff',   # White\n            \n            # Extended background colors\n            '48;5;0': '#000000',    # Black background\n            '48;5;1': '#800000',    # Dark red background\n            '48;5;2': '#008000',    # Dark green background\n            '48;5;3': '#808000',    # Dark yellow background\n            '48;5;4': '#000080',    # Dark blue background\n            '48;5;5': '#800080',    # Dark magenta background\n            '48;5;6': '#008080',    # Dark cyan background\n            '48;5;7': '#c0c0c0',    # Light gray background\n            \n            # True Color support\n            '38;2;0;0;0': '#000000',    # Black\n            '38;2;255;0;0': '#ff0000',  # Red\n            '38;2;0;255;0': '#00ff00',  # Green\n            '38;2;0;0;255': '#0000ff',  # Blue\n        }\n        \n        # Color name to hex mapping\n        self.color_name_to_hex = {\n            'black': '#000000',\n            'red': '#ff0000',\n            'green': '#00ff00',\n            'yellow': '#ffff00',\n            'blue': '#0000ff',\n            'magenta': '#ff00ff',\n            'cyan': '#00ffff',\n            'white': '#ffffff',\n            'gray': '#808080',\n            'bright red': '#ff8080',\n            'bright green': '#80ff80',\n            'bright yellow': '#ffff80',\n            'bright blue': '#8080ff',\n            'bright magenta': '#ff80ff',\n            'bright cyan': '#80ffff',\n            'bright white': '#ffffff',\n            'orange': '#ff8000',\n            'purple': '#8000ff',\n            'pink': '#ff80ff',\n            'brown': '#804000',\n            'dark gray': '#404040',\n            'light gray': '#c0c0c0',\n        }\n        \n        # Available fonts\n        try:\n            self.available_fonts = font.families()\n        except Exception:\n            self.available_fonts = [\"Courier\", \"Consolas\", \"Monaco\", \"Menlo\"]\n            warnings.warn(f\"Could not load font families, using fallback fonts: {self.available_fonts}\")\n        \n        # Current text style state\n        self.current_style = {\n            'font': ('Courier', 10, 'normal'),\n            'foreground': 'white',\n            'background': 'black',\n            'underline': False,\n            'strikethrough': False\n        }\n        \n        # Defined text tags\n        self.tag_names: Set[str] = set()\n        \n        # Handle window close\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.exit)\n        \n        # Main frame\n        self.main_frame = Frame(self.root)\n        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Output area\n        self.text_area = scrolledtext.ScrolledText(\n            self.main_frame,\n            wrap=tk.WORD,\n            width=width,\n            height=height,\n            font=(\"Courier\", 10),\n            bg=\"black\",\n            fg=\"white\",\n            insertbackground=\"white\"\n        )\n        self.text_area.pack(padx=5, pady=5, fill=tk.BOTH, expand=True)\n        self.text_area.config(state=tk.DISABLED)\n        \n        # Configure default tag\n        self.text_area.tag_configure(\"default\", \n            font=(\"Courier\", 10, \"normal\"),\n            foreground=\"white\",\n            background=\"black\"\n        )\n        \n        # Configure color tags\n        for code, color_hex in self.ansi_colors.items():\n            # Skip disabled colors\n            if 'disabled_colors' in self.config and code in self.config['disabled_colors']:\n                continue\n                \n            tag_name = f\"ansi_{code}\"\n            if (code.startswith('3') and ';' not in code) or code.startswith('38'):\n                # Foreground color\n                self.text_area.tag_configure(tag_name, foreground=color_hex)\n            elif code.startswith('4') or code.startswith('48'):\n                # Background color\n                self.text_area.tag_configure(tag_name, background=color_hex)\n            self.tag_names.add(tag_name)\n        \n        # Configure style tags\n        self.text_area.tag_configure(\"bold\", font=(\"Courier\", 10, \"bold\"))\n        self.text_area.tag_configure(\"italic\", font=(\"Courier\", 10, \"italic\"))\n        self.text_area.tag_configure(\"underline\", underline=True)\n        self.text_area.tag_configure(\"strikethrough\", overstrike=True)\n        self.text_area.tag_configure(\"reverse\", foreground=\"black\", background=\"white\")\n        \n        # Add style tags to tag set\n        for tag in [\"bold\", \"italic\", \"underline\", \"strikethrough\", \"reverse\"]:\n            self.tag_names.add(tag)\n        \n        # Terminal style input area frame\n        self.input_frame = Frame(self.main_frame)\n        self.input_frame.pack(fill=tk.X, padx=5, pady=5)\n        \n        # Input label\n        self.input_label = tk.Label(self.input_frame, text=\">> \", font=(\"Courier\", 10), fg=\"white\", bg=\"black\")\n        self.input_label.pack(side=tk.LEFT, padx=(0, 5))\n        \n        # Terminal style input field\n        self.input_var = StringVar()\n        self.input_entry = Entry(\n            self.input_frame,\n            textvariable=self.input_var,\n            font=(\"Courier\", 10),\n            bg=\"black\",\n            fg=\"white\",\n            insertbackground=\"white\"\n        )\n        self.input_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))\n        \n        # Send button\n        self.send_button = Button(\n            self.input_frame,\n            text=\"Send\",\n            command=self._on_send_input,\n            font=(\"Courier\", 9)\n        )\n        self.send_button.pack(side=tk.LEFT)\n        \n        # Input queues\n        self.input_queue = queue.Queue()\n        self.type_in_queue = queue.Queue()\n        \n        # Bind Enter key\n        self.input_entry.bind('<Return>', self._on_enter_pressed)\n        \n        # Create menus\n        self._setup_menus()\n    \n    def _load_config(self) -> Dict[str, Any]:\n        \"\"\"Load configuration from JSON file\"\"\"\n        default_config = {\n            \"disabled_menus\": [],\n            \"disabled_views\": [],\n            \"disabled_colors\": [],\n            \"show_clear_button\": True,\n            \"show_demo_button\": True\n        }\n        \n        try:\n            if os.path.exists(self.config_file):\n                with open(self.config_file, 'r', encoding='utf-8') as f:\n                    config = json.load(f)\n                    # Merge with default config\n                    for key, value in default_config.items():\n                        if key not in config:\n                            config[key] = value\n                    return config\n        except (json.JSONDecodeError, IOError, OSError) as e:\n            self._safe_print(f\"Error loading config file: {e}\")\n        except Exception as e:\n            self._safe_print(f\"Unexpected error loading config: {e}\")\n        \n        return default_config\n    \n    def _safe_print(self, message: str) -> None:\n        \"\"\"Safely print message (for initialization and error handling)\"\"\"\n        try:\n            print(message, file=sys.stderr)\n        except Exception:\n            pass  # Ignore print errors\n    \n    def _setup_menus(self) -> None:\n        \"\"\"Set up menu system - simplified to only File and Themes\"\"\"\n        menubar = Menu(self.root)\n        self.root.config(menu=menubar)\n        \n        # File menu\n        file_menu = Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\"File\", menu=file_menu)\n        file_menu.add_command(label=\"Exit\", command=self.exit)\n        \n        # Themes menu (renamed from Colors)\n        themes_menu = Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\"Themes\", menu=themes_menu)\n        themes_menu.add_command(label=\"Default Theme\", command=lambda: self.set_theme(\"default\"))\n        themes_menu.add_command(label=\"Dark Theme\", command=lambda: self.set_theme(\"dark\"))\n        themes_menu.add_command(label=\"Light Theme\", command=lambda: self.set_theme(\"light\"))\n        themes_menu.add_command(label=\"Green on Black\", command=lambda: self.set_theme(\"matrix\"))\n    \n    def _parse_ansi_codes(self, text: str) -> List[Tuple[str, List[str]]]:\n        \"\"\"Parse ANSI escape sequences in text\"\"\"\n        # ANSI escape sequence regex pattern\n        ansi_pattern = re.compile(r'(\\x1b\\[[\\d;]*m)')\n        \n        parts = []\n        last_end = 0\n        current_codes: List[str] = []\n        \n        for match in ansi_pattern.finditer(text):\n            # Add normal text\n            if match.start() > last_end:\n                normal_text = text[last_end:match.start()]\n                if normal_text:\n                    parts.append((normal_text, current_codes.copy()))\n            \n            # Parse ANSI code\n            ansi_code = match.group(0)\n            code_str = ansi_code[2:-1]  # Remove \\x1b[ and m\n            \n            if code_str == '':\n                # Reset all attributes\n                current_codes = ['0']\n            else:\n                codes = code_str.split(';')\n                for code in codes:\n                    if code == '0':\n                        # Reset\n                        current_codes = ['0']\n                    elif code in ['1', '3', '4', '7', '9']:\n                        # Style codes\n                        if code not in current_codes:\n                            if code == '1' and '22' in current_codes:\n                                current_codes.remove('22')\n                            current_codes.append(code)\n                    elif code in ['22', '23', '24', '27', '29']:\n                        # Reset specific styles\n                        reset_map = {'22': '1', '23': '3', '24': '4', '27': '7', '29': '9'}\n                        if reset_map[code] in current_codes:\n                            current_codes.remove(reset_map[code])\n                    elif code in self.ansi_colors or code.startswith('38;') or code.startswith('48;'):\n                        # Color codes\n                        if 'disabled_colors' in self.config and code in self.config['disabled_colors']:\n                            continue\n                            \n                        # Remove same type color codes\n                        if code in ['30', '31', '32', '33', '34', '35', '36', '37',\n                                   '90', '91', '92', '93', '94', '95', '96', '97']:\n                            # Remove other basic foreground colors\n                            for c in list(current_codes):\n                                if c in ['30', '31', '32', '33', '34', '35', '36', '37',\n                                        '90', '91', '92', '93', '94', '95', '96', '97']:\n                                    current_codes.remove(c)\n                        elif code in ['40', '41', '42', '43', '44', '45', '46', '47']:\n                            # Remove other basic background colors\n                            for c in list(current_codes):\n                                if c in ['40', '41', '42', '43', '44', '45', '46', '47']:\n                                    current_codes.remove(c)\n                        elif code.startswith('38;'):\n                            # Remove other foreground colors\n                            for c in list(current_codes):\n                                if c.startswith('38;'):\n                                    current_codes.remove(c)\n                        elif code.startswith('48;'):\n                            # Remove other background colors\n                            for c in list(current_codes):\n                                if c.startswith('48;'):\n                                    current_codes.remove(c)\n                        current_codes.append(code)\n        \n        # Add remaining text\n        if last_end < len(text):\n            remaining_text = text[last_end:]\n            if remaining_text:\n                parts.append((remaining_text, current_codes.copy()))\n        \n        return parts\n    \n    def _get_tags_for_codes(self, codes: List[str]) -> List[str]:\n        \"\"\"Get corresponding tag list based on ANSI codes\"\"\"\n        tags = []\n        \n        for code in codes:\n            if code == '0':\n                # Reset all styles\n                tags = ['default']\n                break\n            elif code in ['1', '3', '4', '7', '9']:\n                # Style tags\n                style_map = {'1': 'bold', '3': 'italic', '4': 'underline', \n                            '7': 'reverse', '9': 'strikethrough'}\n                if code in style_map:\n                    tags.append(style_map[code])\n            elif code in self.ansi_colors or code.startswith('38;') or code.startswith('48;'):\n                # Skip disabled colors\n                if 'disabled_colors' in self.config and code in self.config['disabled_colors']:\n                    continue\n                # Color tags\n                tag_name = f\"ansi_{code}\"\n                if tag_name in self.tag_names:\n                    tags.append(tag_name)\n        \n        return tags if tags else ['default']\n    \n    def _process_escape_sequences(self, text: str) -> str:\n        \"\"\"Process escape sequences like \\n, \\t, etc.\"\"\"\n        # Replace common escape sequences\n        replacements = {\n            '\\\\n': '\\n',\n            '\\\\t': '\\t',\n            '\\\\r': '\\r',\n            '\\\\b': '\\b',\n            '\\\\f': '\\f',\n            '\\\\v': '\\v',\n            '\\\\\\\\': '\\\\',\n            '\\\\\"': '\"',\n            \"\\\\'\": \"'\"\n        }\n        \n        for esc_seq, char in replacements.items():\n            text = text.replace(esc_seq, char)\n        \n        return text\n    \n    def display_paragraph(self, text: str, parse_ansi: bool = True, font_family: Optional[str] = None, \n                         font_size: Optional[int] = None, font_style: Optional[str] = None) -> None:\n        \"\"\"Thread-safe display paragraph (no auto newline)\"\"\"\n        def _update():\n            try:\n                self.text_area.config(state=tk.NORMAL)\n                \n                # Process escape sequences\n                text_processed = self._process_escape_sequences(text)\n                \n                # Check custom font settings\n                font_tags = []\n                if font_family or font_size or font_style:\n                    # Create unique tag for font combination\n                    font_family_val = font_family or \"Courier\"\n                    font_size_val = font_size or 10\n                    font_style_val = font_style or \"normal\"\n                    font_key = f\"font_{font_family_val}_{font_size_val}_{font_style_val}\"\n                    \n                    if font_key not in self.tag_names:\n                        self.text_area.tag_configure(font_key, \n                                                     font=(font_family_val, font_size_val, font_style_val))\n                        self.tag_names.add(font_key)\n                    font_tags.append(font_key)\n                \n                if parse_ansi and ('\\x1b[' in text_processed or '\\033[' in text_processed):\n                    # Parse and apply ANSI colors\n                    parts = self._parse_ansi_codes(text_processed)\n                    \n                    for part_text, codes in parts:\n                        tags = self._get_tags_for_codes(codes)\n                        \n                        # Add font tags (if specified)\n                        if font_tags:\n                            tags = font_tags + tags\n                        \n                        # Insert text and apply tags\n                        self.text_area.insert(tk.END, part_text, tuple(tags))\n                else:\n                    # Normal text\n                    tags = ['default']\n                    if font_tags:\n                        tags = font_tags\n                    self.text_area.insert(tk.END, text_processed, tuple(tags))\n                \n                self.text_area.config(state=tk.DISABLED)\n                self.text_area.see(tk.END)\n            except tk.TclError as e:\n                if self.running:\n                    self._safe_print(f\"Tkinter error in display_paragraph: {e}\")\n            except Exception as e:\n                if self.running:\n                    self._safe_print(f\"Error in display_paragraph: {e}\")\n        \n        if self.running:\n            self.root.after(0, _update)\n    \n    def display(self, text: str, parse_ansi: bool = True, font_family: Optional[str] = None, \n               font_size: Optional[int] = None, font_style: Optional[str] = None) -> None:\n        \"\"\"Thread-safe display text (auto newline)\"\"\"\n        def _update():\n            try:\n                self.text_area.config(state=tk.NORMAL)\n                \n                # Check custom font settings\n                font_tags = []\n                if font_family or font_size or font_style:\n                    # Create unique tag for font combination\n                    font_family_val = font_family or \"Courier\"\n                    font_size_val = font_size or 10\n                    font_style_val = font_style or \"normal\"\n                    font_key = f\"font_{font_family_val}_{font_size_val}_{font_style_val}\"\n                    \n                    if font_key not in self.tag_names:\n                        self.text_area.tag_configure(font_key, \n                                                     font=(font_family_val, font_size_val, font_style_val))\n                        self.tag_names.add(font_key)\n                    font_tags.append(font_key)\n                \n                if parse_ansi and ('\\x1b[' in str(text) or '\\033[' in str(text)):\n                    # Parse and apply ANSI colors\n                    parts = self._parse_ansi_codes(str(text))\n                    \n                    for part_text, codes in parts:\n                        tags = self._get_tags_for_codes(codes)\n                        \n                        # Add font tags (if specified)\n                        if font_tags:\n                            tags = font_tags + tags\n                        \n                        # Insert text and apply tags\n                        self.text_area.insert(tk.END, part_text, tuple(tags))\n                    \n                    # Add newline\n                    if font_tags:\n                        self.text_area.insert(tk.END, \"\\n\", tuple(font_tags))\n                    else:\n                        self.text_area.insert(tk.END, \"\\n\", 'default')\n                else:\n                    # Normal text\n                    tags = ['default']\n                    if font_tags:\n                        tags = font_tags\n                    self.text_area.insert(tk.END, str(text) + \"\\n\", tuple(tags))\n                \n                self.text_area.config(state=tk.DISABLED)\n                self.text_area.see(tk.END)\n            except tk.TclError as e:\n                if self.running:\n                    self._safe_print(f\"Tkinter error in display: {e}\")\n            except Exception as e:\n                if self.running:\n                    self._safe_print(f\"Error in display: {e}\")\n        \n        if self.running:\n            self.root.after(0, _update)\n    \n    def display_colored(self, text: str, fg_color: Optional[str] = None, bg_color: Optional[str] = None, \n                       bold: bool = False, underline: bool = False, italic: bool = False,\n                       strikethrough: bool = False, reverse: bool = False,\n                       font_family: Optional[str] = None, font_size: Optional[int] = None, \n                       font_style: Optional[str] = None) -> None:\n        \"\"\"Directly display colored text\"\"\"\n        def _update():\n            try:\n                self.text_area.config(state=tk.NORMAL)\n                \n                tags = ['default']\n                \n                # Process foreground color\n                if fg_color is not None and fg_color != \"\":\n                    fg_color_lower = fg_color.lower()\n                    if fg_color_lower in self.color_name_to_hex:\n                        color_value = self.color_name_to_hex[fg_color_lower]\n                        custom_fg_tag = f\"custom_fg_{color_value}\"\n                        tags.append(custom_fg_tag)\n                        if custom_fg_tag not in self.tag_names:\n                            self.text_area.tag_configure(custom_fg_tag, foreground=color_value)\n                            self.tag_names.add(custom_fg_tag)\n                    elif fg_color.isdigit():\n                        # ANSI code\n                        if ('disabled_colors' not in self.config or \n                            fg_color not in self.config.get('disabled_colors', [])):\n                            if fg_color in self.ansi_colors:\n                                tags.append(f\"ansi_{fg_color}\")\n                    elif fg_color.startswith('#') and len(fg_color) in [4, 5, 7, 9]:\n                        # Hex color\n                        color_value = fg_color\n                        custom_fg_tag = f\"custom_fg_{color_value}\"\n                        tags.append(custom_fg_tag)\n                        if custom_fg_tag not in self.tag_names:\n                            self.text_area.tag_configure(custom_fg_tag, foreground=color_value)\n                            self.tag_names.add(custom_fg_tag)\n                    elif ';' in fg_color and fg_color.startswith('38;'):\n                        # Extended ANSI color codes\n                        if fg_color in self.ansi_colors:\n                            tags.append(f\"ansi_{fg_color}\")\n                    else:\n                        # Try named color\n                        try:\n                            if fg_color.strip():\n                                self.text_area.tag_configure(f\"custom_fg_{fg_color}\", foreground=fg_color)\n                                tags.append(f\"custom_fg_{fg_color}\")\n                                self.tag_names.add(f\"custom_fg_{fg_color}\")\n                        except tk.TclError:\n                            pass\n                \n                # Process background color\n                if bg_color is not None and bg_color != \"\":\n                    bg_color_lower = bg_color.lower()\n                    if bg_color_lower in self.color_name_to_hex:\n                        color_value = self.color_name_to_hex[bg_color_lower]\n                        custom_bg_tag = f\"custom_bg_{color_value}\"\n                        tags.append(custom_bg_tag)\n                        if custom_bg_tag not in self.tag_names:\n                            self.text_area.tag_configure(custom_bg_tag, background=color_value)\n                            self.tag_names.add(custom_bg_tag)\n                    elif bg_color.isdigit():\n                        # ANSI code\n                        if ('disabled_colors' not in self.config or \n                            bg_color not in self.config.get('disabled_colors', [])):\n                            if bg_color in self.ansi_colors:\n                                tags.append(f\"ansi_{bg_color}\")\n                    elif bg_color.startswith('#') and len(bg_color) in [4, 5, 7, 9]:\n                        # Hex color\n                        color_value = bg_color\n                        custom_bg_tag = f\"custom_bg_{color_value}\"\n                        tags.append(custom_bg_tag)\n                        if custom_bg_tag not in self.tag_names:\n                            self.text_area.tag_configure(custom_bg_tag, background=color_value)\n                            self.tag_names.add(custom_bg_tag)\n                    elif ';' in bg_color and bg_color.startswith('48;'):\n                        # Extended ANSI color codes\n                        if bg_color in self.ansi_colors:\n                            tags.append(f\"ansi_{bg_color}\")\n                    else:\n                        # Try named color\n                        try:\n                            if bg_color.strip():\n                                self.text_area.tag_configure(f\"custom_bg_{bg_color}\", background=bg_color)\n                                tags.append(f\"custom_bg_{bg_color}\")\n                                self.tag_names.add(f\"custom_bg_{bg_color}\")\n                        except tk.TclError:\n                            pass\n                \n                # Process font\n                if font_family or font_size or font_style:\n                    font_family_val = font_family or \"Courier\"\n                    font_size_val = font_size or 10\n                    font_style_val = font_style or \"normal\"\n                    font_key = f\"font_{font_family_val}_{font_size_val}_{font_style_val}\"\n                    \n                    if font_key not in self.tag_names:\n                        self.text_area.tag_configure(font_key, \n                                                     font=(font_family_val, font_size_val, font_style_val))\n                        self.tag_names.add(font_key)\n                    tags.append(font_key)\n                \n                # Process styles\n                if bold:\n                    tags.append('bold')\n                if underline:\n                    tags.append('underline')\n                if italic:\n                    tags.append('italic')\n                if strikethrough:\n                    tags.append('strikethrough')\n                if reverse:\n                    tags.append('reverse')\n                \n                self.text_area.insert(tk.END, str(text) + \"\\n\", tuple(tags))\n                self.text_area.config(state=tk.DISABLED)\n                self.text_area.see(tk.END)\n            except tk.TclError as e:\n                if self.running:\n                    self._safe_print(f\"Tkinter error in display_colored: {e}\")\n            except Exception as e:\n                if self.running:\n                    self._safe_print(f\"Error in display_colored: {e}\")\n        \n        if self.running:\n            self.root.after(0, _update)\n    \n    def _demo_colors(self) -> None:\n        \"\"\"Display ANSI color demo\"\"\"\n        demo_texts = [\n            (\"\\x1b[1mANSI Color Demo\\x1b[0m\\n\", False),\n            (\"\\x1b[1;37mBasic Colors:\\x1b[0m\\n\", True),\n            (\"  \\x1b[30mBlack\\x1b[0m  \\x1b[31mRed\\x1b[0m  \\x1b[32mGreen\\x1b[0m  \\x1b[33mYellow\\x1b[0m\\n\", True),\n            (\"  \\x1b[34mBlue\\x1b[0m  \\x1b[35mMagenta\\x1b[0m  \\x1b[36mCyan\\x1b[0m  \\x1b[37mWhite\\x1b[0m\\n\", True),\n            (\"\\n\\x1b[1;37mBright Colors:\\x1b[0m\\n\", True),\n            (\"  \\x1b[90mGray\\x1b[0m  \\x1b[91mBright Red\\x1b[0m  \\x1b[92mBright Green\\x1b[0m\\n\", True),\n            (\"  \\x1b[93mBright Yellow\\x1b[0m  \\x1b[94mBright Blue\\x1b[0m  \\x1b[95mBright Magenta\\x1b[0m\\n\", True),\n            (\"\\n\\x1b[1;37mBackground Colors:\\x1b[0m\\n\", True),\n            (\"  \\x1b[40;37mBlack BG\\x1b[0m  \\x1b[41mRed BG\\x1b[0m  \\x1b[42mGreen BG\\x1b[0m\\n\", True),\n            (\"  \\x1b[43mYellow BG\\x1b[0m  \\x1b[44mBlue BG\\x1b[0m  \\x1b[45mMagenta BG\\x1b[0m\\n\", True),\n            (\"\\n\\x1b[1;37mExtended Colors:\\x1b[0m\\n\", True),\n            (\"  \\x1b[38;5;1mDark Red\\x1b[0m  \\x1b[38;5;9mRed\\x1b[0m  \\x1b[38;5;10mGreen\\x1b[0m  \\x1b[38;5;12mBlue\\x1b[0m\\n\", True),\n            (\"  \\x1b[48;5;1mDark Red BG\\x1b[0m  \\x1b[48;5;9mRed BG\\x1b[0m\\n\", True),\n            (\"\\n\\x1b[1;37mTrue Colors (RGB):\\x1b[0m\\n\", True),\n            (\"  \\x1b[38;2;255;0;0mRed\\x1b[0m  \\x1b[38;2;0;255;0mGreen\\x1b[0m  \\x1b[38;2;0;0;255mBlue\\x1b[0m\\n\", True),\n            (\"\\n\\x1b[1;37mText Styles:\\x1b[0m\\n\", True),\n            (\"  \\x1b[1mBold\\x1b[0m  \\x1b[3mItalic\\x1b[0m  \\x1b[4mUnderline\\x1b[0m  \\x1b[9mStrikethrough\\x1b[0m\\n\", True),\n            (\"\\n\\x1b[1;37mCombined Styles:\\x1b[0m\\n\", True),\n            (\"  \\x1b[1;31mBold Red\\x1b[0m  \\x1b[1;4;32mBold Underlined Green\\x1b[0m\\n\", True),\n            (\"  \\x1b[1;33;44mBold Yellow on Blue\\x1b[0m  \\x1b[1;37;41mBold White on Red\\x1b[0m\\n\", True),\n        ]\n        \n        for text, parse_ansi in demo_texts:\n            self.display(text, parse_ansi)\n    \n    def set_theme(self, theme_name: str) -> None:\n        \"\"\"Set theme\"\"\"\n        def _set_theme():\n            try:\n                if theme_name == \"dark\":\n                    self.text_area.config(bg=\"black\", fg=\"white\", insertbackground=\"white\")\n                    self.text_area.tag_configure(\"default\", foreground=\"white\", background=\"black\")\n                elif theme_name == \"light\":\n                    self.text_area.config(bg=\"white\", fg=\"black\", insertbackground=\"black\")\n                    self.text_area.tag_configure(\"default\", foreground=\"black\", background=\"white\")\n                elif theme_name == \"matrix\":\n                    self.text_area.config(bg=\"black\", fg=\"#00ff00\", insertbackground=\"#00ff00\")\n                    self.text_area.tag_configure(\"default\", foreground=\"#00ff00\", background=\"black\")\n                else:  # Default theme\n                    self.text_area.config(bg=\"black\", fg=\"white\", insertbackground=\"white\")\n                    self.text_area.tag_configure(\"default\", foreground=\"white\", background=\"black\")\n                \n                self.text_area.see(tk.END)\n            except tk.TclError as e:\n                if self.running:\n                    self._safe_print(f\"Tkinter error setting theme: {e}\")\n        \n        if self.running:\n            self.root.after(0, _set_theme)\n    \n    def user_write(self, prompt: str = \"Input:\") -> Optional[str]:\n        \"\"\"Thread-safe input dialog (opens in new window)\"\"\"\n        if not self.running:\n            return None\n        \n        def _ask():\n            try:\n                result = simpledialog.askstring(\"Input\", prompt, parent=self.root)\n                self.input_queue.put(result)\n            except tk.TclError:\n                self.input_queue.put(None)\n            except Exception as e:\n                self._safe_print(f\"Error in user_write dialog: {e}\")\n                self.input_queue.put(None)\n        \n        self.root.after(0, _ask)\n        \n        # Wait for input, but check if still running\n        while self.running:\n            try:\n                return self.input_queue.get(timeout=0.1)\n            except queue.Empty:\n                continue\n        return None\n    \n    def user_type_in(self, prompt: str = \">> \") -> Optional[str]:\n        \"\"\"Thread-safe terminal-style input (embedded in main window)\"\"\"\n        if not self.running:\n            return None\n            \n        def _prepare_input():\n            try:\n                # Update prompt in label\n                self.input_label.config(text=prompt)\n                \n                # Clear previous input\n                self.input_var.set(\"\")\n                \n                # Focus input field\n                self.input_entry.focus_set()\n                \n                # Enable input field\n                self.input_entry.config(state=tk.NORMAL)\n            except tk.TclError as e:\n                if self.running:\n                    self._safe_print(f\"Tkinter error preparing input: {e}\")\n        \n        # Clear old values from queue\n        while not self.type_in_queue.empty():\n            try:\n                self.type_in_queue.get_nowait()\n            except queue.Empty:\n                break\n        \n        # Prepare input field\n        try:\n            self.root.after(0, _prepare_input)\n        except tk.TclError as e:\n            if self.running:\n                self._safe_print(f\"Tkinter error scheduling input preparation: {e}\")\n            return None\n        \n        # Block and wait for user input\n        while self.running:\n            try:\n                return self.type_in_queue.get(timeout=0.1)\n            except queue.Empty:\n                continue\n        return None\n    \n    def _on_enter_pressed(self, event: Optional[tk.Event] = None) -> str:\n        \"\"\"Handle Enter key press in input field\"\"\"\n        self._on_send_input()\n        return \"break\"  # Prevent default behavior\n    \n    def _on_send_input(self) -> None:\n        \"\"\"Send input from terminal-style input field\"\"\"\n        try:\n            user_input = self.input_var.get().strip()\n            \n            if user_input:\n                # Put input in queue\n                self.type_in_queue.put(user_input)\n                \n                # Display user input in output area\n                self.text_area.config(state=tk.NORMAL)\n                self.text_area.insert(tk.END, f\"{self.input_label.cget('text')}{user_input}\\n\", 'default')\n                self.text_area.config(state=tk.DISABLED)\n                self.text_area.see(tk.END)\n                \n                # Clear input field\n                self.input_var.set(\"\")\n        except tk.TclError as e:\n            if self.running:\n                self._safe_print(f\"Tkinter error sending input: {e}\")\n        except Exception as e:\n            if self.running:\n                self._safe_print(f\"Error sending input: {e}\")\n    \n    def _clear_input(self) -> None:\n        \"\"\"Clear terminal-style input field\"\"\"\n        try:\n            self.input_var.set(\"\")\n            self.input_entry.focus_set()\n        except tk.TclError as e:\n            if self.running:\n                self._safe_print(f\"Tkinter error clearing input: {e}\")\n    \n    def focus_input(self) -> None:\n        \"\"\"Set focus to terminal-style input field\"\"\"\n        try:\n            self.input_entry.focus_set()\n        except tk.TclError as e:\n            if self.running:\n                self._safe_print(f\"Tkinter error focusing input: {e}\")\n    \n    def clear(self) -> None:\n        \"\"\"Clear output area\"\"\"\n        try:\n            self.text_area.config(state=tk.NORMAL)\n            self.text_area.delete(1.0, tk.END)\n            self.text_area.config(state=tk.DISABLED)\n        except tk.TclError as e:\n            if self.running:\n                self._safe_print(f\"Tkinter error clearing text: {e}\")\n    \n    def copy_text(self) -> None:\n        \"\"\"Copy selected text\"\"\"\n        try:\n            selected = self.text_area.selection_get()\n            self.root.clipboard_clear()\n            self.root.clipboard_append(selected)\n        except tk.TclError:\n            pass  # No text selected\n        except Exception as e:\n            if self.running:\n                self._safe_print(f\"Error copying text: {e}\")\n    \n    def select_all(self) -> None:\n        \"\"\"Select all text\"\"\"\n        try:\n            self.text_area.config(state=tk.NORMAL)\n            self.text_area.tag_add(tk.SEL, \"1.0\", tk.END)\n            self.text_area.config(state=tk.DISABLED)\n            self.text_area.mark_set(tk.INSERT, \"1.0\")\n            self.text_area.see(tk.INSERT)\n        except tk.TclError as e:\n            if self.running:\n                self._safe_print(f\"Tkinter error selecting all: {e}\")\n    \n    def exit(self) -> None:\n        \"\"\"Exit GUI\"\"\"\n        self.running = False\n        try:\n            self.root.quit()\n            self.root.destroy()\n        except tk.TclError:\n            pass  # Already destroyed\n        except Exception as e:\n            self._safe_print(f\"Error exiting GUI: {e}\")\n    \n    def run(self, func: Optional[Callable] = None, *args, **kwargs) -> Any:\n        \"\"\"\n        Run GUI and optional worker function\n        Tkinter operations stay in main thread; logic runs in another thread\n        \"\"\"\n        result_queue = queue.Queue()\n        \n        if func:\n            def worker():\n                try:\n                    result = func(*args, **kwargs)\n                    result_queue.put(result)\n                except Exception as e:\n                    self.display(f\"Error: {e}\\n{traceback.format_exc()}\")\n                    result_queue.put(e)\n            thread = threading.Thread(target=worker, daemon=True)\n            thread.start()\n        \n        try:\n            self.root.mainloop()\n        except KeyboardInterrupt:\n            self.exit()\n        except Exception as e:\n            self._safe_print(f\"Error in mainloop: {e}\")\n            self.exit()\n        \n        if func:\n            # Wait for function to complete, but make it interruptible\n            while self.running:\n                try:\n                    return result_queue.get(timeout=0.1)\n                except queue.Empty:\n                    continue\n        return None\n\n\n# Global instance and helper functions\n_gui_instance = None\n\ndef _get_instance() -> Py2GUI:\n    \"\"\"Get or create global instance\"\"\"\n    global _gui_instance\n    if _gui_instance is None or not _gui_instance.running:\n        _gui_instance = Py2GUI()\n    return _gui_instance\n\ndef display(text: str, parse_ansi: bool = True, font_family: Optional[str] = None, \n            font_size: Optional[int] = None, font_style: Optional[str] = None) -> None:\n    \"\"\"Display text (auto newline)\"\"\"\n    _get_instance().display(text, parse_ansi, font_family, font_size, font_style)\n\ndef display_colored(text: str, fg_color: Optional[str] = None, bg_color: Optional[str] = None, \n                   bold: bool = False, underline: bool = False, italic: bool = False,\n                   strikethrough: bool = False, reverse: bool = False,\n                   font_family: Optional[str] = None, font_size: Optional[int] = None, \n                   font_style: Optional[str] = None) -> None:\n    \"\"\"Directly display colored text\"\"\"\n    _get_instance().display_colored(text, fg_color, bg_color, bold, underline, \n                                   italic, strikethrough, reverse, font_family, \n                                   font_size, font_style)\n\ndef display_paragraph(text: str, parse_ansi: bool = True, font_family: Optional[str] = None, \n                     font_size: Optional[int] = None, font_style: Optional[str] = None) -> None:\n    \"\"\"Display paragraph (no auto newline)\"\"\"\n    _get_instance().display_paragraph(text, parse_ansi, font_family, font_size, font_style)\n\ndef user_write(prompt: str = \"Input:\") -> Optional[str]:\n    \"\"\"User input (dialog)\"\"\"\n    return _get_instance().user_write(prompt)\n\ndef user_type_in(prompt: str = \">> \") -> Optional[str]:\n    \"\"\"User input (terminal-style)\"\"\"\n    return _get_instance().user_type_in(prompt)\n\ndef clear() -> None:\n    \"\"\"Clear output\"\"\"\n    _get_instance().clear()\n\ndef copy_text() -> None:\n    \"\"\"Copy text\"\"\"\n    _get_instance().copy_text()\n\ndef select_all() -> None:\n    \"\"\"Select all\"\"\"\n    _get_instance().select_all()\n\ndef exit_gui() -> None:\n    \"\"\"Exit GUI\"\"\"\n    _get_instance().exit()\n\ndef run(func: Optional[Callable] = None, *args, **kwargs) -> Any:\n    \"\"\"Run GUI\"\"\"\n    return _get_instance().run(func, *args, **kwargs)\n\ndef focus_input() -> None:\n    \"\"\"Focus on input field\"\"\"\n    _get_instance().focus_input()\n\ndef set_theme(theme_name: str) -> None:\n    \"\"\"Set theme\"\"\"\n    _get_instance().set_theme(theme_name)\n","path":null,"size_bytes":41556,"size_tokens":null},"api/market.js":{"content":"import fs from 'fs';\nimport path from 'path';\n\nconst DATA_PATH = path.join(process.cwd(), 'api', 'data', 'items.json');\n\n/**\n * Reads and parses the items JSON file\n */\nfunction readItems() {\n  try {\n    const data = fs.readFileSync(DATA_PATH, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    console.error('Error reading items data:', error);\n    return null;\n  }\n}\n\n/**\n * Filters items based on query parameters\n */\nfunction filterItems(items, query) {\n  let filtered = { ...items };\n\n  // Remove placeholder entries\n  delete filtered['Mage New Weapons lvl 4-7'];\n  delete filtered['Rogue New Weapons lvl 4-7'];\n  delete filtered['Hunter New Weapons lvl 4-7'];\n  delete filtered['New Rogue Armor'];\n  delete filtered['New Materials'];\n  delete filtered['New Accessories'];\n\n  // Filter by type\n  if (query.type) {\n    const typeFilter = query.type.toLowerCase();\n    filtered = Object.fromEntries(\n      Object.entries(filtered).filter(([_, item]) => \n        item.type && item.type.toLowerCase() === typeFilter\n      )\n    );\n  }\n\n  // Filter by rarity\n  if (query.rarity) {\n    const rarityFilter = query.rarity.toLowerCase();\n    filtered = Object.fromEntries(\n      Object.entries(filtered).filter(([_, item]) => \n        item.rarity && item.rarity.toLowerCase() === rarityFilter\n      )\n    );\n  }\n\n  // Filter by class requirement\n  if (query.class) {\n    const classFilter = query.class.charAt(0).toUpperCase() + query.class.slice(1).toLowerCase();\n    filtered = Object.fromEntries(\n      Object.entries(filtered).filter(([_, item]) => \n        item.requirements && item.requirements.class === classFilter\n      )\n    );\n  }\n\n  // Filter by minimum level\n  if (query.minLevel) {\n    const minLevel = parseInt(query.minLevel, 10);\n    filtered = Object.fromEntries(\n      Object.entries(filtered).filter(([_, item]) => {\n        const itemLevel = item.requirements?.level || 1;\n        return itemLevel >= minLevel;\n      })\n    );\n  }\n\n  // Filter by max price\n  if (query.maxPrice) {\n    const maxPrice = parseInt(query.maxPrice, 10);\n    filtered = Object.fromEntries(\n      Object.entries(filtered).filter(([_, item]) => \n        item.price && Math.ceil(item.price / 2) <= maxPrice\n      )\n    );\n  }\n\n  return filtered;\n}\n\n/**\n * Transforms items to market format with half price\n */\nfunction transformToMarketItems(items) {\n  const marketItems = [];\n\n  for (const [name, item] of Object.entries(items)) {\n    const originalPrice = item.price || 0;\n    const marketPrice = Math.ceil(originalPrice / 2);\n\n    marketItems.push({\n      name,\n      type: item.type || 'unknown',\n      description: item.description || '',\n      originalPrice,\n      marketPrice,\n      discount: 50,\n      rarity: item.rarity || 'common',\n      requirements: item.requirements || null,\n      attributes: {\n        attack_bonus: item.attack_bonus || null,\n        defense_bonus: item.defense_bonus || null,\n        speed_bonus: item.speed_bonus || null,\n        mp_bonus: item.mp_bonus || null,\n        hp_bonus: item.hp_bonus || null,\n        effect: item.effect || null,\n        value: item.value || null,\n      }\n    });\n  }\n\n  return marketItems;\n}\n\n/**\n * Sorts market items by various criteria\n */\nfunction sortItems(items, sortBy = 'price_asc') {\n  const sorted = [...items];\n\n  switch (sortBy) {\n    case 'price_asc':\n      return sorted.sort((a, b) => a.marketPrice - b.marketPrice);\n    case 'price_desc':\n      return sorted.sort((a, b) => b.marketPrice - a.marketPrice);\n    case 'name_asc':\n      return sorted.sort((a, b) => a.name.localeCompare(b.name));\n    case 'name_desc':\n      return sorted.sort((a, b) => b.name.localeCompare(a.name));\n    case 'rarity':\n      const rarityOrder = { legendary: 0, rare: 1, uncommon: 2, common: 3, junk: 4 };\n      return sorted.sort((a, b) => rarityOrder[a.rarity] - rarityOrder[b.rarity]);\n    case 'level':\n      return sorted.sort((a, b) => {\n        const aLevel = a.requirements?.level || 1;\n        const bLevel = b.requirements?.level || 1;\n        return aLevel - bLevel;\n      });\n    default:\n      return sorted;\n  }\n}\n\nexport default function handler(req, res) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({\n      ok: false,\n      error: 'Method not allowed',\n      message: 'Only GET requests are supported'\n    });\n  }\n\n  const { type, rarity, class: className, minLevel, maxPrice, sort } = req.query;\n\n  // Read items data\n  const rawItems = readItems();\n  \n  if (!rawItems) {\n    return res.status(500).json({\n      ok: false,\n      error: 'Failed to load items data',\n      message: 'Could not read items database'\n    });\n  }\n\n  // Filter items\n  const filteredItems = filterItems(rawItems, { type, rarity, class: className, minLevel, maxPrice });\n\n  // Transform to market format\n  let marketItems = transformToMarketItems(filteredItems);\n\n  // Sort items\n  const sortBy = sort || 'price_asc';\n  marketItems = sortItems(marketItems, sortBy);\n\n  // Group by type for organized response\n  const itemsByType = {};\n  for (const item of marketItems) {\n    if (!itemsByType[item.type]) {\n      itemsByType[item.type] = [];\n    }\n    itemsByType[item.type].push(item);\n  }\n\n  // Build response\n  const response = {\n    ok: true,\n    timestamp: Date.now(),\n    endpoint: '/api/market',\n    baseUrl: 'https://our-legacy.vercel.app/api/market',\n    filters: {\n      type: type || null,\n      rarity: rarity || null,\n      class: className || null,\n      minLevel: minLevel ? parseInt(minLevel, 10) : null,\n      maxPrice: maxPrice ? parseInt(maxPrice, 10) : null,\n      sort: sortBy\n    },\n    summary: {\n      totalItems: marketItems.length,\n      byType: Object.fromEntries(\n        Object.entries(itemsByType).map(([type, items]) => [type, items.length])\n      )\n    },\n    items: marketItems,\n    itemsByType\n  };\n\n  // Cache for 5 minutes (300 seconds)\n  res.setHeader('Cache-Control', 'public, s-maxage=300, stale-while-revalidate=600');\n\n  return res.status(200).json(response);\n}\n\n","path":null,"size_bytes":6007,"size_tokens":null},"README.md":{"content":"# âš”ï¸ Our Legacy - Text-Based CLI Fantasy RPG Game\n\n![Python](https://img.shields.io/badge/Python-3.9+-blue.svg)\n![Node.js](https://img.shields.io/badge/Node.js-Required-green.svg)\n![License](https://img.shields.io/badge/License-MIT-yellow.svg)\n\n## ðŸ“‘ Quick Links\n- [Overview](#overview)\n- [Quick Start](#quick-start)\n- [Features](#features)\n- [Installation](#installation--setup)\n- [Web Download](#web-download)\n- [Game Controls](#game-controls)\n- [File Structure](#file-structure)\n- [Mod System](#mod-system)\n- [Contributing](#contributing)\n\n## Overview\n\n\"Our Legacy\" is a comprehensive text-based CLI fantasy RPG game focused on exploration, grinding, and adventure. Built with Python and driven by modular JSON data, the game offers a rich, extensible experience for players and modders alike. Now featuring a powerful **JavaScript Scripting Engine** powered by Node.js and a new **Alchemy & Crafting** system.\n\n## Features\n\n### Core Gameplay\n- **Character Classes**: Choose from **Warrior**, **Mage**, **Rogue**, **Hunter**, **Bard**, **Paladin**, **Druid**, or **Priest** classes.\n- **Exploration**: 7 diverse areas including the Starting Village, Dark Forest, Ancient Ruins, and more.\n- **Alchemy & Crafting**: Collect materials from monsters and the environment to brew potent potions or forge powerful equipment.\n- **Grinding System**: Level up through combat, gaining stats and unlocking new equipment.\n- **Mission System**: Complete main story and side quests for gold and experience rewards.\n- **Boss Battles**: Face legendary bosses like the **Ancient Fire Dragon** with multi-phase mechanics and HP thresholds.\n- **Scripting Engine**: Extend and automate your journey using JavaScript (Node.js).\n\n### Advanced Systems\n- **Companions**: Hire unique companions at the Tavern with active abilities and passive party bonuses.\n- **Buff & Effect System**: Manage temporary status effects, magical shields, and per-turn HP/MP regeneration.\n- **Offhand & Accessories**: Deep equipment customization with dedicated offhand slots and up to 3 accessory slots.\n- **Real-time Cooldowns**: Bosses feature an 8-hour real-time cooldown after defeat.\n\n## Character Classes\n\n| Class | Description | Key Stats | Starting Gear |\n|-------|-------------|-----------|---------------|\n| **Warrior** | Strong melee fighter | High HP & Defense | Iron Sword, Leather Armor |\n| **Mage** | Powerful spellcaster | High MP & Magic | Wooden Wand, Cloth Tunic |\n| **Rogue** | Agile assassin | High Speed & Crit | Steel Dagger, Leather Armor |\n| **Hunter** | Experienced tracker | High Attack & Aim | Hunter's Bow, Hunting Knife |\n| **Bard** | Master of melodies | High Speed & Support | Enchanting Lute, Colourful Robe |\n| **Paladin** | Holy warrior | High Defense & Holy Power | Paladin's Sword, Holy Shield |\n| **Druid** | Nature guardian | High MP & Shapeshift | Druidic Staff, Nature's Robe |\n| **Priest** | Devoted healer | High MP & Healing | Priest's Staff, Devout's Robe |\n\n## Alchemy & Crafting\n\nThe new Crafting system allows you to create items using materials gathered during your travels.\n\n### Material Collection\nMaterials are found by defeating enemies or exploring specific areas:\n- **Ores**: Iron Ore, Coal, Steel Ingot, Gold Nugget.\n- **Herbs**: Herbs, Mana Herbs, Spring Water.\n- **Crystals**: Crystal Shards, Dark Crystals, Fire Gems.\n- **Monster Parts**: Goblin Ears, Orc Teeth, Wolf Fangs, Venom Sacs.\n- **Magical**: Phoenix Feathers, Dragon Scales, Ancient Relics.\n\n### Alchemy Recipes\n- **Potions**: Brew Health and Mana potions (Basic to Greater), or specialized Frost Potions.\n- **Elixirs**: Create powerful boosters like the *Elixir of Giant Strength*.\n- **Enchantments**: Forge weapons and armor like *Steel Daggers* or *Swamp Scale Armor*.\n- **Utility**: Craft Luck Charms or extract pure Elemental Essences into Gems.\n\n## ðŸš€ Quick Start\n\n### Prerequisites\n- **Python 3.9+**\n- **Node.js** (for scripting features)\n\n### Installation\n```bash\n# Clone or download the repository\ngit clone https://github.com/yourusername/our-legacy.git\n\n# Navigate to the project directory\ncd our-legacy\n\n# Run the game\npython3 main.py\n\n# Or use the launcher for all tools\npython3 launcher.py\n```\n\n## ðŸŒ Web Download\n\nYou can also download Our Legacy directly from the web interface:\n\n1. Open `index.html` in your browser\n2. Click the **\"Download Our Legacy (ZIP)\"** button\n3. Extract the ZIP file\n4. Run `python3 main.py` to start playing\n\nThe web interface also includes:\n- ðŸ“– Full documentation display\n- ðŸŽ® Feature highlights\n- ðŸ“¦ One-click ZIP download\n\n## Game Controls\n\n### Main Menu\n- **Explore**: Engage in random encounters and collect crafting materials.\n- **Inventory**: Manage items and access the **Crafting** menu.\n- **View Character**: Check stats, equipment, and active buffs.\n- **Travel**: Move between connected world areas.\n- **Missions**: Track and accept quests.\n- **Tavern**: Hire and manage your party members.\n- **Shop**: Browse multiple specialized shops in each area, each with unique items and purchase limits.\n- **Save/Load**: Persist your progress to JSON save files.\n\n## File Structure\n\n```\nOur_Legacy/\nâ”œâ”€â”€ launcher.py             # Unified launcher for all tools\nâ”œâ”€â”€ storyland.py            # Download and manage mods from GitHub\nâ”œâ”€â”€ storywrite.py           # Submit mods to the community\nâ”œâ”€â”€ main.py                 # Core game engine (Python 3.9+)\nâ”œâ”€â”€ chat.py                 # The chat client for Global chat\nâ”œâ”€â”€ gui_all.py              # Experimental GUI version of launcher.py using Tkinter\nâ”œâ”€â”€ README.md               # Quick start guide and overview\nâ”œâ”€â”€ documentation.md        # Complete modding guide with parameters & examples\nâ”œâ”€â”€ package.json            # Node.js project configuration (for scripting)\nâ”œâ”€â”€ data/                   # Base Game Content (JSON)\nâ”‚   â”œâ”€â”€ classes.json        # Player character classes and progression\nâ”‚   â”œâ”€â”€ items.json          # Weapons, armor, consumables, accessories\nâ”‚   â”œâ”€â”€ crafting.json       # Alchemy recipes and material categories\nâ”‚   â”œâ”€â”€ areas.json          # World locations, shops, connections\nâ”‚   â”œâ”€â”€ shops.json          # Shop definitions with items and limits\nâ”‚   â”œâ”€â”€ enemies.json        # Regular combat encounters\nâ”‚   â”œâ”€â”€ bosses.json         # Boss mechanics with multi-phase support\nâ”‚   â”œâ”€â”€ missions.json       # Quests with objectives and rewards\nâ”‚   â”œâ”€â”€ spells.json         # Magic spells and abilities\nâ”‚   â”œâ”€â”€ effects.json        # Status effects and buffs\nâ”‚   â”œâ”€â”€ companions.json     # Hireable companion definitions\nâ”‚   â”œâ”€â”€ dialogues.json      # NPC and boss dialogue text\nâ”‚   â”œâ”€â”€ dungeons.json       # Procedural dungeons with challenges\nâ”‚   â”œâ”€â”€ weekly_challenges.json  # Recurring challenges\nâ”‚   â””â”€â”€ saves/              # Player save files (.json)\nâ”œâ”€â”€ mods/                   # Installed mods (downloaded and custom)\nâ”‚   â””â”€â”€ The Ether/          # Example mod structure\nâ”‚       â”œâ”€â”€ mod.json        # Mod metadata\nâ”‚       â”œâ”€â”€ bosses.json     # New bosses\nâ”‚       â”œâ”€â”€ areas.json      # New areas\nâ”‚       â”œâ”€â”€ enemies.json    # New enemies\nâ”‚       â”œâ”€â”€ items.json      # New items\nâ”‚       â”œâ”€â”€ dungeons.json   # New dungeons\nâ”‚       â”œâ”€â”€ dialogues.json  # New dialogue text\nâ”‚       â””â”€â”€ ...other files\nâ”œâ”€â”€ api/                    # API modules for marketplace\nâ”‚   â”œâ”€â”€ market.js\nâ”‚   â”œâ”€â”€ ping.js\nâ”‚   â”œâ”€â”€ upload_test.js\nâ”‚   â”œâ”€â”€ send_message.js\nâ”‚   â”œâ”€â”€ create_user.js\nâ”‚   â””â”€â”€ data/\nâ””â”€â”€ LICENSE                 # Project license\n```\n\n## Mod System\n\n### Creating a Mod\n1. Create a folder in `mods/` with your mod name\n2. Create `mod.json` with metadata:\n```json\n{\n  \"name\": \"Your Mod Name\",\n  \"version\": \"1.0.0\",\n  \"author\": \"Your Name\",\n  \"description\": \"What your mod adds\",\n  \"enabled\": true\n}\n```\n3. Add any data files you want to modify:\n   - `bosses.json` - New or override bosses\n   - `areas.json` - New areas or area changes\n   - `items.json` - New items\n   - `dungeons.json` - New dungeons\n   - `dialogues.json` - Dialogue text\n   - Any other data files from `data/`\n\n### How Mods Load\n- Base game data loads first from `data/`\n- Enabled mods load sequentially, merging data\n- Arrays (dungeons) are extended with new entries\n- Objects (items, bosses) are updated/overridden\n- Mod data takes precedence over base data for same IDs\n\n---\n\n## Data File Overview\n\n### Core Data Files\n| File | Purpose | Contains |\n|------|---------|----------|\n| **classes.json** | Character classes | Warrior, Mage, Rogue, Hunter, Bard |\n| **items.json** | Equipment & consumables | Weapons, armor, potions, materials |\n| **enemies.json** | Regular encounters | Goblin, Orc, Skeleton, etc. |\n| **bosses.json** | Boss battles | Multi-phase encounters with abilities |\n| **areas.json** | World locations | Starting Village, Dungeons, Towns |\n| **missions.json** | Quests | Main story and side quests |\n| **spells.json** | Magic abilities | Spells for different classes |\n| **effects.json** | Status effects | Buffs, debuffs, conditions |\n| **companions.json** | Party members | Hireable companions with abilities |\n| **crafting.json** | Alchemy system | Recipes and material categories |\n| **dialogues.json** | Text dialogue | Boss speeches and NPC dialogue |\n| **dungeons.json** | Procedural dungeons | Dungeon definitions and challenges |\n\n### Parameter Reference\nFor complete parameter documentation, see [documentation.md](documentation.md):\n- **All JSON parameters** with type information\n- **Complete examples** for each file type\n- **Mod creation guide** with step-by-step instructions\n- **Best practices** for mod development\n\n## ðŸ¤ Contributing\n\nContributions are welcome! Whether it's:\n- ðŸ› Bug fixes\n- âœ¨ New features\n- ðŸ”§ Mod creation\n- ðŸ“š Documentation improvements\n- ðŸŒ Translation support\n\nPlease ensure your code follows the existing style and includes appropriate documentation.\n\n## ðŸ“„ License\n\nThis project is open source under the MIT License. See the [LICENSE](LICENSE) file for details.\n\n---\n\n<p align=\"center\">\n  <strong>Forge your destiny and leave behind a legend that will never be forgotten!</strong><br>\n  <em>Built with â¤ï¸ using Python & Node.js</em>\n</p>\n","path":null,"size_bytes":10391,"size_tokens":null},"api/send_message.js":{"content":"// Global Chat API for Our Legacy\n// Message structure: [{ content, author, timestamp }]\n// Repository: andy64lol/globalchat\n// File: global_chat.json on main branch\n\nconst GITHUB_API = \"https://api.github.com\";\nconst REPO_OWNER = \"andy64lol\";\nconst REPO_NAME = \"globalchat\";\nconst BRANCH = \"main\";\nconst FILE_PATH = \"global_chat.json\";\nconst OLD_MESSAGES_DIR = \"old_messages\";\nconst MAX_MESSAGES = 100;\nconst MESSAGES_TO_KEEP = 5;\nconst PROFANITY_WORDS_URL = \"https://raw.githubusercontent.com/zautumnz/profane-words/refs/heads/master/words.json\";\n\n// GitHub REST API helper\nasync function githubFetch(url, options = {}) {\n  const token = process.env.GITHUB_REST_API;\n  const headers = {\n    Authorization: `Bearer ${token}`,\n    Accept: \"application/vnd.github+json\",\n    \"X-GitHub-Api-Version\": \"2022-11-28\",\n    \"Content-Type\": \"application/json\",\n    ...options.headers\n  };\n\n  const response = await fetch(url, { ...options, headers });\n  const data = await response.json();\n  \n  if (!response.ok) {\n    throw { status: response.status, data };\n  }\n  \n  return data;\n}\n\n// Get file SHA for updates\nasync function getFileSha() {\n  try {\n    const data = await githubFetch(\n      `${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/contents/${FILE_PATH}`\n    );\n    return data.sha;\n  } catch {\n    return null;\n  }\n}\n\n// Fetch profanity words for filtering\nasync function fetchProfanityWords() {\n  try {\n    const response = await fetch(PROFANITY_WORDS_URL);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch profanity words: ${response.status}`);\n    }\n    const words = await response.json();\n    return words;\n  } catch (error) {\n    console.error('Error fetching profanity words:', error);\n    return [];\n  }\n}\n\n// Check if text contains profanity\nfunction containsProfanity(text, profanityWords) {\n  if (!text || typeof text !== 'string') return false;\n  \n  const lowerText = text.toLowerCase();\n  for (const word of profanityWords) {\n    if (typeof word === 'string' && word.trim()) {\n      const escapedWord = word.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n      const regex = new RegExp(`\\\\b${escapedWord}\\\\b`, 'i');\n      if (regex.test(text)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// Read messages from the repository\nasync function readMessages() {\n  const rawUrl = `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${FILE_PATH}`;\n  \n  try {\n    const response = await fetch(rawUrl);\n    if (!response.ok) {\n      if (response.status === 404) {\n        return [];\n      }\n      throw new Error(`Failed to fetch messages: ${response.status}`);\n    }\n    const content = await response.text();\n    const decoded = Buffer.from(content, 'base64').toString('utf-8');\n    return JSON.parse(decoded);\n  } catch (error) {\n    console.error('Error reading messages:', error);\n    return [];\n  }\n}\n\n// Save messages to repository\nasync function saveMessages(messages, sha = null) {\n  const content = JSON.stringify(messages, null, 2);\n  const encoded = Buffer.from(content).toString('base64');\n  \n  const payload = {\n    message: messages.length > 0 \n      ? `Update chat: ${messages.length} messages` \n      : \"Initialize chat\",\n    content: encoded,\n    branch: BRANCH\n  };\n  \n  if (sha) {\n    payload.sha = sha;\n  }\n  \n  return await githubFetch(\n    `${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/contents/${FILE_PATH}`,\n    {\n      method: \"PUT\",\n      body: JSON.stringify(payload)\n    }\n  );\n}\n\n// Archive old messages\nasync function archiveMessages(messages) {\n  // Create archive filename with timestamp\n  const timestamp = messages.length > 0 \n    ? messages[messages.length - 1].timestamp \n    : Date.now();\n  const archiveFilename = `${OLD_MESSAGES_DIR}/${timestamp}_chat.json`;\n  \n  // Save archived messages - GitHub creates the directory automatically if it doesn't exist\n  const content = JSON.stringify(messages, null, 2);\n  const encoded = Buffer.from(content).toString('base64');\n  \n  const archivePayload = {\n    message: `Archive ${messages.length} old messages`,\n    content: encoded,\n    branch: BRANCH\n  };\n  \n  await githubFetch(\n    `${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/contents/${archiveFilename}`,\n    {\n      method: \"PUT\",\n      body: JSON.stringify(archivePayload)\n    }\n  );\n}\n\n// Get latest commit SHA\nasync function getLatestCommitSha() {\n  const data = await githubFetch(\n    `${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/commits/${BRANCH}`\n  );\n  return data.sha;\n}\n\n// Handle incoming messages\nasync function handleMessage(req, res) {\n  const { message, author } = req.body;\n  \n  // Validate input\n  if (!message || !author) {\n    return res.status(400).json({ \n      error: \"Message and author are required\" \n    });\n  }\n  \n  if (typeof message !== 'string' || typeof author !== 'string') {\n    return res.status(400).json({ \n      error: \"Message and author must be strings\" \n    });\n  }\n  \n  if (message.length > 300) {\n    return res.status(400).json({ \n      error: \"Message too long (max 300 characters)\" \n    });\n  }\n  \n  if (author.length > 50) {\n    return res.status(400).json({ \n      error: \"Author name too long (max 50 characters)\" \n    });\n  }\n  \n  // Check for profanity\n  const profanityWords = await fetchProfanityWords();\n  \n  if (containsProfanity(message, profanityWords)) {\n    return res.status(400).json({ \n      error: \"Message contains prohibited content\",\n      filtered: true\n    });\n  }\n  \n  if (containsProfanity(author, profanityWords)) {\n    return res.status(400).json({ \n      error: \"Author name contains prohibited content\",\n      filtered: true\n    });\n  }\n  \n  try {\n    // Read current messages\n    let messages = await readMessages();\n    const sha = await getFileSha();\n    \n    // Create new message\n    const newMessage = {\n      content: message.trim(),\n      author: author.trim(),\n      timestamp: Date.now().toString(),\n      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    };\n    \n    // Check if we need to archive messages\n    if (messages.length >= MAX_MESSAGES) {\n      // Archive all except last MESSAGES_TO_KEEP\n      const toArchive = messages.slice(0, -MESSAGES_TO_KEEP);\n      const toKeep = messages.slice(-MESSAGES_TO_KEEP);\n      \n      await archiveMessages(toArchive);\n      messages = toKeep;\n    }\n    \n    // Add new message\n    messages.push(newMessage);\n    \n    // Save updated messages\n    await saveMessages(messages, sha);\n    \n    return res.status(200).json({\n      success: true,\n      message: \"Message sent successfully\",\n      data: {\n        id: newMessage.id,\n        timestamp: newMessage.timestamp,\n        position: messages.length\n      }\n    });\n    \n  } catch (error) {\n    console.error('Error sending message:', error);\n    return res.status(error.status || 500).json({\n      error: error.data?.message || error.message || \"Failed to send message\"\n    });\n  }\n}\n\n// Handle reading messages\nasync function handleRead(req, res) {\n  const { limit = 50, offset = 0 } = req.query;\n  \n  try {\n    const messages = await readMessages();\n    \n    // Pagination\n    const start = Math.min(offset, messages.length);\n    const end = Math.min(start + parseInt(limit), messages.length);\n    const paginatedMessages = messages.slice(start, end);\n    \n    return res.status(200).json({\n      success: true,\n      data: {\n        messages: paginatedMessages,\n        total: messages.length,\n        limit: parseInt(limit),\n        offset: parseInt(offset),\n        hasMore: end < messages.length\n      }\n    });\n    \n  } catch (error) {\n    console.error('Error reading messages:', error);\n    return res.status(error.status || 500).json({\n      error: error.data?.message || error.message || \"Failed to read messages\"\n    });\n  }\n}\n\n// Main handler\nexport default async function handler(req, res) {\n  const { method, query } = req;\n  \n  switch (method) {\n    case \"GET\":\n      return handleRead(req, res);\n    case \"POST\":\n      return handleMessage(req, res);\n    default:\n      return res.status(405).json({ \n        error: \"Method not allowed\",\n        allowed: [\"GET\", \"POST\"]\n      });\n  }\n}\n","path":null,"size_bytes":8096,"size_tokens":null},"utilities/dice.py":{"content":"# Dice rolling utility, idk why I made it but btw it can be used for anything lol\n# Made by andy64lol\n\nimport random\n\nclass Dice:\n    def roll_1d(self, sides):\n        return random.randint(1, sides)\n    def roll(self, num_dice, sides): \n        return [self.roll_1d(sides) for _ in range(num_dice)]\n    def roll_min_max(self, num_dice, sides): \n        rolls = self.roll(num_dice, sides)\n        return min(rolls), max(rolls)","path":null,"size_bytes":426,"size_tokens":null},"storyland.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nOur Legacy Mod Downloader CLI\n\nDownloads mods from the GitHub repository and installs them locally.\nFeatures: Pagination, colored output, screen clearing, navigation.\n\"\"\"\n\nimport json\nimport os\nimport sys\nimport requests\nimport zipfile\nimport io\nfrom pathlib import Path\n\n\n# Configuration\nGITHUB_API_URL = \"https://api.github.com\"\nREPO_OWNER = \"andy64lol\"\nREPO_NAME = \"Our_Legacy_Mods\"\nMODS_BRANCH = \"main\"\nLOCAL_MODS_DIR = Path(__file__).parent / \"mods\"\nMODS_PER_PAGE = 10\n\n\n# Colors\nclass Colors:\n    RESET = '\\033[0m'\n    BOLD = '\\033[1m'\n    \n    # Colors\n    BLACK = '\\033[30m'\n    RED = '\\033[31m'\n    GREEN = '\\033[32m'\n    YELLOW = '\\033[33m'\n    BLUE = '\\033[34m'\n    MAGENTA = '\\033[35m'\n    CYAN = '\\033[36m'\n    WHITE = '\\033[37m'\n    \n    # Bright colors\n    BRIGHT_BLACK = '\\033[90m'\n    BRIGHT_RED = '\\033[91m'\n    BRIGHT_GREEN = '\\033[92m'\n    BRIGHT_YELLOW = '\\033[93m'\n    BRIGHT_BLUE = '\\033[94m'\n    BRIGHT_MAGENTA = '\\033[95m'\n    BRIGHT_CYAN = '\\033[96m'\n    BRIGHT_WHITE = '\\033[97m'\n    \n    # Background colors\n    BG_RED = '\\033[41m'\n    BG_GREEN = '\\033[42m'\n    BG_YELLOW = '\\033[43m'\n    BG_BLUE = '\\033[44m'\n\n\ndef clear_screen():\n    \"\"\"Clear the terminal screen.\"\"\"\n    os.system('cls' if os.name == 'nt' else 'clear')\n\n\ndef get_available_mods():\n    \"\"\"Fetch list of available mods from GitHub repository.\"\"\"\n    url = f\"{GITHUB_API_URL}/repos/{REPO_OWNER}/{REPO_NAME}/contents/mods?ref={MODS_BRANCH}\"\n    \n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        contents = response.json()\n        \n        mods = []\n        for item in contents:\n            if item['type'] == 'dir' or item['type'] == 'file':\n                if item['name'] != '.gitkeep':  # Skip gitkeep files\n                    mods.append(item['name'])\n        \n        return sorted(mods)\n    except requests.exceptions.RequestException as e:\n        print(f\"{Colors.RED}Error fetching mods: {e}{Colors.RESET}\")\n        return []\n\n\ndef get_mod_details(mod_name):\n    \"\"\"Get details of a specific mod.\"\"\"\n    url = f\"{GITHUB_API_URL}/repos/{REPO_OWNER}/{REPO_NAME}/contents/mods/{mod_name}?ref={MODS_BRANCH}\"\n    \n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        print(f\"{Colors.RED}Error fetching mod details: {e}{Colors.RESET}\")\n        return None\n\n\ndef download_and_install_mod(mod_name):\n    \"\"\"Download a mod and install it to the local mods directory.\"\"\"\n    # First, try to get the mod as a zip from GitHub\n    zip_url = f\"https://github.com/{REPO_OWNER}/{REPO_NAME}/archive/refs/heads/{MODS_BRANCH}.zip\"\n    \n    try:\n        # Download the entire repository as zip\n        response = requests.get(zip_url)\n        response.raise_for_status()\n        \n        # Extract the zip in memory\n        with zipfile.ZipFile(io.BytesIO(response.content)) as zf:\n            # The zip will have a folder like \"Our_Legacy_Mods-main/mods/{mod_name}/\"\n            prefix = f\"Our_Legacy_Mods-{MODS_BRANCH}/mods/{mod_name}/\"\n            \n            # Find all files for this mod\n            mod_files = [f for f in zf.namelist() if f.startswith(prefix) and not f.endswith('/')]\n            \n            if not mod_files:\n                print(f\"{Colors.RED}No files found for mod: {mod_name}{Colors.RESET}\")\n                return False\n            \n            # Create the local mod directory\n            local_mod_dir = LOCAL_MODS_DIR / mod_name\n            local_mod_dir.mkdir(parents=True, exist_ok=True)\n            \n            # Extract each file\n            for file_path in mod_files:\n                # Remove the prefix to get the relative path\n                relative_path = file_path[len(prefix):]\n                \n                # Skip if it's just a directory reference\n                if not relative_path:\n                    continue\n                \n                # Create the full local path\n                local_path = local_mod_dir / relative_path\n                \n                # Create parent directories if needed\n                local_path.parent.mkdir(parents=True, exist_ok=True)\n                \n                # Extract the file\n                with zf.open(file_path) as source, open(local_path, 'wb') as target:\n                    target.write(source.read())\n            \n            print(f\"{Colors.GREEN}âœ“ Successfully installed mod: {mod_name}{Colors.RESET}\")\n            return True\n            \n    except requests.exceptions.RequestException as e:\n        print(f\"{Colors.RED}Error downloading mod: {e}{Colors.RESET}\")\n        return False\n    except zipfile.BadZipFile:\n        print(f\"{Colors.RED}Error: Invalid zip file received from GitHub{Colors.RESET}\")\n        return False\n    except Exception as e:\n        print(f\"{Colors.RED}Error installing mod: {e}{Colors.RESET}\")\n        return False\n\n\ndef display_banner():\n    \"\"\"Display the CLI banner.\"\"\"\n    clear_screen()\n    print(f\"{Colors.CYAN}{Colors.BOLD}\")\n    print(\"=\" * 50)\n    print(\"     Our Legacy Mod Downloader: Storyland\")\n    print(\"=\" * 50)\n    print(f\"{Colors.RESET}\")\n\n\ndef display_mod_list(mods, current_page, total_pages):\n    \"\"\"Display a page of mods with pagination info.\"\"\"\n    print(f\"\\n{Colors.BRIGHT_BLUE}Available Mods (Page {current_page}/{total_pages}){Colors.RESET}\")\n    print(\"-\" * 50)\n    \n    start_idx = (current_page - 1) * MODS_PER_PAGE\n    end_idx = min(start_idx + MODS_PER_PAGE, len(mods))\n    \n    for i in range(start_idx, end_idx):\n        mod_num = i + 1\n        mod_name = mods[i]\n        \n        # Alternate colors for mod numbers\n        if mod_num % 2 == 0:\n            num_color = Colors.YELLOW\n        else:\n            num_color = Colors.BRIGHT_YELLOW\n        \n        print(f\"{num_color}{mod_num:2}.{Colors.RESET} {Colors.WHITE}{mod_name}{Colors.RESET}\")\n    \n    print(\"-\" * 50)\n\n\ndef main():\n    \"\"\"Main CLI function.\"\"\"\n    display_banner()\n    \n    # Get list of available mods\n    print(f\"\\n{Colors.YELLOW}Fetching available mods...{Colors.RESET}\")\n    mods = get_available_mods()\n    \n    if not mods:\n        print(f\"\\n{Colors.RED}No mods found or error connecting to GitHub.{Colors.RESET}\")\n        sys.exit(1)\n    \n    total_mods = len(mods)\n    total_pages = (total_mods + MODS_PER_PAGE - 1) // MODS_PER_PAGE\n    current_page = 1\n    \n    # Main loop\n    while True:\n        display_banner()\n        display_mod_list(mods, current_page, total_pages)\n        \n        print(f\"\\n{Colors.MAGENTA}{Colors.BOLD}Enter your choice:{Colors.RESET} \", end=\"\")\n        \n        try:\n            choice = input().strip().lower()\n        except (EOFError, OSError):\n            # Handle Ctrl+D or other input errors\n            print(f\"\\n{Colors.RED}Input error. Use 'q' to quit.{Colors.RESET}\")\n            continue\n        \n        # Clear screen after each action\n        clear_screen()\n        \n        # Handle navigation commands\n        if choice in ['q', 'quit']:\n            print(f\"\\n{Colors.CYAN}Thank you for using Our Legacy Mod Downloader Storyland!{Colors.RESET}\")\n            print(f\"{Colors.CYAN}Goodbye!{Colors.RESET}\\n\")\n            sys.exit(0)\n        \n        elif choice == 'n' or choice == 'next':\n            if current_page < total_pages:\n                current_page += 1\n                print(f\"\\n{Colors.GREEN}Going to next page...{Colors.RESET}\")\n            else:\n                print(f\"\\n{Colors.YELLOW}Already on the last page.{Colors.RESET}\")\n            continue\n        \n        elif choice == 'p' or choice == 'prev' or choice == 'previous':\n            if current_page > 1:\n                current_page -= 1\n                print(f\"\\n{Colors.GREEN}Going to previous page...{Colors.RESET}\")\n            else:\n                print(f\"\\n{Colors.YELLOW}Already on the first page.{Colors.RESET}\")\n            continue\n        \n        # Handle mod selection\n        try:\n            choice_idx = int(choice) - 1\n            \n            # Calculate which page this mod would be on\n            if choice_idx < 0 or choice_idx >= total_mods:\n                print(f\"\\n{Colors.RED}Invalid selection. Please enter a number between 1 and {total_mods}{Colors.RESET}\")\n                input(f\"\\n{Colors.BLUE}Press Enter to continue...{Colors.RESET}\")\n                continue\n            \n            selected_mod = mods[choice_idx]\n            \n            # Navigate to the correct page if needed\n            required_page = (choice_idx // MODS_PER_PAGE) + 1\n            if required_page != current_page:\n                current_page = required_page\n            \n            print(f\"\\n{Colors.YELLOW}Downloading and installing: {Colors.BRIGHT_WHITE}{selected_mod}{Colors.RESET}...\")\n            \n            if download_and_install_mod(selected_mod):\n                print(f\"\\n{Colors.GREEN}âœ“ Mod '{selected_mod}' has been successfully installed!{Colors.RESET}\")\n                print(f\"{Colors.BLUE}  Location: {LOCAL_MODS_DIR / selected_mod}{Colors.RESET}\")\n            else:\n                print(f\"\\n{Colors.RED}âœ— Failed to install mod '{selected_mod}'{Colors.RESET}\")\n            \n            input(f\"\\n{Colors.BLUE}Press Enter to continue...{Colors.RESET}\")\n            \n        except ValueError:\n            print(f\"\\n{Colors.RED}Invalid input. Please enter a number, 'n', 'p', or 'q'.{Colors.RESET}\")\n            input(f\"\\n{Colors.BLUE}Press Enter to continue...{Colors.RESET}\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n","path":null,"size_bytes":9504,"size_tokens":null},"api/create_user.js":{"content":"// User Management API for Our Legacy\n// Repository: andy64lol/globalchat\n// File: users.json on main branch\n\nconst GITHUB_API = \"https://api.github.com\";\nconst REPO_OWNER = \"andy64lol\";\nconst REPO_NAME = \"globalchat\";\nconst BRANCH = \"main\";\nconst FILE_PATH = \"users.json\";\n\n// GitHub REST API helper\nasync function githubFetch(url, options = {}) {\n  const token = process.env.GITHUB_REST_API;\n  const headers = {\n    Authorization: `Bearer ${token}`,\n    Accept: \"application/vnd.github+json\",\n    \"X-GitHub-Api-Version\": \"2022-11-28\",\n    \"Content-Type\": \"application/json\",\n    ...options.headers\n  };\n\n  const response = await fetch(url, { ...options, headers });\n  const data = await response.json();\n  \n  if (!response.ok) {\n    throw { status: response.status, data };\n  }\n  \n  return data;\n}\n\n// Get file SHA for updates\nasync function getFileSha() {\n  try {\n    const data = await githubFetch(\n      `${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/contents/${FILE_PATH}`\n    );\n    return data.sha;\n  } catch {\n    return null;\n  }\n}\n\n// Read users from the repository\nasync function readUsers() {\n  const rawUrl = `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${FILE_PATH}`;\n  \n  try {\n    const response = await fetch(rawUrl);\n    if (!response.ok) {\n      if (response.status === 404) {\n        return [];\n      }\n      throw new Error(`Failed to fetch users: ${response.status}`);\n    }\n    const content = await response.text();\n    // GitHub API returns base64 encoded content, but raw URL returns plain text\n    try {\n      // Try parsing as JSON first (raw URL returns JSON)\n      return JSON.parse(content);\n    } catch {\n      // If that fails, try base64 decoding\n      const decoded = Buffer.from(content, 'base64').toString('utf-8');\n      return JSON.parse(decoded);\n    }\n  } catch (error) {\n    console.error('Error reading users:', error);\n    return [];\n  }\n}\n\n// Save users to repository\nasync function saveUsers(users, sha = null) {\n  const content = JSON.stringify(users, null, 2);\n  const encoded = Buffer.from(content).toString('base64');\n  \n  const payload = {\n    message: `Add new user: ${users.length} total users`,\n    content: encoded,\n    branch: BRANCH\n  };\n  \n  if (sha) {\n    payload.sha = sha;\n  }\n  \n  return await githubFetch(\n    `${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/contents/${FILE_PATH}`,\n    {\n      method: \"PUT\",\n      body: JSON.stringify(payload)\n    }\n  );\n}\n\n// Check if alias exists (case-insensitive)\nfunction aliasExists(users, alias) {\n  const lowerAlias = alias.toLowerCase();\n  return users.some(user => \n    user && typeof user === 'object' && \n    user.alias && user.alias.toLowerCase() === lowerAlias\n  );\n}\n\n// Validate alias format\nfunction validateAlias(alias) {\n  if (!alias || typeof alias !== 'string') {\n    return { valid: false, error: \"Alias is required and must be a string\" };\n  }\n  \n  const trimmed = alias.trim();\n  \n  if (!trimmed) {\n    return { valid: false, error: \"Alias cannot be empty\" };\n  }\n  \n  if (trimmed.length > 20) {\n    return { valid: false, error: \"Alias too long (max 20 characters)\" };\n  }\n  \n  // Allow letters, numbers, spaces, underscores, and hyphens\n  const validPattern = /^[a-zA-Z0-9_\\- ]+$/;\n  if (!validPattern.test(trimmed)) {\n    return { valid: false, error: \"Only letters, numbers, spaces, underscores, and hyphens allowed\" };\n  }\n  \n  return { valid: true, alias: trimmed };\n}\n\n// Handle creating a new user\nasync function handleCreateUser(req, res) {\n  const { alias, metadata = {} } = req.body;\n  \n  // Validate alias format\n  const validation = validateAlias(alias);\n  if (!validation.valid) {\n    return res.status(400).json({ \n      error: validation.error,\n      field: \"alias\"\n    });\n  }\n  \n  const validatedAlias = validation.alias;\n  \n  try {\n    // Read current users\n    const users = await readUsers();\n    const sha = await getFileSha();\n    \n    // Check if alias already exists\n    if (aliasExists(users, validatedAlias)) {\n      return res.status(409).json({ \n        error: \"Username already taken\",\n        alias: validatedAlias,\n        available: false\n      });\n    }\n    \n    // Create new user with standard structure\n    const newUser = {\n      alias: validatedAlias,\n      permissions: metadata.permissions || \"user\",\n      blacklisted: false\n    };\n    \n    // Add to users list\n    users.push(newUser);\n    \n    // Save updated users\n    await saveUsers(users, sha);\n    \n    return res.status(201).json({\n      success: true,\n      message: \"User created successfully\",\n      data: {\n        alias: newUser.alias,\n        permissions: newUser.permissions,\n        available: true\n      }\n    });\n    \n  } catch (error) {\n    console.error('Error creating user:', error);\n    return res.status(error.status || 500).json({\n      error: error.data?.message || error.message || \"Failed to create user\"\n    });\n  }\n}\n\n// Handle checking if alias exists\nasync function handleCheckAlias(req, res) {\n  const { alias } = req.query;\n  \n  if (!alias) {\n    return res.status(400).json({\n      error: \"Alias parameter is required\"\n    });\n  }\n  \n  // Validate format\n  const validation = validateAlias(alias);\n  if (!validation.valid) {\n    return res.status(400).json({\n      error: validation.error,\n      available: false\n    });\n  }\n  \n  try {\n    const users = await readUsers();\n    const exists = aliasExists(users, validation.alias);\n    \n    return res.status(200).json({\n      alias: validation.alias,\n      available: !exists,\n      exists: exists\n    });\n    \n  } catch (error) {\n    console.error('Error checking alias:', error);\n    return res.status(error.status || 500).json({\n      error: error.data?.message || error.message || \"Failed to check alias\"\n    });\n  }\n}\n\n// Handle getting all users (admin/debug)\nasync function handleGetUsers(req, res) {\n  try {\n    const users = await readUsers();\n    \n    // Return sanitized list (no sensitive data)\n    const sanitizedUsers = users.map(user => ({\n      alias: user.alias,\n      permissions: user.permissions || \"user\",\n      blacklisted: user.blacklisted || false\n    }));\n    \n    return res.status(200).json({\n      success: true,\n      count: sanitizedUsers.length,\n      users: sanitizedUsers\n    });\n    \n  } catch (error) {\n    console.error('Error getting users:', error);\n    return res.status(error.status || 500).json({\n      error: error.data?.message || error.message || \"Failed to get users\"\n    });\n  }\n}\n\n// Main handler\nexport default async function handler(req, res) {\n  const { method, query } = req;\n  \n  // Enable CORS\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n  \n  if (method === 'OPTIONS') {\n    return res.status(200).end();\n  }\n  \n  switch (method) {\n    case \"GET\":\n      // If alias query param provided, check existence\n      if (query.alias) {\n        return handleCheckAlias(req, res);\n      }\n      // Otherwise return all users\n      return handleGetUsers(req, res);\n    case \"POST\":\n      return handleCreateUser(req, res);\n    default:\n      return res.status(405).json({ \n        error: \"Method not allowed\",\n        allowed: [\"GET\", \"POST\", \"OPTIONS\"]\n      });\n  }\n}\n","path":null,"size_bytes":7285,"size_tokens":null},"api/upload_test.js":{"content":"const GITHUB_API = \"https://api.github.com\";\nconst PROFANITY_WORDS_URL = \"https://raw.githubusercontent.com/zautumnz/profane-words/refs/heads/master/words.json\";\n\nasync function githubFetch(url, options) {\n  const r = await fetch(url, options);\n  const data = await r.json();\n  if (!r.ok) throw { status: r.status, data };\n  return data;\n}\n\nasync function directoryExists(owner, repo, dir, headers) {\n  try {\n    await githubFetch(\n      `${GITHUB_API}/repos/${owner}/${repo}/contents/${dir}`,\n      { headers }\n    );\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nasync function getFileSha(owner, repo, path, headers) {\n  try {\n    const data = await githubFetch(\n      `${GITHUB_API}/repos/${owner}/${repo}/contents/${path}`,\n      { headers }\n    );\n    return data.sha;\n  } catch {\n    return null;\n  }\n}\n\nasync function fetchProfanityWords() {\n  try {\n    const response = await fetch(PROFANITY_WORDS_URL);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch profanity words: ${response.status}`);\n    }\n    const words = await response.json();\n    return words;\n  } catch (error) {\n    console.error('Error fetching profanity words:', error);\n    return [];\n  }\n}\n\nfunction containsProfanity(text, profanityWords) {\n  if (!text || typeof text !== 'string') return false;\n  \n  const lowerText = text.toLowerCase();\n  for (const word of profanityWords) {\n    if (typeof word === 'string' && word.trim()) {\n      const escapedWord = word.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n      const regex = new RegExp(`\\\\b${escapedWord}\\\\b`, 'i');\n      if (regex.test(text)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction isJsonFile(filename) {\n  if (!filename || typeof filename !== 'string') return false;\n  return filename.toLowerCase().endsWith('.json');\n}\n\nfunction validateFileExtension(filename) {\n  if (!isJsonFile(filename)) {\n    return {\n      valid: false,\n      error: `File \"${filename}\" is not a JSON file. Only .json files are allowed.`\n    };\n  }\n  return { valid: true };\n}\n\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") {\n    return res.status(405).json({ error: \"POST only\" });\n  }\n\n  try {\n    const { dir_name, files } = req.body;\n\n    if (!dir_name || !files || typeof files !== \"object\") {\n      return res.status(400).json({\n        error: \"dir_name and files object required\"\n      });\n    }\n\n    if (!files[\"mod.json\"]) {\n      return res.status(400).json({\n        error: \"Directory must contain mod.json\"\n      });\n    }\n\n    // æ£€æŸ¥æ‰€æœ‰æ–‡ä»¶æ˜¯å¦éƒ½æ˜¯JSONæ–‡ä»¶\n    for (const filename of Object.keys(files)) {\n      const validation = validateFileExtension(filename);\n      if (!validation.valid) {\n        return res.status(400).json({\n          error: validation.error\n        });\n      }\n    }\n\n    // èŽ·å–ä¸é›…è¯æ±‡åˆ—è¡¨\n    const profanityWords = await fetchProfanityWords();\n    if (profanityWords.length === 0) {\n      return res.status(500).json({\n        error: \"Failed to load profanity filter list\"\n      });\n    }\n\n    // æ£€æŸ¥ç›®å½•åæ˜¯å¦åŒ…å«ä¸é›…è¯æ±‡\n    if (containsProfanity(dir_name, profanityWords)) {\n      return res.status(400).json({\n        error: \"Directory name contains prohibited content\"\n      });\n    }\n\n    // æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦åŒ…å«ä¸é›…è¯æ±‡\n    for (const filename of Object.keys(files)) {\n      // æ£€æŸ¥å®Œæ•´è·¯å¾„\n      if (containsProfanity(filename, profanityWords)) {\n        return res.status(400).json({\n          error: `Filename \"${filename}\" contains prohibited content`\n        });\n      }\n      \n      // æ£€æŸ¥è·¯å¾„çš„å„ä¸ªéƒ¨åˆ†\n      const pathParts = filename.split('/');\n      for (const part of pathParts) {\n        if (containsProfanity(part, profanityWords)) {\n          return res.status(400).json({\n            error: `Filename part \"${part}\" contains prohibited content`\n          });\n        }\n      }\n    }\n\n    // æ£€æŸ¥æ–‡ä»¶å†…å®¹æ˜¯å¦åŒ…å«ä¸é›…è¯æ±‡\n    for (const [filename, content] of Object.entries(files)) {\n      if (typeof content !== 'string') continue;\n      \n      // å¦‚æžœä¸æ˜¯base64ç¼–ç çš„å†…å®¹ï¼Œç›´æŽ¥æ£€æŸ¥\n      if (!/^[A-Za-z0-9+/=]+$/.test(content)) {\n        if (containsProfanity(content, profanityWords)) {\n          return res.status(400).json({\n            error: `File \"${filename}\" content contains prohibited content`\n          });\n        }\n      } else {\n        // å¦‚æžœæ˜¯base64ç¼–ç çš„å†…å®¹ï¼Œå…ˆè§£ç å†æ£€æŸ¥\n        try {\n          const decodedContent = Buffer.from(content, 'base64').toString('utf-8');\n          if (containsProfanity(decodedContent, profanityWords)) {\n            return res.status(400).json({\n              error: `File \"${filename}\" content contains prohibited content`\n            });\n          }\n        } catch (decodeError) {\n          // å¦‚æžœè§£ç å¤±è´¥ï¼Œè·³è¿‡å†…å®¹æ£€æŸ¥\n          console.error(`Failed to decode base64 content for file ${filename}:`, decodeError);\n        }\n      }\n    }\n\n    const token = process.env.GITHUB_REST_API;\n    const owner = process.env.GITHUB_USERNAME;\n    const repo = process.env.GITHUB_REPOSITORY;\n\n    const headers = {\n      Authorization: `Bearer ${token}`,\n      Accept: \"application/vnd.github+json\",\n      \"X-GitHub-Api-Version\": \"2022-11-28\"\n    };\n\n    const baseDir = `mods/${dir_name}`;\n\n    // ðŸš« å¦‚æžœç›®å½•å·²å­˜åœ¨ï¼Œæ‹’ç»è¯·æ±‚\n    if (await directoryExists(owner, repo, baseDir, headers)) {\n      return res.status(409).json({\n        error: \"Mod directory already exists\"\n      });\n    }\n\n    const uploaded = [];\n\n    for (const [relativePath, content] of Object.entries(files)) {\n      const fullPath = `${baseDir}/${relativePath}`;\n\n      const encoded =\n        /^[A-Za-z0-9+/=]+$/.test(content)\n          ? content\n          : Buffer.from(content).toString(\"base64\");\n\n      const payload = {\n        message: `Add mod ${dir_name}`,\n        content: encoded\n      };\n\n      await githubFetch(\n        `${GITHUB_API}/repos/${owner}/${repo}/contents/${fullPath}`,\n        {\n          method: \"PUT\",\n          headers,\n          body: JSON.stringify(payload)\n        }\n      );\n\n      uploaded.push(fullPath);\n    }\n\n    return res.status(200).json({\n      success: true,\n      directory: baseDir,\n      files: uploaded\n    });\n\n  } catch (err) {\n    return res.status(err.status || 500).json({\n      error: err.data?.message || err.message || \"Internal server error\"\n    });\n  }\n}","path":null,"size_bytes":6413,"size_tokens":null},"documentation.md":{"content":"# Our Legacy - Complete Modding & Data Structure Documentation\n\nThis comprehensive guide covers the complete structure of Our Legacy RPG, including all game data formats, mod system, and available parameters with examples.\n\n---\n\n## Table of Contents\n1. [File Overview](#file-overview)\n2. [Data Files Structure](#data-files-structure)\n3. [Mod System](#mod-system)\n4. [Complete Parameter Reference](#complete-parameter-reference)\n5. [Examples](#examples)\n6. [Tips & Best Practices](#tips--best-practices)\n\n---\n\n## File Overview\n\n### Base Game Data (`data/` directory)\n- **classes.json** - Player character classes with stats and progression\n- **items.json** - All equipment, weapons, consumables, and accessories\n- **companions.json** - Hireable companions with abilities\n- **enemies.json** - Regular enemies and encounter data\n- **bosses.json** - Boss encounters with multi-phase mechanics\n- **areas.json** - World locations, connections, and shops\n- **shops.json** - Shop definitions with items and purchase limits â­ NEW\n- **missions.json** - Quests and objectives\n- **spells.json** - Magic spells and abilities\n- **effects.json** - Status effects and buffs\n- **crafting.json** - Alchemy recipes and materials\n- **dialogues.json** - NPC and boss dialogue text\n- **dungeons.json** - Dungeon definitions and challenges\n- **weekly_challenges.json** - Recurring challenges\n- **housing.json** - Housing items for home building â­ NEW\n- **farming.json** - Crop definitions for farming system â­ NEW\n- **cutscenes.json** - Interactive story sequences â­ NEW\n\n### Mod Data (`mods/` directory)\nMods can override or extend any base game data files. Each mod folder can contain:\n- Any of the above JSON files (will be merged with base data)\n- **mod.json** - Mod metadata (name, version, enabled status)\n\n---\n\n## Data Files Structure\n\n### 1. CLASSES.JSON\n\n**Purpose**: Define character classes with base stats and progression.\n\n**Parameters**:\n```json\n{\n  \"class_id\": {\n    \"name\": \"string\",                          // Display name\n    \"description\": \"string\",                   // Class flavor text\n    \"base_stats\": {\n      \"max_hp\": number,                        // Starting max HP\n      \"max_mp\": number,                        // Starting max MP\n      \"attack\": number,                        // Attack stat\n      \"defense\": number,                       // Defense stat\n      \"speed\": number                          // Speed/initiative stat\n    },\n    \"level_up_bonuses\": {\n      \"hp\": number,                            // HP gain per level\n      \"mp\": number,                            // MP gain per level\n      \"attack\": number,                        // Attack gain per level\n      \"defense\": number,                       // Defense gain per level\n      \"speed\": number                          // Speed gain per level\n    },\n    \"starting_equipment\": {\n      \"weapon\": \"item_id\",                     // Starting weapon\n      \"armor\": \"item_id\",                      // Starting armor\n      \"accessory\": \"item_id\" or null           // Optional starting accessory\n    },\n    \"rank\": number,                            // Class tier/rarity\n    \"class_skill\": {\n      \"name\": \"string\",\n      \"description\": \"string\",\n      \"effect\": \"string\",\n      \"damage_multiplier\": number              // Optional damage multiplier\n    }\n  }\n}\n```\n\n**Example**:\n```json\n{\n  \"warrior\": {\n    \"name\": \"Warrior\",\n    \"description\": \"A master of melee combat with unmatched strength.\",\n    \"base_stats\": {\n      \"max_hp\": 120,\n      \"max_mp\": 20,\n      \"attack\": 18,\n      \"defense\": 15,\n      \"speed\": 8\n    },\n    \"level_up_bonuses\": {\n      \"hp\": 8,\n      \"mp\": 1,\n      \"attack\": 1.5,\n      \"defense\": 1.2,\n      \"speed\": 0.3\n    },\n    \"starting_equipment\": {\n      \"weapon\": \"iron_sword\",\n      \"armor\": \"leather_armor\",\n      \"accessory\": null\n    },\n    \"rank\": 1,\n    \"class_skill\": {\n      \"name\": \"Cleave\",\n      \"description\": \"Deal massive damage to a single target\",\n      \"effect\": \"damage\",\n      \"damage_multiplier\": 1.8\n    }\n  }\n}\n```\n\n---\n\n### 2. ITEMS.JSON\n\n**Purpose**: Define all equipment, consumables, and items.\n\n**Parameters**:\n```json\n{\n  \"item_id\": {\n    \"name\": \"string\",                          // Display name\n    \"description\": \"string\",                   // Item flavor text\n    \"type\": \"string\",                          // weapon|armor|accessory|consumable|material\n    \"rarity\": \"string\",                        // common|uncommon|rare|legendary\n    \"price\": number,                           // Shop price in gold\n    \"effect\": \"string\",                        // Optional effect (for consumables)\n    \"shop_type\": [\"string\"],                   // Which shop types sell this\n    \"requirements\": {\n      \"level\": number,                         // Minimum level required\n      \"class\": \"string\" or [\"string\"],         // Class requirement(s) or null\n      \"attack\": number,                        // Min attack stat required\n      \"defense\": number                        // Min defense stat required\n    },\n    \"stats\": {\n      \"attack\": number,                        // Weapon/equipment bonus\n      \"defense\": number,                       // Armor/equipment bonus\n      \"hp\": number,                            // Max HP bonus\n      \"mp\": number,                            // Max MP bonus\n      \"speed\": number                          // Speed bonus\n    }\n  }\n}\n```\n\n**Example**:\n```json\n{\n  \"iron_sword\": {\n    \"name\": \"Iron Sword\",\n    \"description\": \"A sturdy blade forged from iron ore.\",\n    \"type\": \"weapon\",\n    \"rarity\": \"common\",\n    \"price\": 50,\n    \"shop_type\": [\"general_store\", \"equipment_shop\"],\n    \"requirements\": {\n      \"level\": 1,\n      \"class\": null,\n      \"attack\": 0,\n      \"defense\": 0\n    },\n    \"stats\": {\n      \"attack\": 8,\n      \"defense\": 0,\n      \"hp\": 0,\n      \"mp\": 0,\n      \"speed\": 0\n    }\n  },\n  \"health_potion\": {\n    \"name\": \"Health Potion\",\n    \"description\": \"Restores 50 HP when consumed.\",\n    \"type\": \"consumable\",\n    \"rarity\": \"common\",\n    \"price\": 25,\n    \"effect\": \"restore_hp\",\n    \"stats\": {\n      \"hp\": 50\n    }\n  }\n}\n```\n\n---\n\n### 3. ENEMIES.JSON\n\n**Purpose**: Define regular enemies encountered during exploration.\n\n**Parameters**:\n```json\n{\n  \"enemy_id\": {\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"hp\": number,\n    \"attack\": number,\n    \"defense\": number,\n    \"speed\": number,\n    \"experience_reward\": number,\n    \"gold_reward\": number,\n    \"possible_drops\": [\"item_id\"],             // Loot table\n    \"drop_rates\": [number],                    // Probability for each item (0-1)\n    \"special_abilities\": [\n      {\n        \"name\": \"string\",\n        \"description\": \"string\",\n        \"damage\": number,\n        \"mp_cost\": number,\n        \"cooldown\": number\n      }\n    ]\n  }\n}\n```\n\n**Example**:\n```json\n{\n  \"goblin\": {\n    \"name\": \"Goblin\",\n    \"description\": \"A small, mischievous creature with sharp teeth.\",\n    \"hp\": 30,\n    \"attack\": 8,\n    \"defense\": 3,\n    \"speed\": 6,\n    \"experience_reward\": 50,\n    \"gold_reward\": 10,\n    \"possible_drops\": [\"leather_armor\", \"copper_coin\"],\n    \"drop_rates\": [0.3, 0.5],\n    \"special_abilities\": [\n      {\n        \"name\": \"Claw Slash\",\n        \"description\": \"A quick slash attack\",\n        \"damage\": 12,\n        \"mp_cost\": 0,\n        \"cooldown\": 2\n      }\n    ]\n  }\n}\n```\n\n---\n\n### 4. BOSSES.JSON\n\n**Purpose**: Define boss encounters with multi-phase mechanics.\n\n**Parameters**:\n```json\n{\n  \"boss_id\": {\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"hp\": number,\n    \"attack\": number,\n    \"defense\": number,\n    \"speed\": number,\n    \"special_abilities\": [\n      {\n        \"name\": \"string\",\n        \"description\": \"string\",\n        \"damage\": number,\n        \"mp_cost\": number,\n        \"cooldown\": number,\n        \"effect\": \"string\",                    // Optional: stun|buff|debuff\n        \"duration\": number                     // Duration if effect present\n      }\n    ],\n    \"phases\": [\n      {\n        \"hp_threshold\": number,                // (0-1) trigger at % HP\n        \"description\": \"string\",\n        \"attack_multiplier\": number,\n        \"defense_multiplier\": number\n      }\n    ],\n    \"experience_reward\": number,\n    \"gold_reward\": number,\n    \"loot_table\": [\"item_id\"],                // Guaranteed drops\n    \"unlock_conditions\": {\n      \"level\": number,\n      \"missions_required\": [\"mission_id\"]\n    },\n    \"dialogues\": {\n      \"on_start_battle\": \"dialogue_key\",\n      \"on_defeat\": \"dialogue_key\"\n    }\n  }\n}\n```\n\n**Example**:\n```json\n{\n  \"fire_dragon\": {\n    \"name\": \"Ancient Fire Dragon\",\n    \"description\": \"A legendary dragon wreathed in flames.\",\n    \"hp\": 300,\n    \"attack\": 35,\n    \"defense\": 20,\n    \"speed\": 15,\n    \"special_abilities\": [\n      {\n        \"name\": \"Fire Breath\",\n        \"description\": \"Deals massive fire damage\",\n        \"damage\": 50,\n        \"mp_cost\": 20,\n        \"cooldown\": 3\n      }\n    ],\n    \"phases\": [\n      {\n        \"hp_threshold\": 0.7,\n        \"description\": \"The dragon fights with typical fury\",\n        \"attack_multiplier\": 1.0,\n        \"defense_multiplier\": 1.0\n      },\n      {\n        \"hp_threshold\": 0.4,\n        \"description\": \"The dragon becomes enraged\",\n        \"attack_multiplier\": 1.3,\n        \"defense_multiplier\": 0.8\n      }\n    ],\n    \"experience_reward\": 1000,\n    \"gold_reward\": 500,\n    \"loot_table\": [\"dragon_scale_armor\", \"fire_gem\"],\n    \"unlock_conditions\": {\n      \"level\": 8,\n      \"missions_required\": []\n    },\n    \"dialogues\": {\n      \"on_start_battle\": \"fire_dragon.boss.start\",\n      \"on_defeat\": \"fire_dragon.boss.defeat\"\n    }\n  }\n}\n```\n\n---\n\n### 5. AREAS.JSON\n\n**Purpose**: Define world locations, connections, and shops.\n\n**Parameters**:\n```json\n{\n  \"area_id\": {\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"possible_enemies\": [\"enemy_id\"],\n    \"possible_bosses\": [\"boss_id\"],\n    \"shops\": [\"shop_id\"],                     // Shop identifiers\n    \"missions_available\": boolean,\n    \"connections\": [\"area_id\"],               // Connected areas\n    \"difficulty\": number,                     // 1-5 difficulty rating\n    \"rest_cost\": number,                      // Gold to rest\n    \"can_rest\": boolean,                      // Can rest in this area\n    \"boss_area\": boolean,                     // Is this a boss area\n    \"area_treasure\": [\"item_id\"]              // Optional treasure\n  }\n}\n```\n\n**Example**:\n```json\n{\n  \"starting_village\": {\n    \"name\": \"Starting Village\",\n    \"description\": \"A peaceful village where new adventurers begin.\",\n    \"possible_enemies\": [\"thief\"],\n    \"possible_bosses\": [],\n    \"shops\": [\"general_store\"],\n    \"missions_available\": true,\n    \"connections\": [\"forest_path\", \"ancient_ruins\"],\n    \"difficulty\": 1,\n    \"rest_cost\": 5,\n    \"can_rest\": true,\n    \"boss_area\": false\n  }\n}\n```\n\n---\n\n### 6. MISSIONS.JSON\n\n**Purpose**: Define quests and objectives.\n\n**Parameters**:\n```json\n{\n  \"mission_id\": {\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"objectives\": [\n      {\n        \"type\": \"string\",                      // kill|collect|explore|defend\n        \"target\": \"string\",                    // Enemy/item/area name\n        \"count\": number,                       // How many needed\n        \"current\": number                      // Current progress\n      }\n    ],\n    \"rewards\": {\n      \"gold\": number,\n      \"experience\": number,\n      \"items\": [\"item_id\"]\n    },\n    \"required_level\": number,\n    \"repeatable\": boolean\n  }\n}\n```\n\n**Example**:\n```json\n{\n  \"goblin_slayer\": {\n    \"name\": \"Goblin Slayer\",\n    \"description\": \"The village is plagued by goblins. Slay 10 of them.\",\n    \"objectives\": [\n      {\n        \"type\": \"kill\",\n        \"target\": \"goblin\",\n        \"count\": 10,\n        \"current\": 0\n      }\n    ],\n    \"rewards\": {\n      \"gold\": 200,\n      \"experience\": 300,\n      \"items\": []\n    },\n    \"required_level\": 1,\n    \"repeatable\": false\n  }\n}\n```\n\n---\n\n### 7. DIALOGUES.JSON\n\n**Purpose**: Store NPC and boss dialogue text.\n\n**Parameters**:\n```json\n{\n  \"dialogue_key\": \"dialogue_text\"\n}\n```\n\n**Example**:\n```json\n{\n  \"fire_dragon.boss.start\": \"The dragon roars as flames erupt around it!\",\n  \"fire_dragon.boss.defeat\": \"The mighty dragon falls, defeated at last.\",\n  \"ethereal_guardian.boss.start\": \"The guardian materializes before you...\",\n  \"merchant_greeting\": \"Welcome, traveler. What can I help you with?\"\n}\n```\n\n---\n\n### 8. DUNGEONS.JSON\n\n**Purpose**: Define procedural dungeons with challenges and rewards.\n\n**Parameters**:\n```json\n{\n  \"dungeons\": [\n    {\n      \"id\": \"dungeon_id\",\n      \"name\": \"string\",\n      \"description\": \"string\",\n      \"difficulty\": [number, number],         // [min, max] difficulty\n      \"rooms\": number,                        // Number of rooms\n      \"boss_id\": \"boss_id\",\n      \"completion_reward\": {\n        \"gold\": number,\n        \"experience\": number,\n        \"items\": [\"item_id\"]\n      },\n      \"room_weights\": {\n        \"battle\": number,                     // Probability weights\n        \"question\": number,\n        \"chest\": number,\n        \"trap_chest\": number,\n        \"multi_choice\": number,\n        \"empty\": number\n      }\n    }\n  ],\n  \"challenge_templates\": {\n    \"question\": {\n      \"types\": [\n        {\n          \"question\": \"string\",\n          \"answer\": \"string\",\n          \"hints\": [\"string\"],\n          \"time_limit\": number,\n          \"success_reward\": {\n            \"gold\": number,\n            \"experience\": number\n          },\n          \"failure_damage\": number\n        }\n      ]\n    },\n    \"selection\": {\n      \"types\": [\n        {\n          \"question\": \"string\",\n          \"options\": [\n            {\n              \"text\": \"string\",\n              \"correct\": boolean,\n              \"reason\": \"string\",\n              \"reward\": {\"gold\": number, \"experience\": number}\n            }\n          ],\n          \"success_reward\": {\"gold\": number, \"experience\": number},\n          \"failure_damage\": number\n        }\n      ]\n    },\n    \"trap\": {\n      \"types\": [\n        {\n          \"description\": \"string\",\n          \"base_damage\": number,\n          \"difficulty\": \"string\"\n        }\n      ]\n    }\n  },\n  \"chest_templates\": {\n    \"small\": {\n      \"name\": \"string\",\n      \"gold_range\": [number, number],\n      \"item_count_range\": [number, number],\n      \"experience\": number,\n      \"item_rarity\": [\"string\"],\n      \"guaranteed_legendary\": number or false\n    }\n  }\n}\n```\n\n**Example**:\n```json\n{\n  \"dungeons\": [\n    {\n      \"id\": \"ethereal_spire\",\n      \"name\": \"Ethereal Spire\",\n      \"description\": \"A mystical tower between worlds.\",\n      \"difficulty\": [4, 5],\n      \"rooms\": 8,\n      \"boss_id\": \"ethereal_guardian\",\n      \"completion_reward\": {\n        \"gold\": 1000,\n        \"experience\": 1800,\n        \"items\": [\"ethereal_crown\"]\n      },\n      \"room_weights\": {\n        \"question\": 35,\n        \"battle\": 25,\n        \"chest\": 15,\n        \"trap_chest\": 10,\n        \"multi_choice\": 10,\n        \"empty\": 5\n      }\n    }\n  ],\n  \"challenge_templates\": {\n    \"question\": {\n      \"types\": [\n        {\n          \"question\": \"What is the name of the magical force?\",\n          \"answer\": \"ether\",\n          \"hints\": [\"It's the substance of magic\", \"Ancient name\"],\n          \"time_limit\": 60,\n          \"success_reward\": {\"gold\": 100, \"experience\": 150},\n          \"failure_damage\": 20\n        }\n      ]\n    }\n  }\n}\n```\n\n---\n\n### 9. CRAFTING.JSON\n\n**Purpose**: Define alchemy recipes and material categories.\n\n**Parameters**:\n```json\n{\n  \"material_categories\": {\n    \"category_name\": [\"material_id\"]\n  },\n  \"recipes\": {\n    \"recipe_id\": {\n      \"name\": \"string\",\n      \"category\": \"string\",                   // Potions|Elixirs|Enchantments|Utility\n      \"rarity\": \"string\",\n      \"skill_requirement\": number,\n      \"materials\": {\n        \"material_id\": number                 // Material: quantity required\n      },\n      \"output\": {\n        \"item_id\": number                     // Item: quantity produced\n      }\n    }\n  }\n}\n```\n\n**Example**:\n```json\n{\n  \"material_categories\": {\n    \"ores\": [\"iron_ore\", \"coal\", \"steel_ingot\"],\n    \"herbs\": [\"herb\", \"mana_herb\", \"spring_water\"],\n    \"crystals\": [\"crystal_shard\", \"fire_gem\", \"ice_crystal\"]\n  },\n  \"recipes\": {\n    \"health_potion\": {\n      \"name\": \"Health Potion\",\n      \"category\": \"Potions\",\n      \"rarity\": \"common\",\n      \"skill_requirement\": 1,\n      \"materials\": {\n        \"herb\": 2,\n        \"spring_water\": 1\n      },\n      \"output\": {\n        \"health_potion\": 1\n      }\n    }\n  }\n}\n```\n\n---\n\n### 10. SPELLS.JSON\n\n**Purpose**: Define magic spells and abilities.\n\n**Parameters**:\n```json\n{\n  \"spell_id\": {\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"damage\": number,\n    \"mp_cost\": number,\n    \"cooldown\": number,\n    \"effect\": \"string\",                       // Optional effect type\n    \"duration\": number,                       // For effects\n    \"range\": \"string\",                        // single|all|ally|self\n    \"required_level\": number,\n    \"class_requirement\": \"string\" or null,\n    \"element\": \"string\"                       // fire|ice|lightning|nature\n  }\n}\n```\n\n---\n\n### 11. COMPANIONS.JSON\n\n**Purpose**: Define hireable companions.\n\n**Parameters**:\n```json\n{\n  \"companion_id\": {\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"cost\": number,                           // Gold to hire\n    \"base_stats\": {\n      \"max_hp\": number,\n      \"max_mp\": number,\n      \"attack\": number,\n      \"defense\": number,\n      \"speed\": number\n    },\n    \"passive_ability\": {\n      \"name\": \"string\",\n      \"description\": \"string\",\n      \"effect\": \"string\"\n    },\n    \"active_ability\": {\n      \"name\": \"string\",\n      \"description\": \"string\",\n      \"damage\": number,\n      \"mp_cost\": number\n    }\n  }\n}\n```\n\n---\n\n## Mod System\n\n### Mod Structure\n```\nmods/\nâ”œâ”€â”€ The Ether/\nâ”‚   â”œâ”€â”€ mod.json                 # Mod metadata\nâ”‚   â”œâ”€â”€ bosses.json              # Optional - extends base bosses\nâ”‚   â”œâ”€â”€ areas.json               # Optional - extends base areas\nâ”‚   â”œâ”€â”€ items.json               # Optional - new items\nâ”‚   â”œâ”€â”€ enemies.json             # Optional - new enemies\nâ”‚   â”œâ”€â”€ dungeons.json            # Optional - new dungeons\nâ”‚   â”œâ”€â”€ dialogues.json           # Optional - new dialogues\nâ”‚   â”œâ”€â”€ classes.json             # Optional - new classes\nâ”‚   â”œâ”€â”€ spells.json              # Optional - new spells\nâ”‚   â”œâ”€â”€ crafting.json            # Optional - new recipes\nâ”‚   â””â”€â”€ ...other files\n```\n\n### mod.json Format\n```json\n{\n  \"name\": \"The Ether\",\n  \"version\": \"1.0.0\",\n  \"author\": \"Your Name\",\n  \"description\": \"Ethereal dungeons and magical encounters\",\n  \"enabled\": true\n}\n```\n\n### How Mods Are Loaded\n1. Base game data loads from `data/` directory\n2. Each enabled mod is scanned for data files\n3. Mod data is merged with base data:\n   - **Arrays** (dungeons): Extended with new entries\n   - **Objects** (items, enemies): Updated/overridden\n   - **Nested objects** (challenge_templates): Merged\n\n---\n\n## Complete Parameter Reference\n\n### Boss Abilities Parameters\n```\nname: string                          - Ability name\ndescription: string                  - What it does\ndamage: number                        - Damage dealt (0 for non-damaging)\nmp_cost: number                       - MP required to use\ncooldown: number                      - Turns between uses\neffect: string (optional)             - stun|buff|debuff|heal|drain\nduration: number (optional)           - How long effect lasts\nignores_defense: boolean (optional)   - Pierce armor\nstun_chance: number 0-1 (optional)   - Probability to stun\nheal_amount: number (optional)        - Health restored\n```\n\n### Item Requirements\n```\nlevel: number                         - Minimum character level\nclass: string|null                    - Class requirement (null = any)\nattack: number                        - Min attack stat\ndefense: number                       - Min defense stat\n```\n\n### Area Difficulty Scales\n- **1**: Beginner (Starting Village, Dark Forest)\n- **2**: Novice (Deep Woods, Ancient Ruins)\n- **3**: Intermediate (Crystal Caves, Spire)\n- **4**: Advanced (Dragon Lair approach, High dungeons)\n- **5**: Legendary (Final areas, End-game content)\n\n### Rarity Tiers\n- **common**: Standard items, low value\n- **uncommon**: Better quality, mid value\n- **rare**: High quality, high value\n- **legendary**: Unique, very high value\n\n---\n\n## Examples\n\n### Example: Creating a New Boss (Mod)\n\nCreate `mods/MyMod/bosses.json`:\n```json\n{\n  \"shadow_king\": {\n    \"name\": \"Shadow King\",\n    \"description\": \"Ruler of the dark realm\",\n    \"hp\": 400,\n    \"attack\": 40,\n    \"defense\": 25,\n    \"speed\": 18,\n    \"special_abilities\": [\n      {\n        \"name\": \"Shadow Strike\",\n        \"description\": \"Strike from darkness\",\n        \"damage\": 45,\n        \"mp_cost\": 25,\n        \"cooldown\": 2\n      }\n    ],\n    \"phases\": [\n      {\n        \"hp_threshold\": 0.5,\n        \"description\": \"The king emerges from shadow\",\n        \"attack_multiplier\": 1.3\n      }\n    ],\n    \"experience_reward\": 2000,\n    \"gold_reward\": 1000,\n    \"loot_table\": [\"shadow_crown\", \"dark_gem\"],\n    \"unlock_conditions\": {\n      \"level\": 12,\n      \"missions_required\": []\n    },\n    \"dialogues\": {\n      \"on_start_battle\": \"shadow_king.boss.start\",\n      \"on_defeat\": \"shadow_king.boss.defeat\"\n    }\n  }\n}\n```\n\n### Example: Creating a New Dungeon (Mod)\n\nCreate `mods/MyMod/dungeons.json`:\n```json\n{\n  \"dungeons\": [\n    {\n      \"id\": \"shadow_castle\",\n      \"name\": \"Shadow Castle\",\n      \"description\": \"A fortress of darkness\",\n      \"difficulty\": [5, 6],\n      \"rooms\": 10,\n      \"boss_id\": \"shadow_king\",\n      \"completion_reward\": {\n        \"gold\": 2000,\n        \"experience\": 3000,\n        \"items\": [\"shadow_crown\"]\n      },\n      \"room_weights\": {\n        \"battle\": 40,\n        \"question\": 20,\n        \"chest\": 15,\n        \"trap_chest\": 15,\n        \"multi_choice\": 5,\n        \"empty\": 5\n      }\n    }\n  ],\n  \"challenge_templates\": {\n    \"question\": {\n      \"types\": [\n        {\n          \"question\": \"What is the color of shadow?\",\n          \"answer\": \"black\",\n          \"hints\": [\"Dark\", \"The absence of light\"],\n          \"time_limit\": 45,\n          \"success_reward\": {\"gold\": 150, \"experience\": 200},\n          \"failure_damage\": 25\n        }\n      ]\n    }\n  }\n}\n```\n\n### Example: Creating New Items (Mod)\n\nCreate `mods/MyMod/items.json`:\n```json\n{\n  \"shadow_sword\": {\n    \"name\": \"Shadow Sword\",\n    \"description\": \"A blade wreathed in darkness\",\n    \"type\": \"weapon\",\n    \"rarity\": \"legendary\",\n    \"price\": 5000,\n    \"shop_type\": [\"dark_market\"],\n    \"requirements\": {\n      \"level\": 10,\n      \"class\": [\"Warrior\", \"Rogue\"],\n      \"attack\": 25,\n      \"defense\": 0\n    },\n    \"stats\": {\n      \"attack\": 35,\n      \"defense\": 0,\n      \"speed\": 5,\n      \"hp\": 0,\n      \"mp\": 0\n    }\n  }\n}\n```\n\n---\n\n### 9. WEEKLY_CHALLENGES.JSON\n\n**Purpose**: Define recurring weekly challenges that players can complete for rewards.\n\n**Structure**: Weekly challenges are organized as an array within a \"challenges\" object.\n\n**Parameters**:\n```json\n{\n  \"challenges\": [\n    {\n      \"id\": \"string\",                          // Unique challenge identifier\n      \"name\": \"string\",                        // Display name\n      \"description\": \"string\",                 // Challenge objective description\n      \"type\": \"string\",                        // Challenge type (see below)\n      \"target\": number,                        // Number to reach for completion\n      \"reward_exp\": number,                    // Experience points reward\n      \"reward_gold\": number,                   // Gold reward,\n      \"reward_items\": [\"item_id\"] (optional),  // Item rewards on completion\n      \"icon\": \"string\" (optional),             // Icon/emoji for display\n      \"difficulty\": \"string\" (optional)        // Difficulty tier (easy/medium/hard)\n    }\n  ]\n}\n```\n\n**Challenge Types**:\n| Type | Description | Tracking | Example |\n|------|-------------|----------|---------|\n| `kill_count` | Defeat a certain number of enemies | Auto-tracked on kill | \"Defeat 10 enemies\" |\n| `mission_count` | Complete a number of missions | Auto-tracked on mission completion | \"Complete 3 missions\" |\n| `level_reach` | Reach a specific character level | Auto-tracked on level up | \"Reach level 10\" |\n| `boss_kill` | Defeat a certain number of bosses | Auto-tracked on boss defeat | \"Defeat 1 boss\" |\n| `dungeon_complete` | Complete a number of dungeons | Auto-tracked on dungeon completion | \"Complete 1 dungeon\" |\n\n**Example**:\n```json\n{\n  \"challenges\": [\n    {\n      \"id\": \"kill_10\",\n      \"name\": \"Monster Hunter\",\n      \"description\": \"Defeat 10 enemies\",\n      \"type\": \"kill_count\",\n      \"target\": 10,\n      \"reward_exp\": 2000,\n      \"reward_gold\": 500,\n      \"icon\": \"âš”ï¸\",\n      \"difficulty\": \"easy\"\n    },\n    {\n      \"id\": \"level_20\",\n      \"name\": \"Power Leveler\",\n      \"description\": \"Reach level 20\",\n      \"type\": \"level_reach\",\n      \"target\": 20,\n      \"reward_exp\": 10000,\n      \"reward_gold\": 5000,\n      \"reward_items\": [\"rare_scroll\"],\n      \"icon\": \"ðŸ“ˆ\",\n      \"difficulty\": \"hard\"\n    },\n    {\n      \"id\": \"dungeon_master\",\n      \"name\": \"Dungeon Explorer\",\n      \"description\": \"Complete 5 dungeons\",\n      \"type\": \"dungeon_complete\",\n      \"target\": 5,\n      \"reward_exp\": 15000,\n      \"reward_gold\": 7500,\n      \"reward_items\": [\"legendary_key\", \"treasure_map\"],\n      \"icon\": \"ðŸ°\",\n      \"difficulty\": \"hard\"\n    }\n  ]\n}\n```\n\n**Mod Merging Behavior**: \n- Mods can add new challenges to the base game challenges\n- Challenges from mods are appended to the base challenge list\n- Challenge IDs must be unique across all loaded mods and base game\n- Progress tracking is automatically initialized for new challenges\n\n---\n\n### 10. SHOPS.JSON â­ NEW\n\n**Purpose**: Define shops available in different areas, including their welcome messages, available items, and purchase limits.\n\n**Parameters**:\n```json\n{\n  \"shop_id\": {\n    \"name\": \"string\",                          // Display name for the shop\n    \"welcome_message\": \"string\",               // Greeting message shown when entering shop\n    \"items\": [\"item_id1\", \"item_id2\"],         // Array of item IDs available for purchase\n    \"max_buy\": number                          // Maximum quantity of each item a player can own (default: 99)\n  }\n}\n```\n\n**Example**:\n```json\n{\n  \"general_store\": {\n    \"name\": \"General Store\",\n    \"welcome_message\": \"Welcome to the General Store! We have all your basic needs covered.\",\n    \"items\": [\"Health Potion\", \"Iron Sword\", \"Leather Armor\"],\n    \"max_buy\": 10\n  }\n}\n```\n\n**Notes**:\n- Shop IDs must match those referenced in `areas.json`\n- Items must exist in `items.json`\n- `max_buy` limits apply per item type (e.g., player can own up to 10 Health Potions)\n- Housing shop is handled separately and not defined here\n\n---\n\n### 11. HOUSING.JSON\n\n**Purpose**: Define housing items that players can purchase and place in their home at \"Your Land\".\n\n**Parameters**:\n```json\n{\n  \"housing_item_id\": {\n    \"name\": \"string\",                          // Display name in Housing Shop\n    \"description\": \"string\",                   // Item description/flavor text\n    \"price\": number,                           // Cost in gold to purchase\n    \"comfort_points\": number,                  // Comfort value for home tier\n    \"rarity\": \"common|uncommon|rare|epic|legendary\",  // Item rarity tier\n    \"type\": \"house|fencing|decoration|garden|farming|training_place|storage|crafting\"  // Item category\n  }\n}\n```\n\n**Housing Item Guidelines**:\n- **Price Range**: 30-20000+ gold (scales with comfort and rarity)\n- **Comfort Points**: 5-1000+ points (typically 1 point per 10-15 gold)\n- **Training Effectiveness** (for `training_place` type items):\n  - Rarity multipliers: common (1.0x), uncommon (1.2x), rare (1.4x), epic (1.6x), legendary (1.8x)\n  - Comfort bonus: +0.1x multiplier per 10 comfort points\n  - Higher quality training facilities = better stat gains from training\n- **Home Tiers** (based on total comfort):\n  - COMMON (0-99): Basic shelter with minimal comfort\n  - UNCOMMON (100-199): Modest home with decent accommodations\n  - RARE (200-499): Well-decorated home with many comforts\n  - EPIC (500-999): Luxurious estate with exceptional amenities\n  - LEGENDARY (1000+): Grand mansion fit for royalty\n\n**Example**:\n```json\n{\n  \"small_tent\": {\n    \"name\": \"Small tent\",\n    \"description\": \"A basic makeshift tent that provides minimal shelter.\",\n    \"price\": 50,\n    \"comfort_points\": 10\n  },\n  \"crystal_greenhouse\": {\n    \"name\": \"Crystal greenhouse\",\n    \"description\": \"A greenhouse made of crystal, perfect for cultivating rare and exotic plants.\",\n    \"price\": 900,\n    \"comfort_points\": 45\n  },\n  \"imperial_palace\": {\n    \"name\": \"Imperial palace with jade walls and diamond encrusted furnishings\",\n    \"description\": \"An extraordinary imperial palace adorned with jade walls and lavish diamond-encrusted furnishings, representing the pinnacle of opulence.\",\n    \"price\": 20000,\n    \"comfort_points\": 1000\n  }\n}\n```\n\n**Purchasing Housing**:\n- Players can purchase multiple copies of the same item (comfort stacks)\n- Housing items appear in Housing Shop in \"Your Land\" area\n- Purchased items contribute to overall home comfort rating\n- Items can be removed from home (refunding comfort points)\n\n**Mod Merging Behavior**:\n- Mods can add new housing items\n- All items from base game and enabled mods appear in Housing Shop\n- No ID conflicts (mod items coexist with base items)\n- Items from all sources contribute equally to comfort\n\n---\n\n### 11. FARMING.JSON\n\n**Purpose**: Define crops and fruits that players can plant and harvest in their farm.\n\n**Parameters**:\n```json\n{\n  \"version\": \"1.0\",\n  \"description\": \"Farming crops and fruits for Our Legacy farming system\",\n  \"crops\": {\n    \"crop_id\": {\n      \"name\": \"string\",                    // Display name\n      \"description\": \"string\",             // Flavor text description\n      \"growth_time\": number,               // Days to mature (1-30)\n      \"harvest_amount\": number,            // Items harvested per plant (1-10)\n      \"sell_price\": number,                // Gold value per harvested item\n      \"rarity\": \"common|uncommon|rare|epic|legendary\",  // Visual rarity indicator\n      \"icon\": \"emoji\"                      // Unicode emoji for display\n    }\n  }\n}\n```\n\n**Example**:\n```json\n{\n  \"version\": \"1.0\",\n  \"description\": \"Farming crops and fruits for Our Legacy farming system\",\n  \"crops\": {\n    \"wheat\": {\n      \"name\": \"Wheat\",\n      \"description\": \"A common grain crop, takes 3 days to mature\",\n      \"growth_time\": 3,\n      \"harvest_amount\": 3,\n      \"sell_price\": 15,\n      \"rarity\": \"common\",\n      \"icon\": \"ðŸŒ¾\"\n    },\n    \"golden_apple\": {\n      \"name\": \"Golden Apple\",\n      \"description\": \"A rare magical fruit that grows on enchanted trees\",\n      \"growth_time\": 14,\n      \"harvest_amount\": 1,\n      \"sell_price\": 500,\n      \"rarity\": \"legendary\",\n      \"icon\": \"ðŸŽ\"\n    }\n  }\n}\n```\n\n**Crop Guidelines**:\n- **growth_time**: 1-7 days for common crops, 8-14 for rare, 15+ for legendary\n- **harvest_amount**: 1-3 for rare items, 4-6 for common, 7+ for abundant crops\n- **sell_price**: Balance based on growth time and rarity (faster/more common = cheaper)\n- **rarity**: Affects visual display and perceived value\n- **icon**: Use relevant food/nature emojis\n\n**Farming Mechanics**:\n- Players plant crops in their farm (requires farm building)\n- Crops take growth_time days to mature\n- Harvest yields harvest_amount items per plant\n- Items can be sold for sell_price gold each\n- No watering or maintenance required (simplified system)\n\n**Mod Merging Behavior**:\n- Mods can add new crops to the crops object\n- New crop IDs are added alongside existing ones\n- No conflicts if IDs are unique\n- All crops from base game and mods appear in farming\n\n---\n\n### 13. CUTSCENES.JSON â­ NEW\n\n**Purpose**: Define interactive story sequences that play during key game events.\n\n**Parameters**:\n```json\n{\n  \"cutscene_id\": {\n    \"id\": \"string\",                          // Unique identifier (matches reference)\n    \"iterable\": boolean,                      // Whether cutscene can replay (default: false)\n    \"content\": {                             // Recursive content structure\n      \"text\": \"string\",                       // Dialogue/text to display\n      \"wait\": number,                         // Seconds to wait before continuing\n      \"choice\": {                             // Optional: player choice branch\n        \"option_key\": {                       // Choice option identifier\n          \"text\": \"string\",                   // Choice prompt text\n          \"wait\": number,                     // Wait time for this choice\n          \"choice\": {                         // Nested choices (recursive)\n            // ... more nested content\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n**Content Structure**:\n- **text**: The narrative text displayed to the player\n- **wait**: Time in seconds to pause before proceeding (allows reading time)\n- **choice**: Optional branching dialogue with player choices\n- **Recursive**: Choices can contain more text, wait, and nested choices\n- **Termination**: Cutscenes end when no more content exists\n\n**Integration Points**:\n- **Areas**: Use `\"first_time_enter_cutscene\": \"cutscene_id\"` to trigger on first area visit\n- **Missions**: Use `\"accept_cutscene\": \"cutscene_id\"` to trigger when accepting a mission\n- **Iterable**: `false` = plays once per game, `true` = can replay on revisit\n\n**Example**:\n```json\n{\n  \"welcome_cutscene\": {\n    \"id\": \"welcome_cutscene\",\n    \"iterable\": false,\n    \"content\": {\n      \"text\": \"Welcome to Our Legacy, adventurer! Your journey begins now.\",\n      \"wait\": 3,\n      \"choice\": {\n        \"continue\": {\n          \"text\": \"Are you ready to embark on this epic adventure?\",\n          \"wait\": 2,\n          \"choice\": {\n            \"yes\": {\n              \"text\": \"Excellent! Let the legend begin...\",\n              \"wait\": 2\n            },\n            \"no\": {\n              \"text\": \"I don't care lol. Just begin!\",\n              \"wait\": 2\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n**Notes**:\n- Cutscenes pause normal gameplay until completed\n- Player choices affect narrative flow but not game mechanics\n- Use meaningful wait times (2-4 seconds) for reading\n- Keep text concise and engaging\n- Test cutscene flow thoroughly before release\n\n**Mod Merging Behavior**:\n- Mods can add new cutscenes to the base game\n- Cutscene IDs must be unique across all loaded content\n- New cutscenes are added alongside existing ones\n- References in areas/missions work with mod cutscenes\n\n---\n\n## Tips & Best Practices\n\n1. **JSON Validation**: Always validate JSON files before loading - invalid JSON will crash the game\n2. **ID Consistency**: Use consistent IDs across files (e.g., boss_id matches boss entry)\n3. **Balance**: Increase difficulty and rewards proportionally\n4. **Testing**: Test mods thoroughly before distribution\n5. **Documentation**: Comment your mod's purpose and changes\n6. **Backup**: Keep backups of original data files\n7. **Version Control**: Track mod versions for compatibility\n8. **Mod Conflicts**: Later-loading mods override earlier ones for same IDs\n9. **Performance**: Keep mod data reasonable in size\n10. **Community**: Share mods via the official repository\n\n---\n\n**For more help, join our community or visit the GitHub repository!**\n","path":null,"size_bytes":35293,"size_tokens":null},"launcher.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nOur Legacy Launcher - Fancy Text UI\nRuns all scripts directly from the same directory.\n\"\"\"\n\nimport os\nimport sys\nimport subprocess\n\n# Custom exception for clean exit (used by GUI wrapper)\nclass LauncherExit(Exception):\n    \"\"\"Exception raised when user wants to exit the launcher\"\"\"\n    pass\n\n# ANSI colors\nBLUE = \"\\033[34m\"\nRESET = \"\\033[0m\"\n\ndef clear():\n    os.system(\"clear\" if os.name != \"nt\" else \"cls\")\n\ndef run_main():\n    subprocess.run([sys.executable, \"main.py\"])\n\ndef run_storyland():\n    subprocess.run([sys.executable, \"storyland.py\"])\n\ndef run_storywrite():\n    # Just execute storywrite.py directly\n    subprocess.run([\"python3\", \"storywrite.py\"])\n\ndef run_chat():\n    # Execute chat.py directly\n    subprocess.run([sys.executable, \"chat.py\"])\n\ndef show_credits():\n    print(BLUE + \"===============================================\")\n    print(\"                Our Legacy Team\")\n    print(\"===============================================\" + RESET)\n    print(\"Andy64lol - Project Lead, Developer\")\n    print()\n    print()\n    print(\"Btw if you're interested in joining please send me an e-mail through andy64xd@gmail.com! (Even though I'm busy normally...)\")\n    print()\n    print()\n    input(\"Press Enter to return to menu...\")\n    clear()\n\ndef main_menu():\n    while True:\n        clear()\n        print(BLUE + \"===============================================\")\n        print(\"             Our Legacy Launcher\")\n        print(\"===============================================\" + RESET)\n        print(f\"{BLUE}1.{RESET} Main game\")\n        print(f\"{BLUE}2.{RESET} Browse mods\")\n        print(f\"{BLUE}3.{RESET} Upload mod\")\n        print(f\"{BLUE}4.{RESET} Chat\")\n        print(f\"{BLUE}5.{RESET} Credits\")\n        print(f\"{BLUE}6.{RESET} Exit\")\n        print(\"_______________________________________________\")\n        choice = input(\"Please enter (1-6): \").strip()\n\n        if choice == \"1\":\n            run_main()\n        elif choice == \"2\":\n            run_storyland()\n        elif choice == \"3\":\n            run_storywrite()\n        elif choice == \"4\":\n            run_chat()\n        elif choice == \"5\":\n            clear()\n            show_credits()\n        elif choice == \"6\":\n            clear()\n            raise LauncherExit()\n        else:\n            input(\"Invalid choice! Press Enter to try again...\")\n\nif __name__ == \"__main__\":\n    clear()\n    try:\n        main_menu()\n    except LauncherExit:\n        pass\n    clear()\n","path":null,"size_bytes":2470,"size_tokens":null},"api/ping.js":{"content":"// api/ping.js\n\nexport default function handler(req, res) {\n  res.status(200).json({\n    ok: true,\n    message: \"Ping successful! Serverless is alive and responding.\",\n    method: req.method,\n    timestamp: Date.now()\n  });\n}","path":null,"size_bytes":225,"size_tokens":null},"MOD_CREATION_GUIDE.md":{"content":"# Our Legacy - Quick Mod Creation Guide\n\nFast reference for creating mods. For detailed documentation, see [documentation.md](documentation.md).\n\n---\n\n## Quick Start: Create Your First Mod\n\n### Step 1: Create Mod Folder\n```bash\nmkdir mods/YourModName\ncd mods/YourModName\n```\n\n### Step 2: Create mod.json\n```json\n{\n  \"name\": \"Your Mod Name\",\n  \"version\": \"1.0.0\",\n  \"author\": \"Your Name\",\n  \"description\": \"Brief description of what your mod adds\",\n  \"enabled\": true\n}\n```\n\n### Step 3: Add Data Files\nCopy any of these files from `data/` and modify them:\n- `bosses.json` - Add/modify bosses\n- `areas.json` - Add/modify locations\n- `items.json` - Add/modify items\n- `enemies.json` - Add/modify enemies\n- `dungeons.json` - Add/modify dungeons\n- `dialogues.json` - Add dialogue text\n- `classes.json` - Add/modify classes\n- `companions.json` - Add companions\n- `spells.json` - Add spells\n- `crafting.json` - Add recipes\n- `weekly_challenges.json` - Add weekly challenges\n- `housing.json` - Add housing items â­ NEW\n- `farming.json` - Add farm crops â­ NEW\n- `cutscenes.json` - Add cutscenes â­ NEW\n\n### Step 4: Test Your Mod\nStart the game: `python3 main.py`\n\n---\n\n### Add Housing Items\n\n**File**: `mods/YourModName/housing.json`\n\n```json\n{\n  \"item_id\": {\n    \"name\": \"Item Display Name\",\n    \"description\": \"Description shown in shop\",\n    \"price\": 500,\n    \"comfort_points\": 25,\n    \"rarity\": \"common\",\n    \"type\": \"house\"\n  },\n  \"training_facility\": {\n    \"name\": \"Training Facility\",\n    \"description\": \"A place to train and improve stats\",\n    \"price\": 1000,\n    \"comfort_points\": 15,\n    \"rarity\": \"rare\",\n    \"type\": \"training_place\"\n  }\n}\n```\n\n**Tips**:\n- Price range: 50-5000g (or more for unique items)\n- Comfort points: 5-250 (scales with price, roughly 1 point per 10g)\n- **Training Effectiveness**: `training_place` buildings improve training results based on rarity and comfort points\n  - Common: 1.0x multiplier\n  - Uncommon: 1.2x multiplier  \n  - Rare: 1.4x multiplier\n  - Epic: 1.6x multiplier\n  - Legendary: 1.8x multiplier\n  - +0.1x per 10 comfort points\n- Use lowercase IDs with underscores: `my_custom_house`\n- Players can purchase multiple copies to stack comfort\n\n---\n\n### Add Farm Crops\n\n**File**: `mods/YourModName/farming.json`\n\n```json\n{\n  \"version\": \"1.0\",\n  \"description\": \"My custom farming crops\",\n  \"crops\": {\n    \"my_crop\": {\n      \"name\": \"My Special Crop\",\n      \"description\": \"A unique crop I created\",\n      \"growth_time\": 5,\n      \"harvest_amount\": 3,\n      \"sell_price\": 50,\n      \"rarity\": \"rare\",\n      \"icon\": \"ðŸŒ±\"\n    },\n    \"magical_fruit\": {\n      \"name\": \"Magical Fruit\",\n      \"description\": \"Grows on enchanted trees\",\n      \"growth_time\": 10,\n      \"harvest_amount\": 1,\n      \"sell_price\": 200,\n      \"rarity\": \"epic\",\n      \"icon\": \"ðŸ‡\"\n    }\n  }\n}\n```\n\n**Tips**:\n- Growth time: 1-7 days for common, 8-14 for rare, 15+ for legendary\n- Harvest amount: 1-3 for rare items, 4-6 for common crops\n- Sell price: Balance with growth time (longer = more valuable)\n- Rarity affects visual display: common, uncommon, rare, epic, legendary\n- Use relevant emojis for icons: ðŸŒ¾ ðŸŒ½ ðŸ… ðŸ¥” etc.\n\n---\n\n**File**: `mods/YourModName/bosses.json`\n\n```json\n{\n  \"your_boss_id\": {\n    \"name\": \"Boss Name\",\n    \"description\": \"What the boss looks like\",\n    \"hp\": 200,\n    \"attack\": 25,\n    \"defense\": 15,\n    \"speed\": 10,\n    \"special_abilities\": [\n      {\n        \"name\": \"Ability Name\",\n        \"description\": \"What it does\",\n        \"damage\": 30,\n        \"mp_cost\": 20,\n        \"cooldown\": 3\n      }\n    ],\n    \"phases\": [\n      {\n        \"hp_threshold\": 0.5,\n        \"description\": \"Second phase description\",\n        \"attack_multiplier\": 1.3,\n        \"defense_multiplier\": 0.9\n      }\n    ],\n    \"experience_reward\": 500,\n    \"gold_reward\": 300,\n    \"loot_table\": [\"item_id\"],\n    \"unlock_conditions\": {\n      \"level\": 5,\n      \"missions_required\": []\n    },\n    \"dialogues\": {\n      \"on_start_battle\": \"your_boss_id.boss.start\",\n      \"on_defeat\": \"your_boss_id.boss.defeat\"\n    }\n  }\n}\n```\n\n**Add Dialogues** - `mods/YourModName/dialogues.json`:\n```json\n{\n  \"your_boss_id.boss.start\": \"The boss appears!\",\n  \"your_boss_id.boss.defeat\": \"The boss falls!\"\n}\n```\n\n---\n\n### Add a New Dungeon\n\n**File**: `mods/YourModName/dungeons.json`\n\n```json\n{\n  \"dungeons\": [\n    {\n      \"id\": \"dungeon_id\",\n      \"name\": \"Dungeon Name\",\n      \"description\": \"Dungeon description\",\n      \"difficulty\": [3, 4],\n      \"rooms\": 7,\n      \"boss_id\": \"your_boss_id\",\n      \"completion_reward\": {\n        \"gold\": 1000,\n        \"experience\": 1500,\n        \"items\": [\"legendary_item\"]\n      },\n      \"room_weights\": {\n        \"battle\": 40,\n        \"question\": 25,\n        \"chest\": 15,\n        \"trap_chest\": 10,\n        \"multi_choice\": 5,\n        \"empty\": 5\n      }\n    }\n  ],\n  \"challenge_templates\": {\n    \"question\": {\n      \"types\": [\n        {\n          \"question\": \"A riddle or question?\",\n          \"answer\": \"the_answer\",\n          \"hints\": [\"Hint 1\", \"Hint 2\"],\n          \"time_limit\": 60,\n          \"success_reward\": {\"gold\": 100, \"experience\": 150},\n          \"failure_damage\": 20\n        }\n      ]\n    },\n    \"selection\": {\n      \"types\": [\n        {\n          \"question\": \"What do you do?\",\n          \"options\": [\n            {\n              \"text\": \"Good choice\",\n              \"correct\": true,\n              \"reason\": \"You succeed!\",\n              \"reward\": {\"gold\": 100, \"experience\": 150}\n            },\n            {\n              \"text\": \"Bad choice\",\n              \"correct\": false,\n              \"reason\": \"You fail!\",\n              \"damage\": 25\n            }\n          ]\n        }\n      ]\n    }\n  },\n  \"chest_templates\": {\n    \"small\": {\n      \"name\": \"Small Chest\",\n      \"gold_range\": [50, 100],\n      \"item_count_range\": [1, 1],\n      \"experience\": 100,\n      \"item_rarity\": [\"common\"],\n      \"guaranteed_legendary\": false\n    }\n  }\n}\n```\n\n---\n\n### Add a New Item\n\n**File**: `mods/YourModName/items.json`\n\n```json\n{\n  \"mythical_sword\": {\n    \"name\": \"Mythical Sword\",\n    \"description\": \"A legendary blade forged by ancient smiths\",\n    \"type\": \"weapon\",\n    \"rarity\": \"legendary\",\n    \"price\": 5000,\n    \"shop_type\": [\"dark_market\", \"artifact_shop\"],\n    \"requirements\": {\n      \"level\": 15,\n      \"class\": [\"Warrior\", \"Paladin\"],\n      \"attack\": 30,\n      \"defense\": 0\n    },\n    \"stats\": {\n      \"attack\": 50,\n      \"defense\": 5,\n      \"hp\": 10,\n      \"mp\": 0,\n      \"speed\": 3\n    }\n  }\n}\n```\n\n---\n\n### Add a New Area\n\n**File**: `mods/YourModName/areas.json`\n\n```json\n{\n  \"mystical_forest\": {\n    \"name\": \"Mystical Forest\",\n    \"description\": \"An ancient, magical forest shrouded in mystery\",\n    \"possible_enemies\": [\"forest_spirit\", \"enchanted_wolf\", \"ancient_treant\"],\n    \"possible_bosses\": [\"forest_guardian\"],\n    \"shops\": [\"nature_shop\"],\n    \"missions_available\": true,\n    \"connections\": [\"starting_village\", \"crystal_caves\"],\n    \"difficulty\": 3,\n    \"rest_cost\": 15,\n    \"can_rest\": true,\n    \"boss_area\": false\n  }\n}\n```\n\n---\n\n### Add a New Enemy\n\n**File**: `mods/YourModName/enemies.json`\n\n```json\n{\n  \"forest_spirit\": {\n    \"name\": \"Forest Spirit\",\n    \"description\": \"A ghostly entity of the ancient woods\",\n    \"hp\": 50,\n    \"attack\": 15,\n    \"defense\": 8,\n    \"speed\": 12,\n    \"experience_reward\": 150,\n    \"gold_reward\": 50,\n    \"possible_drops\": [\"ancient_relic\", \"mana_crystal\"],\n    \"drop_rates\": [0.2, 0.3],\n    \"special_abilities\": [\n      {\n        \"name\": \"Spirit Touch\",\n        \"description\": \"A chilling magical strike\",\n        \"damage\": 20,\n        \"mp_cost\": 15,\n        \"cooldown\": 2\n      }\n    ]\n  }\n}\n```\n\n---\n\n### Add a New Class\n\n**File**: `mods/YourModName/classes.json`\n\n```json\n{\n  \"paladin\": {\n    \"name\": \"Paladin\",\n    \"description\": \"A holy warrior blessed with divine power\",\n    \"base_stats\": {\n      \"max_hp\": 110,\n      \"max_mp\": 40,\n      \"attack\": 16,\n      \"defense\": 16,\n      \"speed\": 8\n    },\n    \"level_up_bonuses\": {\n      \"hp\": 7,\n      \"mp\": 3,\n      \"attack\": 1.2,\n      \"defense\": 1.3,\n      \"speed\": 0.4\n    },\n    \"starting_equipment\": {\n      \"weapon\": \"holy_mace\",\n      \"armor\": \"plate_armor\",\n      \"accessory\": \"holy_symbol\"\n    },\n    \"rank\": 2,\n    \"class_skill\": {\n      \"name\": \"Divine Shield\",\n      \"description\": \"Protect with holy power for 2 turns\",\n      \"effect\": \"shield\",\n      \"defense_bonus\": 30\n    }\n  }\n}\n```\n\n---\n\n### Add Crafting Recipes\n\n**File**: `mods/YourModName/crafting.json`\n\n```json\n{\n  \"material_categories\": {\n    \"exotic\": [\"phoenix_feather\", \"dragon_scale\", \"void_essence\"]\n  },\n  \"recipes\": {\n    \"legendary_sword\": {\n      \"name\": \"Legendary Sword\",\n      \"category\": \"Enchantments\",\n      \"rarity\": \"legendary\",\n      \"skill_requirement\": 15,\n      \"materials\": {\n        \"steel_ingot\": 5,\n        \"ancient_crystal\": 3,\n        \"phoenix_feather\": 1\n      },\n      \"output\": {\n        \"legendary_sword\": 1\n      }\n    }\n  }\n}\n```\n\n---\n\n### Add Weekly Challenges\n\n**File**: `mods/YourModName/weekly_challenges.json`\n\n```json\n{\n  \"challenges\": [\n    {\n      \"id\": \"kill_100\",\n      \"name\": \"Ultimate Slayer\",\n      \"description\": \"Defeat 100 enemies\",\n      \"type\": \"kill_count\",\n      \"target\": 100,\n      \"reward_exp\": 25000,\n      \"reward_gold\": 10000,\n      \"reward_items\": [\"legendary_weapon_mod\"],\n      \"icon\": \"ðŸ’€\",\n      \"difficulty\": \"hard\"\n    },\n    {\n      \"id\": \"reach_level_50\",\n      \"name\": \"Half Century\",\n      \"description\": \"Reach level 50\",\n      \"type\": \"level_reach\",\n      \"target\": 50,\n      \"reward_exp\": 50000,\n      \"reward_gold\": 25000,\n      \"icon\": \"ðŸŽ¯\",\n      \"difficulty\": \"very_hard\"\n    },\n    {\n      \"id\": \"boss_five\",\n      \"name\": \"Boss Mastery\",\n      \"description\": \"Defeat 5 bosses\",\n      \"type\": \"boss_kill\",\n      \"target\": 5,\n      \"reward_exp\": 30000,\n      \"reward_gold\": 15000,\n      \"reward_items\": [\"boss_trophy\"],\n      \"icon\": \"ðŸ‘‘\",\n      \"difficulty\": \"hard\"\n    },\n    {\n      \"id\": \"dungeon_ten\",\n      \"name\": \"Dungeon Master\",\n      \"description\": \"Complete 10 dungeons\",\n      \"type\": \"dungeon_complete\",\n      \"target\": 10,\n      \"reward_exp\": 40000,\n      \"reward_gold\": 20000,\n      \"reward_items\": [\"dungeon_key\"],\n      \"icon\": \"ðŸ—ï¸\",\n      \"difficulty\": \"very_hard\"\n    }\n  ]\n}\n```\n\n**Challenge Types Available**:\n- `kill_count` - Track number of enemies defeated\n- `mission_count` - Track completed missions\n- `level_reach` - Track character level\n- `boss_kill` - Track bosses defeated\n- `dungeon_complete` - Track completed dungeons\n\n**All Parameters Explained**:\n- `id` *(required)* - Unique identifier for the challenge\n- `name` *(required)* - Display name shown to player\n- `description` *(required)* - What player must do\n- `type` *(required)* - One of the challenge types above\n- `target` *(required)* - Number to reach for completion\n- `reward_exp` *(required)* - Experience gained on completion\n- `reward_gold` *(required)* - Gold gained on completion\n- `reward_items` *(optional)* - Array of item IDs to receive\n- `icon` *(optional)* - Emoji or symbol for display\n- `difficulty` *(optional)* - \"easy\", \"medium\", \"hard\", \"very_hard\"\n\n---\n\n### Add Cutscenes\n\n**File**: `mods/YourModName/cutscenes.json`\n\n```json\n{\n  \"your_cutscene\": {\n    \"id\": \"your_cutscene\",\n    \"iterable\": false,\n    \"content\": {\n      \"text\": \"Welcome to this mysterious place...\",\n      \"wait\": 3,\n      \"choice\": {\n        \"investigate\": {\n          \"text\": \"Do you wish to investigate further?\",\n          \"wait\": 2,\n          \"choice\": {\n            \"yes\": {\n              \"text\": \"You discover ancient secrets!\",\n              \"wait\": 3\n            },\n            \"no\": {\n              \"text\": \"You decide to leave it be.\",\n              \"wait\": 2\n            }\n          }\n        },\n        \"leave\": {\n          \"text\": \"Perhaps it's best to leave.\",\n          \"wait\": 2\n        }\n      }\n    }\n  },\n  \"boss_encounter\": {\n    \"id\": \"boss_encounter\",\n    \"iterable\": true,\n    \"content\": {\n      \"text\": \"A powerful enemy appears before you!\",\n      \"wait\": 2,\n      \"choice\": {\n        \"fight\": {\n          \"text\": \"You steel yourself for battle.\",\n          \"wait\": 1\n        },\n        \"flee\": {\n          \"text\": \"Discretion is the better part of valor.\",\n          \"wait\": 1\n        }\n      }\n    }\n  }\n}\n```\n\n**Cutscene Parameters**:\n- `id` *(required)* - Unique identifier for the cutscene\n- `iterable` *(optional)* - If `true`, cutscene plays every time the event triggers. If `false` (default), plays only once\n- `content` *(required)* - The cutscene content structure\n\n**Content Structure**:\n- `text` *(required)* - The dialogue/text to display\n- `wait` *(optional)* - Seconds to wait before continuing (can be skipped with Enter)\n- `choice` *(optional)* - Object with choice options, each containing more content\n\n**Triggering Cutscenes**:\nAdd cutscene references to other data files:\n\n**Areas** (`areas.json`):\n```json\n{\n  \"your_area\": {\n    \"name\": \"Your Area\",\n    \"first_time_enter_cutscene\": \"your_cutscene\",\n    // ... other area data\n  }\n}\n```\n\n**Missions** (`missions.json`):\n```json\n{\n  \"your_mission\": {\n    \"name\": \"Your Mission\",\n    \"accept_cutscene\": \"mission_start_cutscene\",\n    \"complete_cutscene\": \"mission_end_cutscene\",\n    // ... other mission data\n  }\n}\n```\n\n**Tips**:\n- Use `iterable: true` for recurring events (boss fights, spell casts)\n- Use `iterable: false` for one-time events (first area visits, story moments)\n- Choices can be nested infinitely deep\n- Wait times are in seconds and can be skipped by pressing Enter\n- Keep text concise for better player experience\n\n---\n\n## Parameter Quick Reference\n\n### Boss Parameters\n| Parameter | Type | Example |\n|-----------|------|---------|\n| name | string | \"Fire Dragon\" |\n| hp | number | 300 |\n| attack | number | 35 |\n| defense | number | 20 |\n| speed | number | 15 |\n| experience_reward | number | 1000 |\n| gold_reward | number | 500 |\n\n### Item Stats\n| Stat | Effect |\n|------|--------|\n| attack | Increases damage dealt |\n| defense | Reduces damage taken |\n| hp | Increases max health |\n| mp | Increases max mana |\n| speed | Increases turn order priority |\n\n### Rarity Levels\n- `common` - Basic items\n- `uncommon` - Better quality\n- `rare` - High quality\n- `legendary` - Unique/powerful\n\n### Difficulty Scale\n- 1: Beginner\n- 2: Novice\n- 3: Intermediate\n- 4: Advanced\n- 5: Legendary\n\n### Cutscene Parameters\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| id | string | Unique identifier for the cutscene |\n| iterable | boolean | If true, plays every time; if false (default), plays only once |\n| content | object | The cutscene content structure |\n\n### Content Structure\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| text | string | Dialogue/text to display |\n| wait | number | Seconds to wait (skippable with Enter) |\n| choice | object | Choice options with nested content |\n\n### Ability Effects\n- `damage` - Deals damage\n- `stun` - Stuns target\n- `buff` - Buffs stats\n- `debuff` - Debuffs stats\n- `heal` - Heals health\n- `drain` - Drains enemy HP to self\n- `shield` - Adds defense\n- `summon` - Summons allies\n\n---\n\n## Testing Your Mod\n\n1. **Validate JSON**\n   - Use an online JSON validator\n   - Ensure no syntax errors\n\n2. **Check ID References**\n   - Boss IDs match dialogue keys\n   - Item IDs exist in items.json\n   - Enemy IDs exist in enemies.json\n\n3. **Balance Check**\n   - Higher difficulty = more rewards\n   - Boss stats scale with level requirement\n   - Item prices match rarity\n\n4. **In-Game Testing**\n   - Create new character\n   - Visit areas with your content\n   - Fight bosses/enemies\n   - Use dungeons/crafting\n\n---\n\n## Common Issues\n\n**Problem**: Mod doesn't load\n- Check `\"enabled\": true` in mod.json\n- Ensure mod folder is in `mods/` directory\n- Restart the game\n\n**Problem**: Errors in console\n- Validate JSON (missing commas, brackets)\n- Check all referenced IDs exist\n- Review parameter types\n\n**Problem**: Game crashes\n- Check for circular references\n- Ensure no duplicate IDs\n- Validate all stat numbers are positive\n\n---\n\n## Distribution\n\n1. **Prepare Your Mod**\n   - Test thoroughly\n   - Write good mod.json description\n   - Create README if complex\n\n2. **Submit**\n   - Use `storywrite.py` to submit\n   - Or create GitHub PR\n\n3. **Community**\n   - Share on Discord\n   - Get feedback\n   - Update based on suggestions\n\n---\n\n## Need Help?\n\n- **Detailed Docs**: See [documentation.md](documentation.md)\n- **Examples**: Check `mods/The Ether/` for a complete mod\n- **Discord**: Join our community server\n- **GitHub**: Report issues and contribute\n\n---\n\n**Happy modding! Create amazing content for Our Legacy!**\n","path":null,"size_bytes":16581,"size_tokens":null},"storywrite.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nOur Legacy Mod Uploader CLI - Storywrite\nInteractive Text UI Version\n\"\"\"\n\nimport json\nimport os\nimport sys\nimport base64\nimport requests\nfrom pathlib import Path\n\n# Configuration\nAPI_URL = \"https://our-legacy.vercel.app/api/upload_test\"\n\n# Colors\nclass Colors:\n    RESET = '\\033[0m'\n    BOLD = '\\033[1m'\n    RED = '\\033[31m'\n    GREEN = '\\033[32m'\n    YELLOW = '\\033[33m'\n    BLUE = '\\033[34m'\n    CYAN = '\\033[36m'\n    BRIGHT_WHITE = '\\033[97m'\n\n\ndef clear():\n    os.system(\"clear\" if os.name != \"nt\" else \"cls\")\n\n\ndef display_banner():\n    clear()\n    print(f\"{Colors.CYAN}{Colors.BOLD}\")\n    print(\"=\" * 50)\n    print(\"     Our Legacy Mod Uploader: Storywrite\")\n    print(\"=\" * 50)\n    print(f\"{Colors.RESET}\")\n\n\ndef validate_mod_directory(mod_path):\n    path = Path(mod_path)\n    if not path.exists():\n        print(f\"{Colors.RED}Error: Directory '{mod_path}' does not exist.{Colors.RESET}\")\n        return None, None\n    if not path.is_dir():\n        print(f\"{Colors.RED}Error: '{mod_path}' is not a directory.{Colors.RESET}\")\n        return None, None\n\n    mod_json_path = path / \"mod.json\"\n    if not mod_json_path.exists():\n        print(f\"{Colors.RED}Error: Directory must contain 'mod.json'.{Colors.RESET}\")\n        return None, None\n\n    try:\n        with open(mod_json_path, 'r', encoding='utf-8') as f:\n            mod_data = json.load(f)\n        mod_name = mod_data.get('name') or mod_data.get('id') or path.name\n        if not mod_name:\n            print(f\"{Colors.RED}Error: 'mod.json' must contain a 'name' or 'id'.{Colors.RESET}\")\n            return None, None\n    except Exception as e:\n        print(f\"{Colors.RED}Error reading mod.json: {e}{Colors.RESET}\")\n        return None, None\n\n    return path, mod_name\n\n\ndef collect_files(directory_path):\n    files = {}\n    for file_path in directory_path.rglob('*'):\n        if file_path.is_file():\n            rel_path = file_path.relative_to(directory_path)\n            try:\n                with open(file_path, 'rb') as f:\n                    encoded = base64.b64encode(f.read()).decode('utf-8')\n                    files[str(rel_path)] = encoded\n            except Exception as e:\n                print(f\"{Colors.YELLOW}Warning: Could not read file '{rel_path}': {e}{Colors.RESET}\")\n    return files\n\n\ndef upload_mod(mod_path):\n    directory_path, mod_name = validate_mod_directory(mod_path)\n    if directory_path is None:\n        return False\n\n    print(f\"\\n{Colors.CYAN}{Colors.BOLD}Preparing to upload mod:{Colors.RESET} {Colors.BRIGHT_WHITE}{mod_name}{Colors.RESET}\")\n    print(f\"{Colors.BLUE}Directory: {directory_path}{Colors.RESET}\")\n\n    files = collect_files(directory_path)\n    if not files:\n        print(f\"{Colors.RED}Error: No files found in the directory.{Colors.RESET}\")\n        return False\n\n    print(f\"{Colors.GREEN}Found {len(files)} files.{Colors.RESET}\")\n\n    payload = {\"dir_name\": mod_name, \"files\": files}\n    print(f\"\\n{Colors.YELLOW}Uploading to GitHub repository...{Colors.RESET}\")\n\n    try:\n        response = requests.post(API_URL, json=payload)\n        response.raise_for_status()\n        result = response.json()\n        if result.get('success'):\n            print(f\"\\n{Colors.GREEN}{Colors.BOLD}âœ“ Successfully uploaded mod: {mod_name}{Colors.RESET}\")\n            print(f\"\\n{Colors.CYAN}Uploaded Files:{Colors.RESET}\")\n            for file in result.get('files', []):\n                print(f\"  â€¢ {file}\")\n            print(f\"\\n{Colors.BLUE}GitHub Directory: {result.get('directory')}{Colors.RESET}\")\n            return True\n        else:\n            print(f\"\\n{Colors.RED}Error: {result.get('error', 'Unknown error')}{Colors.RESET}\")\n            return False\n    except requests.exceptions.RequestException as e:\n        print(f\"\\n{Colors.RED}Upload failed: {e}{Colors.RESET}\")\n        return False\n\n\ndef select_mod_directory():\n    \"\"\"Let user choose a mod directory interactively.\"\"\"\n    print(f\"{Colors.CYAN}Enter the path to your mod directory:{Colors.RESET}\")\n    mod_path = input(\"> \").strip()\n    return mod_path\n\n\ndef main_menu():\n    while True:\n        display_banner()\n        print(f\"{Colors.BLUE}1.{Colors.RESET} Upload a mod\")\n        print(f\"{Colors.BLUE}2.{Colors.RESET} Exit\")\n        print(\"_______________________________________________\")\n        choice = input(\"Please enter (1-2): \").strip()\n        if choice == \"1\":\n            mod_path = select_mod_directory()\n            success = upload_mod(mod_path)\n            input(\"\\nPress Enter to return to menu...\")\n        elif choice == \"2\":\n            clear()\n            sys.exit(0)\n        else:\n            input(\"Invalid choice! Press Enter to try again...\")\n\n\nif __name__ == \"__main__\":\n    main_menu()","path":null,"size_bytes":4710,"size_tokens":null},"TODO.md":{"content":"# Time and Weather System Implementation\n\n## Tasks:\n- [x] Create TODO.md to track progress\n- [ ] Add TimeSystem class to main.py\n- [ ] Add WeatherSystem class to main.py\n- [ ] Integrate time/weather into Game class __init__\n- [ ] Add time/weather display to main menu\n- [ ] Apply weather bonuses to battle rewards\n- [ ] Time affects farming growth rates\n- [ ] Save/load time and weather state\n- [ ] Weather changes on travel\n- [ ] Add weather forecast option\n- [ ] Test and verify implementation\n","path":null,"size_bytes":496,"size_tokens":null}},"version":2}